/* tslint:disable */
/* eslint-disable */
/**
 * Gitea API.
 * This documentation describes the Gitea API.
 *
 * The version of the OpenAPI document: 1.22.0+dev-191-g0271114e6
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * APIError is an api error with a message
 * @export
 * @interface APIError
 */
export interface APIError {
    /**
     * 
     * @type {string}
     * @memberof APIError
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof APIError
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface AccessToken
 */
export interface AccessToken {
    /**
     * 
     * @type {number}
     * @memberof AccessToken
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccessToken
     */
    'scopes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'sha1'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'token_last_eight'?: string;
}
/**
 * 
 * @export
 * @interface Activity
 */
export interface Activity {
    /**
     * 
     * @type {User}
     * @memberof Activity
     */
    'act_user'?: User;
    /**
     * 
     * @type {number}
     * @memberof Activity
     */
    'act_user_id'?: number;
    /**
     * 
     * @type {Comment}
     * @memberof Activity
     */
    'comment'?: Comment;
    /**
     * 
     * @type {number}
     * @memberof Activity
     */
    'comment_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    'created'?: string;
    /**
     * 
     * @type {number}
     * @memberof Activity
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Activity
     */
    'is_private'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    'op_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    'ref_name'?: string;
    /**
     * 
     * @type {Repository}
     * @memberof Activity
     */
    'repo'?: Repository;
    /**
     * 
     * @type {number}
     * @memberof Activity
     */
    'repo_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Activity
     */
    'user_id'?: number;
}
/**
 * ActivityPub type
 * @export
 * @interface ActivityPub
 */
export interface ActivityPub {
    /**
     * 
     * @type {string}
     * @memberof ActivityPub
     */
    '@context'?: string;
}
/**
 * AddCollaboratorOption options when adding a user as a collaborator of a repository
 * @export
 * @interface AddCollaboratorOption
 */
export interface AddCollaboratorOption {
    /**
     * 
     * @type {string}
     * @memberof AddCollaboratorOption
     */
    'permission'?: string;
}
/**
 * AddTimeOption options for adding time to an issue
 * @export
 * @interface AddTimeOption
 */
export interface AddTimeOption {
    /**
     * 
     * @type {string}
     * @memberof AddTimeOption
     */
    'created'?: string;
    /**
     * time in seconds
     * @type {number}
     * @memberof AddTimeOption
     */
    'time': number;
    /**
     * User who spent the time (optional)
     * @type {string}
     * @memberof AddTimeOption
     */
    'user_name'?: string;
}
/**
 * AnnotatedTag represents an annotated tag
 * @export
 * @interface AnnotatedTag
 */
export interface AnnotatedTag {
    /**
     * 
     * @type {string}
     * @memberof AnnotatedTag
     */
    'message'?: string;
    /**
     * 
     * @type {AnnotatedTagObject}
     * @memberof AnnotatedTag
     */
    'object'?: AnnotatedTagObject;
    /**
     * 
     * @type {string}
     * @memberof AnnotatedTag
     */
    'sha'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotatedTag
     */
    'tag'?: string;
    /**
     * 
     * @type {CommitUser}
     * @memberof AnnotatedTag
     */
    'tagger'?: CommitUser;
    /**
     * 
     * @type {string}
     * @memberof AnnotatedTag
     */
    'url'?: string;
    /**
     * 
     * @type {PayloadCommitVerification}
     * @memberof AnnotatedTag
     */
    'verification'?: PayloadCommitVerification;
}
/**
 * AnnotatedTagObject contains meta information of the tag object
 * @export
 * @interface AnnotatedTagObject
 */
export interface AnnotatedTagObject {
    /**
     * 
     * @type {string}
     * @memberof AnnotatedTagObject
     */
    'sha'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotatedTagObject
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotatedTagObject
     */
    'url'?: string;
}
/**
 * Attachment a generic attachment
 * @export
 * @interface Attachment
 */
export interface Attachment {
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'browser_download_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'created_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof Attachment
     */
    'download_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof Attachment
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Attachment
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'uuid'?: string;
}
/**
 * Branch represents a repository branch
 * @export
 * @interface Branch
 */
export interface Branch {
    /**
     * 
     * @type {PayloadCommit}
     * @memberof Branch
     */
    'commit'?: PayloadCommit;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'effective_branch_protection_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Branch
     */
    'enable_status_check'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Branch
     */
    'protected'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Branch
     */
    'required_approvals'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Branch
     */
    'status_check_contexts'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Branch
     */
    'user_can_merge'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Branch
     */
    'user_can_push'?: boolean;
}
/**
 * BranchProtection represents a branch protection for a repository
 * @export
 * @interface BranchProtection
 */
export interface BranchProtection {
    /**
     * 
     * @type {Array<string>}
     * @memberof BranchProtection
     */
    'approvals_whitelist_teams'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BranchProtection
     */
    'approvals_whitelist_username'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof BranchProtection
     */
    'block_on_official_review_requests'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BranchProtection
     */
    'block_on_outdated_branch'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BranchProtection
     */
    'block_on_rejected_reviews'?: boolean;
    /**
     * Deprecated: true
     * @type {string}
     * @memberof BranchProtection
     */
    'branch_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BranchProtection
     */
    'created_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BranchProtection
     */
    'dismiss_stale_approvals'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BranchProtection
     */
    'enable_approvals_whitelist'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BranchProtection
     */
    'enable_merge_whitelist'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BranchProtection
     */
    'enable_push'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BranchProtection
     */
    'enable_push_whitelist'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BranchProtection
     */
    'enable_status_check'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof BranchProtection
     */
    'merge_whitelist_teams'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BranchProtection
     */
    'merge_whitelist_usernames'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BranchProtection
     */
    'protected_file_patterns'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BranchProtection
     */
    'push_whitelist_deploy_keys'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof BranchProtection
     */
    'push_whitelist_teams'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BranchProtection
     */
    'push_whitelist_usernames'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof BranchProtection
     */
    'require_signed_commits'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BranchProtection
     */
    'required_approvals'?: number;
    /**
     * 
     * @type {string}
     * @memberof BranchProtection
     */
    'rule_name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BranchProtection
     */
    'status_check_contexts'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BranchProtection
     */
    'unprotected_file_patterns'?: string;
    /**
     * 
     * @type {string}
     * @memberof BranchProtection
     */
    'updated_at'?: string;
}
/**
 * ChangeFileOperation for creating, updating or deleting a file
 * @export
 * @interface ChangeFileOperation
 */
export interface ChangeFileOperation {
    /**
     * new or updated file content, must be base64 encoded
     * @type {string}
     * @memberof ChangeFileOperation
     */
    'content'?: string;
    /**
     * old path of the file to move
     * @type {string}
     * @memberof ChangeFileOperation
     */
    'from_path'?: string;
    /**
     * indicates what to do with the file
     * @type {string}
     * @memberof ChangeFileOperation
     */
    'operation': ChangeFileOperationOperationEnum;
    /**
     * path to the existing or new file
     * @type {string}
     * @memberof ChangeFileOperation
     */
    'path': string;
    /**
     * sha is the SHA for the file that already exists, required for update or delete
     * @type {string}
     * @memberof ChangeFileOperation
     */
    'sha'?: string;
}

export const ChangeFileOperationOperationEnum = {
    create: 'create',
    update: 'update',
    delete: 'delete'
} as const;

export type ChangeFileOperationOperationEnum = typeof ChangeFileOperationOperationEnum[keyof typeof ChangeFileOperationOperationEnum];

/**
 * ChangeFilesOptions options for creating, updating or deleting multiple files Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
 * @export
 * @interface ChangeFilesOptions
 */
export interface ChangeFilesOptions {
    /**
     * 
     * @type {Identity}
     * @memberof ChangeFilesOptions
     */
    'author'?: Identity;
    /**
     * branch (optional) to base this file from. if not given, the default branch is used
     * @type {string}
     * @memberof ChangeFilesOptions
     */
    'branch'?: string;
    /**
     * 
     * @type {Identity}
     * @memberof ChangeFilesOptions
     */
    'committer'?: Identity;
    /**
     * 
     * @type {CommitDateOptions}
     * @memberof ChangeFilesOptions
     */
    'dates'?: CommitDateOptions;
    /**
     * list of file operations
     * @type {Array<ChangeFileOperation>}
     * @memberof ChangeFilesOptions
     */
    'files': Array<ChangeFileOperation>;
    /**
     * message (optional) for the commit of this file. if not supplied, a default message will be used
     * @type {string}
     * @memberof ChangeFilesOptions
     */
    'message'?: string;
    /**
     * new_branch (optional) will make a new branch from `branch` before creating the file
     * @type {string}
     * @memberof ChangeFilesOptions
     */
    'new_branch'?: string;
    /**
     * Add a Signed-off-by trailer by the committer at the end of the commit log message.
     * @type {boolean}
     * @memberof ChangeFilesOptions
     */
    'signoff'?: boolean;
}
/**
 * ChangedFile store information about files affected by the pull request
 * @export
 * @interface ChangedFile
 */
export interface ChangedFile {
    /**
     * 
     * @type {number}
     * @memberof ChangedFile
     */
    'additions'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChangedFile
     */
    'changes'?: number;
    /**
     * 
     * @type {string}
     * @memberof ChangedFile
     */
    'contents_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof ChangedFile
     */
    'deletions'?: number;
    /**
     * 
     * @type {string}
     * @memberof ChangedFile
     */
    'filename'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChangedFile
     */
    'html_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChangedFile
     */
    'previous_filename'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChangedFile
     */
    'raw_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChangedFile
     */
    'status'?: string;
}
/**
 * CombinedStatus holds the combined state of several statuses for a single commit
 * @export
 * @interface CombinedStatus
 */
export interface CombinedStatus {
    /**
     * 
     * @type {string}
     * @memberof CombinedStatus
     */
    'commit_url'?: string;
    /**
     * 
     * @type {Repository}
     * @memberof CombinedStatus
     */
    'repository'?: Repository;
    /**
     * 
     * @type {string}
     * @memberof CombinedStatus
     */
    'sha'?: string;
    /**
     * CommitStatusState holds the state of a CommitStatus It can be \"pending\", \"success\", \"error\" and \"failure\"
     * @type {string}
     * @memberof CombinedStatus
     */
    'state'?: string;
    /**
     * 
     * @type {Array<CommitStatus>}
     * @memberof CombinedStatus
     */
    'statuses'?: Array<CommitStatus>;
    /**
     * 
     * @type {number}
     * @memberof CombinedStatus
     */
    'total_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof CombinedStatus
     */
    'url'?: string;
}
/**
 * Comment represents a comment on a commit or issue
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {Array<Attachment>}
     * @memberof Comment
     */
    'assets'?: Array<Attachment>;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'body'?: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'html_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'issue_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'original_author'?: string;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    'original_author_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'pull_request_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'updated_at'?: string;
    /**
     * 
     * @type {User}
     * @memberof Comment
     */
    'user'?: User;
}
/**
 * 
 * @export
 * @interface Commit
 */
export interface Commit {
    /**
     * 
     * @type {User}
     * @memberof Commit
     */
    'author'?: User;
    /**
     * 
     * @type {RepoCommit}
     * @memberof Commit
     */
    'commit'?: RepoCommit;
    /**
     * 
     * @type {User}
     * @memberof Commit
     */
    'committer'?: User;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'created'?: string;
    /**
     * 
     * @type {Array<CommitAffectedFiles>}
     * @memberof Commit
     */
    'files'?: Array<CommitAffectedFiles>;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'html_url'?: string;
    /**
     * 
     * @type {Array<CommitMeta>}
     * @memberof Commit
     */
    'parents'?: Array<CommitMeta>;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'sha'?: string;
    /**
     * 
     * @type {CommitStats}
     * @memberof Commit
     */
    'stats'?: CommitStats;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'url'?: string;
}
/**
 * CommitAffectedFiles store information about files affected by the commit
 * @export
 * @interface CommitAffectedFiles
 */
export interface CommitAffectedFiles {
    /**
     * 
     * @type {string}
     * @memberof CommitAffectedFiles
     */
    'filename'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommitAffectedFiles
     */
    'status'?: string;
}
/**
 * CommitDateOptions store dates for GIT_AUTHOR_DATE and GIT_COMMITTER_DATE
 * @export
 * @interface CommitDateOptions
 */
export interface CommitDateOptions {
    /**
     * 
     * @type {string}
     * @memberof CommitDateOptions
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommitDateOptions
     */
    'committer'?: string;
}
/**
 * 
 * @export
 * @interface CommitMeta
 */
export interface CommitMeta {
    /**
     * 
     * @type {string}
     * @memberof CommitMeta
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommitMeta
     */
    'sha'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommitMeta
     */
    'url'?: string;
}
/**
 * CommitStats is statistics for a RepoCommit
 * @export
 * @interface CommitStats
 */
export interface CommitStats {
    /**
     * 
     * @type {number}
     * @memberof CommitStats
     */
    'additions'?: number;
    /**
     * 
     * @type {number}
     * @memberof CommitStats
     */
    'deletions'?: number;
    /**
     * 
     * @type {number}
     * @memberof CommitStats
     */
    'total'?: number;
}
/**
 * CommitStatus holds a single status of a single Commit
 * @export
 * @interface CommitStatus
 */
export interface CommitStatus {
    /**
     * 
     * @type {string}
     * @memberof CommitStatus
     */
    'context'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommitStatus
     */
    'created_at'?: string;
    /**
     * 
     * @type {User}
     * @memberof CommitStatus
     */
    'creator'?: User;
    /**
     * 
     * @type {string}
     * @memberof CommitStatus
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof CommitStatus
     */
    'id'?: number;
    /**
     * CommitStatusState holds the state of a CommitStatus It can be \"pending\", \"success\", \"error\" and \"failure\"
     * @type {string}
     * @memberof CommitStatus
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommitStatus
     */
    'target_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommitStatus
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommitStatus
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface CommitUser
 */
export interface CommitUser {
    /**
     * 
     * @type {string}
     * @memberof CommitUser
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommitUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommitUser
     */
    'name'?: string;
}
/**
 * ContentsResponse contains information about a repo\'s entry\'s (dir, file, symlink, submodule) metadata and content
 * @export
 * @interface ContentsResponse
 */
export interface ContentsResponse {
    /**
     * 
     * @type {FileLinksResponse}
     * @memberof ContentsResponse
     */
    '_links'?: FileLinksResponse;
    /**
     * `content` is populated when `type` is `file`, otherwise null
     * @type {string}
     * @memberof ContentsResponse
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentsResponse
     */
    'download_url'?: string;
    /**
     * `encoding` is populated when `type` is `file`, otherwise null
     * @type {string}
     * @memberof ContentsResponse
     */
    'encoding'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentsResponse
     */
    'git_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentsResponse
     */
    'html_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentsResponse
     */
    'last_commit_sha'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentsResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentsResponse
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentsResponse
     */
    'sha'?: string;
    /**
     * 
     * @type {number}
     * @memberof ContentsResponse
     */
    'size'?: number;
    /**
     * `submodule_git_url` is populated when `type` is `submodule`, otherwise null
     * @type {string}
     * @memberof ContentsResponse
     */
    'submodule_git_url'?: string;
    /**
     * `target` is populated when `type` is `symlink`, otherwise null
     * @type {string}
     * @memberof ContentsResponse
     */
    'target'?: string;
    /**
     * `type` will be `file`, `dir`, `symlink`, or `submodule`
     * @type {string}
     * @memberof ContentsResponse
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentsResponse
     */
    'url'?: string;
}
/**
 * CreateAccessTokenOption options when create access token
 * @export
 * @interface CreateAccessTokenOption
 */
export interface CreateAccessTokenOption {
    /**
     * 
     * @type {string}
     * @memberof CreateAccessTokenOption
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateAccessTokenOption
     */
    'scopes'?: Array<string>;
}
/**
 * CreateBranchProtectionOption options for creating a branch protection
 * @export
 * @interface CreateBranchProtectionOption
 */
export interface CreateBranchProtectionOption {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateBranchProtectionOption
     */
    'approvals_whitelist_teams'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateBranchProtectionOption
     */
    'approvals_whitelist_username'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof CreateBranchProtectionOption
     */
    'block_on_official_review_requests'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateBranchProtectionOption
     */
    'block_on_outdated_branch'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateBranchProtectionOption
     */
    'block_on_rejected_reviews'?: boolean;
    /**
     * Deprecated: true
     * @type {string}
     * @memberof CreateBranchProtectionOption
     */
    'branch_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateBranchProtectionOption
     */
    'dismiss_stale_approvals'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateBranchProtectionOption
     */
    'enable_approvals_whitelist'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateBranchProtectionOption
     */
    'enable_merge_whitelist'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateBranchProtectionOption
     */
    'enable_push'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateBranchProtectionOption
     */
    'enable_push_whitelist'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateBranchProtectionOption
     */
    'enable_status_check'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateBranchProtectionOption
     */
    'merge_whitelist_teams'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateBranchProtectionOption
     */
    'merge_whitelist_usernames'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateBranchProtectionOption
     */
    'protected_file_patterns'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateBranchProtectionOption
     */
    'push_whitelist_deploy_keys'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateBranchProtectionOption
     */
    'push_whitelist_teams'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateBranchProtectionOption
     */
    'push_whitelist_usernames'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof CreateBranchProtectionOption
     */
    'require_signed_commits'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateBranchProtectionOption
     */
    'required_approvals'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateBranchProtectionOption
     */
    'rule_name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateBranchProtectionOption
     */
    'status_check_contexts'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateBranchProtectionOption
     */
    'unprotected_file_patterns'?: string;
}
/**
 * CreateBranchRepoOption options when creating a branch in a repository
 * @export
 * @interface CreateBranchRepoOption
 */
export interface CreateBranchRepoOption {
    /**
     * Name of the branch to create
     * @type {string}
     * @memberof CreateBranchRepoOption
     */
    'new_branch_name': string;
    /**
     * Deprecated: true Name of the old branch to create from
     * @type {string}
     * @memberof CreateBranchRepoOption
     */
    'old_branch_name'?: string;
    /**
     * Name of the old branch/tag/commit to create from
     * @type {string}
     * @memberof CreateBranchRepoOption
     */
    'old_ref_name'?: string;
}
/**
 * CreateEmailOption options when creating email addresses
 * @export
 * @interface CreateEmailOption
 */
export interface CreateEmailOption {
    /**
     * email addresses to add
     * @type {Array<string>}
     * @memberof CreateEmailOption
     */
    'emails'?: Array<string>;
}
/**
 * CreateFileOptions options for creating files Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
 * @export
 * @interface CreateFileOptions
 */
export interface CreateFileOptions {
    /**
     * 
     * @type {Identity}
     * @memberof CreateFileOptions
     */
    'author'?: Identity;
    /**
     * branch (optional) to base this file from. if not given, the default branch is used
     * @type {string}
     * @memberof CreateFileOptions
     */
    'branch'?: string;
    /**
     * 
     * @type {Identity}
     * @memberof CreateFileOptions
     */
    'committer'?: Identity;
    /**
     * content must be base64 encoded
     * @type {string}
     * @memberof CreateFileOptions
     */
    'content': string;
    /**
     * 
     * @type {CommitDateOptions}
     * @memberof CreateFileOptions
     */
    'dates'?: CommitDateOptions;
    /**
     * message (optional) for the commit of this file. if not supplied, a default message will be used
     * @type {string}
     * @memberof CreateFileOptions
     */
    'message'?: string;
    /**
     * new_branch (optional) will make a new branch from `branch` before creating the file
     * @type {string}
     * @memberof CreateFileOptions
     */
    'new_branch'?: string;
    /**
     * Add a Signed-off-by trailer by the committer at the end of the commit log message.
     * @type {boolean}
     * @memberof CreateFileOptions
     */
    'signoff'?: boolean;
}
/**
 * CreateForkOption options for creating a fork
 * @export
 * @interface CreateForkOption
 */
export interface CreateForkOption {
    /**
     * name of the forked repository
     * @type {string}
     * @memberof CreateForkOption
     */
    'name'?: string;
    /**
     * organization name, if forking into an organization
     * @type {string}
     * @memberof CreateForkOption
     */
    'organization'?: string;
}
/**
 * CreateGPGKeyOption options create user GPG key
 * @export
 * @interface CreateGPGKeyOption
 */
export interface CreateGPGKeyOption {
    /**
     * An armored GPG key to add
     * @type {string}
     * @memberof CreateGPGKeyOption
     */
    'armored_public_key': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGPGKeyOption
     */
    'armored_signature'?: string;
}
/**
 * CreateHookOption options when create a hook
 * @export
 * @interface CreateHookOption
 */
export interface CreateHookOption {
    /**
     * 
     * @type {boolean}
     * @memberof CreateHookOption
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateHookOption
     */
    'authorization_header'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateHookOption
     */
    'branch_filter'?: string;
    /**
     * CreateHookOptionConfig has all config options in it required are \"content_type\" and \"url\" Required
     * @type {{ [key: string]: string; }}
     * @memberof CreateHookOption
     */
    'config': { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateHookOption
     */
    'events'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateHookOption
     */
    'type': CreateHookOptionTypeEnum;
}

export const CreateHookOptionTypeEnum = {
    dingtalk: 'dingtalk',
    discord: 'discord',
    gitea: 'gitea',
    gogs: 'gogs',
    msteams: 'msteams',
    slack: 'slack',
    telegram: 'telegram',
    feishu: 'feishu',
    wechatwork: 'wechatwork',
    packagist: 'packagist'
} as const;

export type CreateHookOptionTypeEnum = typeof CreateHookOptionTypeEnum[keyof typeof CreateHookOptionTypeEnum];

/**
 * CreateIssueCommentOption options for creating a comment on an issue
 * @export
 * @interface CreateIssueCommentOption
 */
export interface CreateIssueCommentOption {
    /**
     * 
     * @type {string}
     * @memberof CreateIssueCommentOption
     */
    'body': string;
}
/**
 * CreateIssueOption options to create one issue
 * @export
 * @interface CreateIssueOption
 */
export interface CreateIssueOption {
    /**
     * deprecated
     * @type {string}
     * @memberof CreateIssueOption
     */
    'assignee'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateIssueOption
     */
    'assignees'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateIssueOption
     */
    'body'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateIssueOption
     */
    'closed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateIssueOption
     */
    'due_date'?: string;
    /**
     * list of label ids
     * @type {Array<number>}
     * @memberof CreateIssueOption
     */
    'labels'?: Array<number>;
    /**
     * milestone id
     * @type {number}
     * @memberof CreateIssueOption
     */
    'milestone'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateIssueOption
     */
    'ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateIssueOption
     */
    'title': string;
}
/**
 * CreateKeyOption options when creating a key
 * @export
 * @interface CreateKeyOption
 */
export interface CreateKeyOption {
    /**
     * An armored SSH key to add
     * @type {string}
     * @memberof CreateKeyOption
     */
    'key': string;
    /**
     * Describe if the key has only read access or read/write
     * @type {boolean}
     * @memberof CreateKeyOption
     */
    'read_only'?: boolean;
    /**
     * Title of the key to add
     * @type {string}
     * @memberof CreateKeyOption
     */
    'title': string;
}
/**
 * CreateLabelOption options for creating a label
 * @export
 * @interface CreateLabelOption
 */
export interface CreateLabelOption {
    /**
     * 
     * @type {string}
     * @memberof CreateLabelOption
     */
    'color': string;
    /**
     * 
     * @type {string}
     * @memberof CreateLabelOption
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateLabelOption
     */
    'exclusive'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateLabelOption
     */
    'is_archived'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateLabelOption
     */
    'name': string;
}
/**
 * CreateMilestoneOption options for creating a milestone
 * @export
 * @interface CreateMilestoneOption
 */
export interface CreateMilestoneOption {
    /**
     * 
     * @type {string}
     * @memberof CreateMilestoneOption
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMilestoneOption
     */
    'due_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMilestoneOption
     */
    'state'?: CreateMilestoneOptionStateEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateMilestoneOption
     */
    'title'?: string;
}

export const CreateMilestoneOptionStateEnum = {
    open: 'open',
    closed: 'closed'
} as const;

export type CreateMilestoneOptionStateEnum = typeof CreateMilestoneOptionStateEnum[keyof typeof CreateMilestoneOptionStateEnum];

/**
 * CreateOAuth2ApplicationOptions holds options to create an oauth2 application
 * @export
 * @interface CreateOAuth2ApplicationOptions
 */
export interface CreateOAuth2ApplicationOptions {
    /**
     * 
     * @type {boolean}
     * @memberof CreateOAuth2ApplicationOptions
     */
    'confidential_client'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateOAuth2ApplicationOptions
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateOAuth2ApplicationOptions
     */
    'redirect_uris'?: Array<string>;
}
/**
 * CreateOrUpdateSecretOption options when creating or updating secret
 * @export
 * @interface CreateOrUpdateSecretOption
 */
export interface CreateOrUpdateSecretOption {
    /**
     * Data of the secret to update
     * @type {string}
     * @memberof CreateOrUpdateSecretOption
     */
    'data': string;
}
/**
 * CreateOrgOption options for creating an organization
 * @export
 * @interface CreateOrgOption
 */
export interface CreateOrgOption {
    /**
     * 
     * @type {string}
     * @memberof CreateOrgOption
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrgOption
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrgOption
     */
    'full_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrgOption
     */
    'location'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOrgOption
     */
    'repo_admin_change_team_access'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateOrgOption
     */
    'username': string;
    /**
     * possible values are `public` (default), `limited` or `private`
     * @type {string}
     * @memberof CreateOrgOption
     */
    'visibility'?: CreateOrgOptionVisibilityEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateOrgOption
     */
    'website'?: string;
}

export const CreateOrgOptionVisibilityEnum = {
    public: 'public',
    limited: 'limited',
    private: 'private'
} as const;

export type CreateOrgOptionVisibilityEnum = typeof CreateOrgOptionVisibilityEnum[keyof typeof CreateOrgOptionVisibilityEnum];

/**
 * CreatePullRequestOption options when creating a pull request
 * @export
 * @interface CreatePullRequestOption
 */
export interface CreatePullRequestOption {
    /**
     * 
     * @type {string}
     * @memberof CreatePullRequestOption
     */
    'assignee'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreatePullRequestOption
     */
    'assignees'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreatePullRequestOption
     */
    'base'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePullRequestOption
     */
    'body'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePullRequestOption
     */
    'due_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePullRequestOption
     */
    'head'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreatePullRequestOption
     */
    'labels'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof CreatePullRequestOption
     */
    'milestone'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreatePullRequestOption
     */
    'title'?: string;
}
/**
 * CreatePullReviewComment represent a review comment for creation api
 * @export
 * @interface CreatePullReviewComment
 */
export interface CreatePullReviewComment {
    /**
     * 
     * @type {string}
     * @memberof CreatePullReviewComment
     */
    'body'?: string;
    /**
     * if comment to new file line or 0
     * @type {number}
     * @memberof CreatePullReviewComment
     */
    'new_position'?: number;
    /**
     * if comment to old file line or 0
     * @type {number}
     * @memberof CreatePullReviewComment
     */
    'old_position'?: number;
    /**
     * the tree path
     * @type {string}
     * @memberof CreatePullReviewComment
     */
    'path'?: string;
}
/**
 * CreatePullReviewOptions are options to create a pull review
 * @export
 * @interface CreatePullReviewOptions
 */
export interface CreatePullReviewOptions {
    /**
     * 
     * @type {string}
     * @memberof CreatePullReviewOptions
     */
    'body'?: string;
    /**
     * 
     * @type {Array<CreatePullReviewComment>}
     * @memberof CreatePullReviewOptions
     */
    'comments'?: Array<CreatePullReviewComment>;
    /**
     * 
     * @type {string}
     * @memberof CreatePullReviewOptions
     */
    'commit_id'?: string;
    /**
     * ReviewStateType review state type
     * @type {string}
     * @memberof CreatePullReviewOptions
     */
    'event'?: string;
}
/**
 * 
 * @export
 * @interface CreatePushMirrorOption
 */
export interface CreatePushMirrorOption {
    /**
     * 
     * @type {string}
     * @memberof CreatePushMirrorOption
     */
    'interval'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePushMirrorOption
     */
    'remote_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePushMirrorOption
     */
    'remote_password'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePushMirrorOption
     */
    'remote_username'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePushMirrorOption
     */
    'sync_on_commit'?: boolean;
}
/**
 * CreateReleaseOption options when creating a release
 * @export
 * @interface CreateReleaseOption
 */
export interface CreateReleaseOption {
    /**
     * 
     * @type {string}
     * @memberof CreateReleaseOption
     */
    'body'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateReleaseOption
     */
    'draft'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateReleaseOption
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateReleaseOption
     */
    'prerelease'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateReleaseOption
     */
    'tag_name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateReleaseOption
     */
    'target_commitish'?: string;
}
/**
 * CreateRepoOption options when creating repository
 * @export
 * @interface CreateRepoOption
 */
export interface CreateRepoOption {
    /**
     * Whether the repository should be auto-initialized?
     * @type {boolean}
     * @memberof CreateRepoOption
     */
    'auto_init'?: boolean;
    /**
     * DefaultBranch of the repository (used when initializes and in template)
     * @type {string}
     * @memberof CreateRepoOption
     */
    'default_branch'?: string;
    /**
     * Description of the repository to create
     * @type {string}
     * @memberof CreateRepoOption
     */
    'description'?: string;
    /**
     * Gitignores to use
     * @type {string}
     * @memberof CreateRepoOption
     */
    'gitignores'?: string;
    /**
     * Label-Set to use
     * @type {string}
     * @memberof CreateRepoOption
     */
    'issue_labels'?: string;
    /**
     * License to use
     * @type {string}
     * @memberof CreateRepoOption
     */
    'license'?: string;
    /**
     * Name of the repository to create
     * @type {string}
     * @memberof CreateRepoOption
     */
    'name': string;
    /**
     * Whether the repository is private
     * @type {boolean}
     * @memberof CreateRepoOption
     */
    'private'?: boolean;
    /**
     * Readme of the repository to create
     * @type {string}
     * @memberof CreateRepoOption
     */
    'readme'?: string;
    /**
     * Whether the repository is template
     * @type {boolean}
     * @memberof CreateRepoOption
     */
    'template'?: boolean;
    /**
     * TrustModel of the repository
     * @type {string}
     * @memberof CreateRepoOption
     */
    'trust_model'?: CreateRepoOptionTrustModelEnum;
}

export const CreateRepoOptionTrustModelEnum = {
    default: 'default',
    collaborator: 'collaborator',
    committer: 'committer',
    collaboratorcommitter: 'collaboratorcommitter'
} as const;

export type CreateRepoOptionTrustModelEnum = typeof CreateRepoOptionTrustModelEnum[keyof typeof CreateRepoOptionTrustModelEnum];

/**
 * CreateStatusOption holds the information needed to create a new CommitStatus for a Commit
 * @export
 * @interface CreateStatusOption
 */
export interface CreateStatusOption {
    /**
     * 
     * @type {string}
     * @memberof CreateStatusOption
     */
    'context'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateStatusOption
     */
    'description'?: string;
    /**
     * CommitStatusState holds the state of a CommitStatus It can be \"pending\", \"success\", \"error\" and \"failure\"
     * @type {string}
     * @memberof CreateStatusOption
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateStatusOption
     */
    'target_url'?: string;
}
/**
 * CreateTagOption options when creating a tag
 * @export
 * @interface CreateTagOption
 */
export interface CreateTagOption {
    /**
     * 
     * @type {string}
     * @memberof CreateTagOption
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTagOption
     */
    'tag_name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTagOption
     */
    'target'?: string;
}
/**
 * CreateTeamOption options for creating a team
 * @export
 * @interface CreateTeamOption
 */
export interface CreateTeamOption {
    /**
     * 
     * @type {boolean}
     * @memberof CreateTeamOption
     */
    'can_create_org_repo'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateTeamOption
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateTeamOption
     */
    'includes_all_repositories'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateTeamOption
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTeamOption
     */
    'permission'?: CreateTeamOptionPermissionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateTeamOption
     */
    'units'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateTeamOption
     */
    'units_map'?: { [key: string]: string; };
}

export const CreateTeamOptionPermissionEnum = {
    read: 'read',
    write: 'write',
    admin: 'admin'
} as const;

export type CreateTeamOptionPermissionEnum = typeof CreateTeamOptionPermissionEnum[keyof typeof CreateTeamOptionPermissionEnum];

/**
 * CreateUserOption create user options
 * @export
 * @interface CreateUserOption
 */
export interface CreateUserOption {
    /**
     * For explicitly setting the user creation timestamp. Useful when users are migrated from other systems. When omitted, the user\'s creation timestamp will be set to \"now\".
     * @type {string}
     * @memberof CreateUserOption
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserOption
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserOption
     */
    'full_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserOption
     */
    'login_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUserOption
     */
    'must_change_password'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateUserOption
     */
    'password': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUserOption
     */
    'restricted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUserOption
     */
    'send_notify'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateUserOption
     */
    'source_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateUserOption
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserOption
     */
    'visibility'?: string;
}
/**
 * CreateWikiPageOptions form for creating wiki
 * @export
 * @interface CreateWikiPageOptions
 */
export interface CreateWikiPageOptions {
    /**
     * content must be base64 encoded
     * @type {string}
     * @memberof CreateWikiPageOptions
     */
    'content_base64'?: string;
    /**
     * optional commit message summarizing the change
     * @type {string}
     * @memberof CreateWikiPageOptions
     */
    'message'?: string;
    /**
     * page title. leave empty to keep unchanged
     * @type {string}
     * @memberof CreateWikiPageOptions
     */
    'title'?: string;
}
/**
 * Cron represents a Cron task
 * @export
 * @interface Cron
 */
export interface Cron {
    /**
     * 
     * @type {number}
     * @memberof Cron
     */
    'exec_times'?: number;
    /**
     * 
     * @type {string}
     * @memberof Cron
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Cron
     */
    'next'?: string;
    /**
     * 
     * @type {string}
     * @memberof Cron
     */
    'prev'?: string;
    /**
     * 
     * @type {string}
     * @memberof Cron
     */
    'schedule'?: string;
}
/**
 * DeleteEmailOption options when deleting email addresses
 * @export
 * @interface DeleteEmailOption
 */
export interface DeleteEmailOption {
    /**
     * email addresses to delete
     * @type {Array<string>}
     * @memberof DeleteEmailOption
     */
    'emails'?: Array<string>;
}
/**
 * DeleteFileOptions options for deleting files (used for other File structs below) Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
 * @export
 * @interface DeleteFileOptions
 */
export interface DeleteFileOptions {
    /**
     * 
     * @type {Identity}
     * @memberof DeleteFileOptions
     */
    'author'?: Identity;
    /**
     * branch (optional) to base this file from. if not given, the default branch is used
     * @type {string}
     * @memberof DeleteFileOptions
     */
    'branch'?: string;
    /**
     * 
     * @type {Identity}
     * @memberof DeleteFileOptions
     */
    'committer'?: Identity;
    /**
     * 
     * @type {CommitDateOptions}
     * @memberof DeleteFileOptions
     */
    'dates'?: CommitDateOptions;
    /**
     * message (optional) for the commit of this file. if not supplied, a default message will be used
     * @type {string}
     * @memberof DeleteFileOptions
     */
    'message'?: string;
    /**
     * new_branch (optional) will make a new branch from `branch` before creating the file
     * @type {string}
     * @memberof DeleteFileOptions
     */
    'new_branch'?: string;
    /**
     * sha is the SHA for the file that already exists
     * @type {string}
     * @memberof DeleteFileOptions
     */
    'sha': string;
    /**
     * Add a Signed-off-by trailer by the committer at the end of the commit log message.
     * @type {boolean}
     * @memberof DeleteFileOptions
     */
    'signoff'?: boolean;
}
/**
 * DeployKey a deploy key
 * @export
 * @interface DeployKey
 */
export interface DeployKey {
    /**
     * 
     * @type {string}
     * @memberof DeployKey
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeployKey
     */
    'fingerprint'?: string;
    /**
     * 
     * @type {number}
     * @memberof DeployKey
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeployKey
     */
    'key'?: string;
    /**
     * 
     * @type {number}
     * @memberof DeployKey
     */
    'key_id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DeployKey
     */
    'read_only'?: boolean;
    /**
     * 
     * @type {Repository}
     * @memberof DeployKey
     */
    'repository'?: Repository;
    /**
     * 
     * @type {string}
     * @memberof DeployKey
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeployKey
     */
    'url'?: string;
}
/**
 * DismissPullReviewOptions are options to dismiss a pull review
 * @export
 * @interface DismissPullReviewOptions
 */
export interface DismissPullReviewOptions {
    /**
     * 
     * @type {string}
     * @memberof DismissPullReviewOptions
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DismissPullReviewOptions
     */
    'priors'?: boolean;
}
/**
 * EditAttachmentOptions options for editing attachments
 * @export
 * @interface EditAttachmentOptions
 */
export interface EditAttachmentOptions {
    /**
     * 
     * @type {string}
     * @memberof EditAttachmentOptions
     */
    'name'?: string;
}
/**
 * EditBranchProtectionOption options for editing a branch protection
 * @export
 * @interface EditBranchProtectionOption
 */
export interface EditBranchProtectionOption {
    /**
     * 
     * @type {Array<string>}
     * @memberof EditBranchProtectionOption
     */
    'approvals_whitelist_teams'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EditBranchProtectionOption
     */
    'approvals_whitelist_username'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof EditBranchProtectionOption
     */
    'block_on_official_review_requests'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditBranchProtectionOption
     */
    'block_on_outdated_branch'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditBranchProtectionOption
     */
    'block_on_rejected_reviews'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditBranchProtectionOption
     */
    'dismiss_stale_approvals'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditBranchProtectionOption
     */
    'enable_approvals_whitelist'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditBranchProtectionOption
     */
    'enable_merge_whitelist'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditBranchProtectionOption
     */
    'enable_push'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditBranchProtectionOption
     */
    'enable_push_whitelist'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditBranchProtectionOption
     */
    'enable_status_check'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof EditBranchProtectionOption
     */
    'merge_whitelist_teams'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EditBranchProtectionOption
     */
    'merge_whitelist_usernames'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EditBranchProtectionOption
     */
    'protected_file_patterns'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EditBranchProtectionOption
     */
    'push_whitelist_deploy_keys'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof EditBranchProtectionOption
     */
    'push_whitelist_teams'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EditBranchProtectionOption
     */
    'push_whitelist_usernames'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof EditBranchProtectionOption
     */
    'require_signed_commits'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof EditBranchProtectionOption
     */
    'required_approvals'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof EditBranchProtectionOption
     */
    'status_check_contexts'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EditBranchProtectionOption
     */
    'unprotected_file_patterns'?: string;
}
/**
 * EditDeadlineOption options for creating a deadline
 * @export
 * @interface EditDeadlineOption
 */
export interface EditDeadlineOption {
    /**
     * 
     * @type {string}
     * @memberof EditDeadlineOption
     */
    'due_date': string;
}
/**
 * EditGitHookOption options when modifying one Git hook
 * @export
 * @interface EditGitHookOption
 */
export interface EditGitHookOption {
    /**
     * 
     * @type {string}
     * @memberof EditGitHookOption
     */
    'content'?: string;
}
/**
 * EditHookOption options when modify one hook
 * @export
 * @interface EditHookOption
 */
export interface EditHookOption {
    /**
     * 
     * @type {boolean}
     * @memberof EditHookOption
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EditHookOption
     */
    'authorization_header'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditHookOption
     */
    'branch_filter'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof EditHookOption
     */
    'config'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof EditHookOption
     */
    'events'?: Array<string>;
}
/**
 * EditIssueCommentOption options for editing a comment
 * @export
 * @interface EditIssueCommentOption
 */
export interface EditIssueCommentOption {
    /**
     * 
     * @type {string}
     * @memberof EditIssueCommentOption
     */
    'body': string;
}
/**
 * EditIssueOption options for editing an issue
 * @export
 * @interface EditIssueOption
 */
export interface EditIssueOption {
    /**
     * deprecated
     * @type {string}
     * @memberof EditIssueOption
     */
    'assignee'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EditIssueOption
     */
    'assignees'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EditIssueOption
     */
    'body'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditIssueOption
     */
    'due_date'?: string;
    /**
     * 
     * @type {number}
     * @memberof EditIssueOption
     */
    'milestone'?: number;
    /**
     * 
     * @type {string}
     * @memberof EditIssueOption
     */
    'ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditIssueOption
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditIssueOption
     */
    'title'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EditIssueOption
     */
    'unset_due_date'?: boolean;
}
/**
 * EditLabelOption options for editing a label
 * @export
 * @interface EditLabelOption
 */
export interface EditLabelOption {
    /**
     * 
     * @type {string}
     * @memberof EditLabelOption
     */
    'color'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditLabelOption
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EditLabelOption
     */
    'exclusive'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditLabelOption
     */
    'is_archived'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EditLabelOption
     */
    'name'?: string;
}
/**
 * EditMilestoneOption options for editing a milestone
 * @export
 * @interface EditMilestoneOption
 */
export interface EditMilestoneOption {
    /**
     * 
     * @type {string}
     * @memberof EditMilestoneOption
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditMilestoneOption
     */
    'due_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditMilestoneOption
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditMilestoneOption
     */
    'title'?: string;
}
/**
 * EditOrgOption options for editing an organization
 * @export
 * @interface EditOrgOption
 */
export interface EditOrgOption {
    /**
     * 
     * @type {string}
     * @memberof EditOrgOption
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditOrgOption
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditOrgOption
     */
    'full_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditOrgOption
     */
    'location'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EditOrgOption
     */
    'repo_admin_change_team_access'?: boolean;
    /**
     * possible values are `public`, `limited` or `private`
     * @type {string}
     * @memberof EditOrgOption
     */
    'visibility'?: EditOrgOptionVisibilityEnum;
    /**
     * 
     * @type {string}
     * @memberof EditOrgOption
     */
    'website'?: string;
}

export const EditOrgOptionVisibilityEnum = {
    public: 'public',
    limited: 'limited',
    private: 'private'
} as const;

export type EditOrgOptionVisibilityEnum = typeof EditOrgOptionVisibilityEnum[keyof typeof EditOrgOptionVisibilityEnum];

/**
 * EditPullRequestOption options when modify pull request
 * @export
 * @interface EditPullRequestOption
 */
export interface EditPullRequestOption {
    /**
     * 
     * @type {boolean}
     * @memberof EditPullRequestOption
     */
    'allow_maintainer_edit'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EditPullRequestOption
     */
    'assignee'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EditPullRequestOption
     */
    'assignees'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EditPullRequestOption
     */
    'base'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditPullRequestOption
     */
    'body'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditPullRequestOption
     */
    'due_date'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof EditPullRequestOption
     */
    'labels'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof EditPullRequestOption
     */
    'milestone'?: number;
    /**
     * 
     * @type {string}
     * @memberof EditPullRequestOption
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditPullRequestOption
     */
    'title'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EditPullRequestOption
     */
    'unset_due_date'?: boolean;
}
/**
 * EditReactionOption contain the reaction type
 * @export
 * @interface EditReactionOption
 */
export interface EditReactionOption {
    /**
     * 
     * @type {string}
     * @memberof EditReactionOption
     */
    'content'?: string;
}
/**
 * EditReleaseOption options when editing a release
 * @export
 * @interface EditReleaseOption
 */
export interface EditReleaseOption {
    /**
     * 
     * @type {string}
     * @memberof EditReleaseOption
     */
    'body'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EditReleaseOption
     */
    'draft'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EditReleaseOption
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EditReleaseOption
     */
    'prerelease'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EditReleaseOption
     */
    'tag_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditReleaseOption
     */
    'target_commitish'?: string;
}
/**
 * EditRepoOption options when editing a repository\'s properties
 * @export
 * @interface EditRepoOption
 */
export interface EditRepoOption {
    /**
     * either `true` to allow mark pr as merged manually, or `false` to prevent it.
     * @type {boolean}
     * @memberof EditRepoOption
     */
    'allow_manual_merge'?: boolean;
    /**
     * either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.
     * @type {boolean}
     * @memberof EditRepoOption
     */
    'allow_merge_commits'?: boolean;
    /**
     * either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
     * @type {boolean}
     * @memberof EditRepoOption
     */
    'allow_rebase'?: boolean;
    /**
     * either `true` to allow rebase with explicit merge commits (--no-ff), or `false` to prevent rebase with explicit merge commits.
     * @type {boolean}
     * @memberof EditRepoOption
     */
    'allow_rebase_explicit'?: boolean;
    /**
     * either `true` to allow updating pull request branch by rebase, or `false` to prevent it.
     * @type {boolean}
     * @memberof EditRepoOption
     */
    'allow_rebase_update'?: boolean;
    /**
     * either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
     * @type {boolean}
     * @memberof EditRepoOption
     */
    'allow_squash_merge'?: boolean;
    /**
     * set to `true` to archive this repository.
     * @type {boolean}
     * @memberof EditRepoOption
     */
    'archived'?: boolean;
    /**
     * either `true` to enable AutodetectManualMerge, or `false` to prevent it. Note: In some special cases, misjudgments can occur.
     * @type {boolean}
     * @memberof EditRepoOption
     */
    'autodetect_manual_merge'?: boolean;
    /**
     * set to `true` to allow edits from maintainers by default
     * @type {boolean}
     * @memberof EditRepoOption
     */
    'default_allow_maintainer_edit'?: boolean;
    /**
     * sets the default branch for this repository.
     * @type {string}
     * @memberof EditRepoOption
     */
    'default_branch'?: string;
    /**
     * set to `true` to delete pr branch after merge by default
     * @type {boolean}
     * @memberof EditRepoOption
     */
    'default_delete_branch_after_merge'?: boolean;
    /**
     * set to a merge style to be used by this repository: \"merge\", \"rebase\", \"rebase-merge\", or \"squash\".
     * @type {string}
     * @memberof EditRepoOption
     */
    'default_merge_style'?: string;
    /**
     * a short description of the repository.
     * @type {string}
     * @memberof EditRepoOption
     */
    'description'?: string;
    /**
     * enable prune - remove obsolete remote-tracking references
     * @type {boolean}
     * @memberof EditRepoOption
     */
    'enable_prune'?: boolean;
    /**
     * 
     * @type {ExternalTracker}
     * @memberof EditRepoOption
     */
    'external_tracker'?: ExternalTracker;
    /**
     * 
     * @type {ExternalWiki}
     * @memberof EditRepoOption
     */
    'external_wiki'?: ExternalWiki;
    /**
     * either `true` to enable actions unit, or `false` to disable them.
     * @type {boolean}
     * @memberof EditRepoOption
     */
    'has_actions'?: boolean;
    /**
     * either `true` to enable issues for this repository or `false` to disable them.
     * @type {boolean}
     * @memberof EditRepoOption
     */
    'has_issues'?: boolean;
    /**
     * either `true` to enable packages unit, or `false` to disable them.
     * @type {boolean}
     * @memberof EditRepoOption
     */
    'has_packages'?: boolean;
    /**
     * either `true` to enable project unit, or `false` to disable them.
     * @type {boolean}
     * @memberof EditRepoOption
     */
    'has_projects'?: boolean;
    /**
     * either `true` to allow pull requests, or `false` to prevent pull request.
     * @type {boolean}
     * @memberof EditRepoOption
     */
    'has_pull_requests'?: boolean;
    /**
     * either `true` to enable releases unit, or `false` to disable them.
     * @type {boolean}
     * @memberof EditRepoOption
     */
    'has_releases'?: boolean;
    /**
     * either `true` to enable the wiki for this repository or `false` to disable it.
     * @type {boolean}
     * @memberof EditRepoOption
     */
    'has_wiki'?: boolean;
    /**
     * either `true` to ignore whitespace for conflicts, or `false` to not ignore whitespace.
     * @type {boolean}
     * @memberof EditRepoOption
     */
    'ignore_whitespace_conflicts'?: boolean;
    /**
     * 
     * @type {InternalTracker}
     * @memberof EditRepoOption
     */
    'internal_tracker'?: InternalTracker;
    /**
     * set to a string like `8h30m0s` to set the mirror interval time
     * @type {string}
     * @memberof EditRepoOption
     */
    'mirror_interval'?: string;
    /**
     * name of the repository
     * @type {string}
     * @memberof EditRepoOption
     */
    'name'?: string;
    /**
     * either `true` to make the repository private or `false` to make it public. Note: you will get a 422 error if the organization restricts changing repository visibility to organization owners and a non-owner tries to change the value of private.
     * @type {boolean}
     * @memberof EditRepoOption
     */
    'private'?: boolean;
    /**
     * either `true` to make this repository a template or `false` to make it a normal repository
     * @type {boolean}
     * @memberof EditRepoOption
     */
    'template'?: boolean;
    /**
     * a URL with more information about the repository.
     * @type {string}
     * @memberof EditRepoOption
     */
    'website'?: string;
}
/**
 * EditTeamOption options for editing a team
 * @export
 * @interface EditTeamOption
 */
export interface EditTeamOption {
    /**
     * 
     * @type {boolean}
     * @memberof EditTeamOption
     */
    'can_create_org_repo'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EditTeamOption
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EditTeamOption
     */
    'includes_all_repositories'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EditTeamOption
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EditTeamOption
     */
    'permission'?: EditTeamOptionPermissionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof EditTeamOption
     */
    'units'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof EditTeamOption
     */
    'units_map'?: { [key: string]: string; };
}

export const EditTeamOptionPermissionEnum = {
    read: 'read',
    write: 'write',
    admin: 'admin'
} as const;

export type EditTeamOptionPermissionEnum = typeof EditTeamOptionPermissionEnum[keyof typeof EditTeamOptionPermissionEnum];

/**
 * EditUserOption edit user options
 * @export
 * @interface EditUserOption
 */
export interface EditUserOption {
    /**
     * 
     * @type {boolean}
     * @memberof EditUserOption
     */
    'active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditUserOption
     */
    'admin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditUserOption
     */
    'allow_create_organization'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditUserOption
     */
    'allow_git_hook'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditUserOption
     */
    'allow_import_local'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EditUserOption
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditUserOption
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditUserOption
     */
    'full_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditUserOption
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditUserOption
     */
    'login_name': string;
    /**
     * 
     * @type {number}
     * @memberof EditUserOption
     */
    'max_repo_creation'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EditUserOption
     */
    'must_change_password'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EditUserOption
     */
    'password'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EditUserOption
     */
    'prohibit_login'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditUserOption
     */
    'restricted'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof EditUserOption
     */
    'source_id': number;
    /**
     * 
     * @type {string}
     * @memberof EditUserOption
     */
    'visibility'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditUserOption
     */
    'website'?: string;
}
/**
 * Email an email address belonging to a user
 * @export
 * @interface Email
 */
export interface Email {
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Email
     */
    'primary'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Email
     */
    'user_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    'username'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Email
     */
    'verified'?: boolean;
}
/**
 * ExternalTracker represents settings for external tracker
 * @export
 * @interface ExternalTracker
 */
export interface ExternalTracker {
    /**
     * External Issue Tracker URL Format. Use the placeholders {user}, {repo} and {index} for the username, repository name and issue index.
     * @type {string}
     * @memberof ExternalTracker
     */
    'external_tracker_format'?: string;
    /**
     * External Issue Tracker issue regular expression
     * @type {string}
     * @memberof ExternalTracker
     */
    'external_tracker_regexp_pattern'?: string;
    /**
     * External Issue Tracker Number Format, either `numeric`, `alphanumeric`, or `regexp`
     * @type {string}
     * @memberof ExternalTracker
     */
    'external_tracker_style'?: string;
    /**
     * URL of external issue tracker.
     * @type {string}
     * @memberof ExternalTracker
     */
    'external_tracker_url'?: string;
}
/**
 * ExternalWiki represents setting for external wiki
 * @export
 * @interface ExternalWiki
 */
export interface ExternalWiki {
    /**
     * URL of external wiki.
     * @type {string}
     * @memberof ExternalWiki
     */
    'external_wiki_url'?: string;
}
/**
 * 
 * @export
 * @interface FileCommitResponse
 */
export interface FileCommitResponse {
    /**
     * 
     * @type {CommitUser}
     * @memberof FileCommitResponse
     */
    'author'?: CommitUser;
    /**
     * 
     * @type {CommitUser}
     * @memberof FileCommitResponse
     */
    'committer'?: CommitUser;
    /**
     * 
     * @type {string}
     * @memberof FileCommitResponse
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileCommitResponse
     */
    'html_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileCommitResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<CommitMeta>}
     * @memberof FileCommitResponse
     */
    'parents'?: Array<CommitMeta>;
    /**
     * 
     * @type {string}
     * @memberof FileCommitResponse
     */
    'sha'?: string;
    /**
     * 
     * @type {CommitMeta}
     * @memberof FileCommitResponse
     */
    'tree'?: CommitMeta;
    /**
     * 
     * @type {string}
     * @memberof FileCommitResponse
     */
    'url'?: string;
}
/**
 * FileDeleteResponse contains information about a repo\'s file that was deleted
 * @export
 * @interface FileDeleteResponse
 */
export interface FileDeleteResponse {
    /**
     * 
     * @type {FileCommitResponse}
     * @memberof FileDeleteResponse
     */
    'commit'?: FileCommitResponse;
    /**
     * 
     * @type {object}
     * @memberof FileDeleteResponse
     */
    'content'?: object;
    /**
     * 
     * @type {PayloadCommitVerification}
     * @memberof FileDeleteResponse
     */
    'verification'?: PayloadCommitVerification;
}
/**
 * FileLinksResponse contains the links for a repo\'s file
 * @export
 * @interface FileLinksResponse
 */
export interface FileLinksResponse {
    /**
     * 
     * @type {string}
     * @memberof FileLinksResponse
     */
    'git'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileLinksResponse
     */
    'html'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileLinksResponse
     */
    'self'?: string;
}
/**
 * FileResponse contains information about a repo\'s file
 * @export
 * @interface FileResponse
 */
export interface FileResponse {
    /**
     * 
     * @type {FileCommitResponse}
     * @memberof FileResponse
     */
    'commit'?: FileCommitResponse;
    /**
     * 
     * @type {ContentsResponse}
     * @memberof FileResponse
     */
    'content'?: ContentsResponse;
    /**
     * 
     * @type {PayloadCommitVerification}
     * @memberof FileResponse
     */
    'verification'?: PayloadCommitVerification;
}
/**
 * FilesResponse contains information about multiple files from a repo
 * @export
 * @interface FilesResponse
 */
export interface FilesResponse {
    /**
     * 
     * @type {FileCommitResponse}
     * @memberof FilesResponse
     */
    'commit'?: FileCommitResponse;
    /**
     * 
     * @type {Array<ContentsResponse>}
     * @memberof FilesResponse
     */
    'files'?: Array<ContentsResponse>;
    /**
     * 
     * @type {PayloadCommitVerification}
     * @memberof FilesResponse
     */
    'verification'?: PayloadCommitVerification;
}
/**
 * GPGKey a user GPG key to sign commit and tag in repository
 * @export
 * @interface GPGKey
 */
export interface GPGKey {
    /**
     * 
     * @type {boolean}
     * @memberof GPGKey
     */
    'can_certify'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GPGKey
     */
    'can_encrypt_comms'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GPGKey
     */
    'can_encrypt_storage'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GPGKey
     */
    'can_sign'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GPGKey
     */
    'created_at'?: string;
    /**
     * 
     * @type {Array<GPGKeyEmail>}
     * @memberof GPGKey
     */
    'emails'?: Array<GPGKeyEmail>;
    /**
     * 
     * @type {string}
     * @memberof GPGKey
     */
    'expires_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof GPGKey
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GPGKey
     */
    'key_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GPGKey
     */
    'primary_key_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GPGKey
     */
    'public_key'?: string;
    /**
     * 
     * @type {Array<GPGKey>}
     * @memberof GPGKey
     */
    'subkeys'?: Array<GPGKey>;
    /**
     * 
     * @type {boolean}
     * @memberof GPGKey
     */
    'verified'?: boolean;
}
/**
 * GPGKeyEmail an email attached to a GPGKey
 * @export
 * @interface GPGKeyEmail
 */
export interface GPGKeyEmail {
    /**
     * 
     * @type {string}
     * @memberof GPGKeyEmail
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GPGKeyEmail
     */
    'verified'?: boolean;
}
/**
 * GeneralAPISettings contains global api settings exposed by it
 * @export
 * @interface GeneralAPISettings
 */
export interface GeneralAPISettings {
    /**
     * 
     * @type {number}
     * @memberof GeneralAPISettings
     */
    'default_git_trees_per_page'?: number;
    /**
     * 
     * @type {number}
     * @memberof GeneralAPISettings
     */
    'default_max_blob_size'?: number;
    /**
     * 
     * @type {number}
     * @memberof GeneralAPISettings
     */
    'default_paging_num'?: number;
    /**
     * 
     * @type {number}
     * @memberof GeneralAPISettings
     */
    'max_response_items'?: number;
}
/**
 * GeneralAttachmentSettings contains global Attachment settings exposed by API
 * @export
 * @interface GeneralAttachmentSettings
 */
export interface GeneralAttachmentSettings {
    /**
     * 
     * @type {string}
     * @memberof GeneralAttachmentSettings
     */
    'allowed_types'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GeneralAttachmentSettings
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GeneralAttachmentSettings
     */
    'max_files'?: number;
    /**
     * 
     * @type {number}
     * @memberof GeneralAttachmentSettings
     */
    'max_size'?: number;
}
/**
 * GeneralRepoSettings contains global repository settings exposed by API
 * @export
 * @interface GeneralRepoSettings
 */
export interface GeneralRepoSettings {
    /**
     * 
     * @type {boolean}
     * @memberof GeneralRepoSettings
     */
    'http_git_disabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GeneralRepoSettings
     */
    'lfs_disabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GeneralRepoSettings
     */
    'migrations_disabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GeneralRepoSettings
     */
    'mirrors_disabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GeneralRepoSettings
     */
    'stars_disabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GeneralRepoSettings
     */
    'time_tracking_disabled'?: boolean;
}
/**
 * GeneralUISettings contains global ui settings exposed by API
 * @export
 * @interface GeneralUISettings
 */
export interface GeneralUISettings {
    /**
     * 
     * @type {Array<string>}
     * @memberof GeneralUISettings
     */
    'allowed_reactions'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GeneralUISettings
     */
    'custom_emojis'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GeneralUISettings
     */
    'default_theme'?: string;
}
/**
 * GenerateRepoOption options when creating repository using a template
 * @export
 * @interface GenerateRepoOption
 */
export interface GenerateRepoOption {
    /**
     * include avatar of the template repo
     * @type {boolean}
     * @memberof GenerateRepoOption
     */
    'avatar'?: boolean;
    /**
     * Default branch of the new repository
     * @type {string}
     * @memberof GenerateRepoOption
     */
    'default_branch'?: string;
    /**
     * Description of the repository to create
     * @type {string}
     * @memberof GenerateRepoOption
     */
    'description'?: string;
    /**
     * include git content of default branch in template repo
     * @type {boolean}
     * @memberof GenerateRepoOption
     */
    'git_content'?: boolean;
    /**
     * include git hooks in template repo
     * @type {boolean}
     * @memberof GenerateRepoOption
     */
    'git_hooks'?: boolean;
    /**
     * include labels in template repo
     * @type {boolean}
     * @memberof GenerateRepoOption
     */
    'labels'?: boolean;
    /**
     * Name of the repository to create
     * @type {string}
     * @memberof GenerateRepoOption
     */
    'name': string;
    /**
     * The organization or person who will own the new repository
     * @type {string}
     * @memberof GenerateRepoOption
     */
    'owner': string;
    /**
     * Whether the repository is private
     * @type {boolean}
     * @memberof GenerateRepoOption
     */
    'private'?: boolean;
    /**
     * include protected branches in template repo
     * @type {boolean}
     * @memberof GenerateRepoOption
     */
    'protected_branch'?: boolean;
    /**
     * include topics in template repo
     * @type {boolean}
     * @memberof GenerateRepoOption
     */
    'topics'?: boolean;
    /**
     * include webhooks in template repo
     * @type {boolean}
     * @memberof GenerateRepoOption
     */
    'webhooks'?: boolean;
}
/**
 * GitBlobResponse represents a git blob
 * @export
 * @interface GitBlobResponse
 */
export interface GitBlobResponse {
    /**
     * 
     * @type {string}
     * @memberof GitBlobResponse
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof GitBlobResponse
     */
    'encoding'?: string;
    /**
     * 
     * @type {string}
     * @memberof GitBlobResponse
     */
    'sha'?: string;
    /**
     * 
     * @type {number}
     * @memberof GitBlobResponse
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof GitBlobResponse
     */
    'url'?: string;
}
/**
 * GitEntry represents a git tree
 * @export
 * @interface GitEntry
 */
export interface GitEntry {
    /**
     * 
     * @type {string}
     * @memberof GitEntry
     */
    'mode'?: string;
    /**
     * 
     * @type {string}
     * @memberof GitEntry
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof GitEntry
     */
    'sha'?: string;
    /**
     * 
     * @type {number}
     * @memberof GitEntry
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof GitEntry
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof GitEntry
     */
    'url'?: string;
}
/**
 * GitHook represents a Git repository hook
 * @export
 * @interface GitHook
 */
export interface GitHook {
    /**
     * 
     * @type {string}
     * @memberof GitHook
     */
    'content'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GitHook
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GitHook
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface GitObject
 */
export interface GitObject {
    /**
     * 
     * @type {string}
     * @memberof GitObject
     */
    'sha'?: string;
    /**
     * 
     * @type {string}
     * @memberof GitObject
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof GitObject
     */
    'url'?: string;
}
/**
 * GitTreeResponse returns a git tree
 * @export
 * @interface GitTreeResponse
 */
export interface GitTreeResponse {
    /**
     * 
     * @type {number}
     * @memberof GitTreeResponse
     */
    'page'?: number;
    /**
     * 
     * @type {string}
     * @memberof GitTreeResponse
     */
    'sha'?: string;
    /**
     * 
     * @type {number}
     * @memberof GitTreeResponse
     */
    'total_count'?: number;
    /**
     * 
     * @type {Array<GitEntry>}
     * @memberof GitTreeResponse
     */
    'tree'?: Array<GitEntry>;
    /**
     * 
     * @type {boolean}
     * @memberof GitTreeResponse
     */
    'truncated'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GitTreeResponse
     */
    'url'?: string;
}
/**
 * GitignoreTemplateInfo name and text of a gitignore template
 * @export
 * @interface GitignoreTemplateInfo
 */
export interface GitignoreTemplateInfo {
    /**
     * 
     * @type {string}
     * @memberof GitignoreTemplateInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GitignoreTemplateInfo
     */
    'source'?: string;
}
/**
 * Hook a hook is a web hook when one repository changed
 * @export
 * @interface Hook
 */
export interface Hook {
    /**
     * 
     * @type {boolean}
     * @memberof Hook
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Hook
     */
    'authorization_header'?: string;
    /**
     * 
     * @type {string}
     * @memberof Hook
     */
    'branch_filter'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Hook
     */
    'config'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Hook
     */
    'created_at'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Hook
     */
    'events'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Hook
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Hook
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Hook
     */
    'updated_at'?: string;
}
/**
 * Identity for a person\'s identity like an author or committer
 * @export
 * @interface Identity
 */
export interface Identity {
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    'name'?: string;
}
/**
 * InternalTracker represents settings for internal tracker
 * @export
 * @interface InternalTracker
 */
export interface InternalTracker {
    /**
     * Let only contributors track time (Built-in issue tracker)
     * @type {boolean}
     * @memberof InternalTracker
     */
    'allow_only_contributors_to_track_time'?: boolean;
    /**
     * Enable dependencies for issues and pull requests (Built-in issue tracker)
     * @type {boolean}
     * @memberof InternalTracker
     */
    'enable_issue_dependencies'?: boolean;
    /**
     * Enable time tracking (Built-in issue tracker)
     * @type {boolean}
     * @memberof InternalTracker
     */
    'enable_time_tracker'?: boolean;
}
/**
 * Issue represents an issue in a repository
 * @export
 * @interface Issue
 */
export interface Issue {
    /**
     * 
     * @type {Array<Attachment>}
     * @memberof Issue
     */
    'assets'?: Array<Attachment>;
    /**
     * 
     * @type {User}
     * @memberof Issue
     */
    'assignee'?: User;
    /**
     * 
     * @type {Array<User>}
     * @memberof Issue
     */
    'assignees'?: Array<User>;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    'body'?: string;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    'closed_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof Issue
     */
    'comments'?: number;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    'due_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    'html_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof Issue
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Issue
     */
    'is_locked'?: boolean;
    /**
     * 
     * @type {Array<Label>}
     * @memberof Issue
     */
    'labels'?: Array<Label>;
    /**
     * 
     * @type {Milestone}
     * @memberof Issue
     */
    'milestone'?: Milestone;
    /**
     * 
     * @type {number}
     * @memberof Issue
     */
    'number'?: number;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    'original_author'?: string;
    /**
     * 
     * @type {number}
     * @memberof Issue
     */
    'original_author_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Issue
     */
    'pin_order'?: number;
    /**
     * 
     * @type {PullRequestMeta}
     * @memberof Issue
     */
    'pull_request'?: PullRequestMeta;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    'ref'?: string;
    /**
     * 
     * @type {RepositoryMeta}
     * @memberof Issue
     */
    'repository'?: RepositoryMeta;
    /**
     * StateType issue state type
     * @type {string}
     * @memberof Issue
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    'url'?: string;
    /**
     * 
     * @type {User}
     * @memberof Issue
     */
    'user'?: User;
}
/**
 * 
 * @export
 * @interface IssueConfig
 */
export interface IssueConfig {
    /**
     * 
     * @type {boolean}
     * @memberof IssueConfig
     */
    'blank_issues_enabled'?: boolean;
    /**
     * 
     * @type {Array<IssueConfigContactLink>}
     * @memberof IssueConfig
     */
    'contact_links'?: Array<IssueConfigContactLink>;
}
/**
 * 
 * @export
 * @interface IssueConfigContactLink
 */
export interface IssueConfigContactLink {
    /**
     * 
     * @type {string}
     * @memberof IssueConfigContactLink
     */
    'about'?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueConfigContactLink
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueConfigContactLink
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface IssueConfigValidation
 */
export interface IssueConfigValidation {
    /**
     * 
     * @type {string}
     * @memberof IssueConfigValidation
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IssueConfigValidation
     */
    'valid'?: boolean;
}
/**
 * IssueDeadline represents an issue deadline
 * @export
 * @interface IssueDeadline
 */
export interface IssueDeadline {
    /**
     * 
     * @type {string}
     * @memberof IssueDeadline
     */
    'due_date'?: string;
}
/**
 * IssueFormField represents a form field
 * @export
 * @interface IssueFormField
 */
export interface IssueFormField {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof IssueFormField
     */
    'attributes'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof IssueFormField
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueFormField
     */
    'type'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof IssueFormField
     */
    'validations'?: { [key: string]: object; };
}
/**
 * IssueLabelsOption a collection of labels
 * @export
 * @interface IssueLabelsOption
 */
export interface IssueLabelsOption {
    /**
     * list of label IDs
     * @type {Array<number>}
     * @memberof IssueLabelsOption
     */
    'labels'?: Array<number>;
}
/**
 * IssueMeta basic issue information
 * @export
 * @interface IssueMeta
 */
export interface IssueMeta {
    /**
     * 
     * @type {number}
     * @memberof IssueMeta
     */
    'index'?: number;
    /**
     * 
     * @type {string}
     * @memberof IssueMeta
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueMeta
     */
    'repo'?: string;
}
/**
 * IssueTemplate represents an issue template for a repository
 * @export
 * @interface IssueTemplate
 */
export interface IssueTemplate {
    /**
     * 
     * @type {string}
     * @memberof IssueTemplate
     */
    'about'?: string;
    /**
     * 
     * @type {Array<IssueFormField>}
     * @memberof IssueTemplate
     */
    'body'?: Array<IssueFormField>;
    /**
     * 
     * @type {string}
     * @memberof IssueTemplate
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueTemplate
     */
    'file_name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IssueTemplate
     */
    'labels'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IssueTemplate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueTemplate
     */
    'ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueTemplate
     */
    'title'?: string;
}
/**
 * Label a label to an issue or a pr
 * @export
 * @interface Label
 */
export interface Label {
    /**
     * 
     * @type {string}
     * @memberof Label
     */
    'color'?: string;
    /**
     * 
     * @type {string}
     * @memberof Label
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Label
     */
    'exclusive'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Label
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Label
     */
    'is_archived'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Label
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Label
     */
    'url'?: string;
}
/**
 * LabelTemplate info of a Label template
 * @export
 * @interface LabelTemplate
 */
export interface LabelTemplate {
    /**
     * 
     * @type {string}
     * @memberof LabelTemplate
     */
    'color'?: string;
    /**
     * 
     * @type {string}
     * @memberof LabelTemplate
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LabelTemplate
     */
    'exclusive'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LabelTemplate
     */
    'name'?: string;
}
/**
 * LicensesInfo contains information about a License
 * @export
 * @interface LicenseTemplateInfo
 */
export interface LicenseTemplateInfo {
    /**
     * 
     * @type {string}
     * @memberof LicenseTemplateInfo
     */
    'body'?: string;
    /**
     * 
     * @type {string}
     * @memberof LicenseTemplateInfo
     */
    'implementation'?: string;
    /**
     * 
     * @type {string}
     * @memberof LicenseTemplateInfo
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof LicenseTemplateInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof LicenseTemplateInfo
     */
    'url'?: string;
}
/**
 * LicensesListEntry is used for the API
 * @export
 * @interface LicensesTemplateListEntry
 */
export interface LicensesTemplateListEntry {
    /**
     * 
     * @type {string}
     * @memberof LicensesTemplateListEntry
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof LicensesTemplateListEntry
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof LicensesTemplateListEntry
     */
    'url'?: string;
}
/**
 * MarkdownOption markdown options
 * @export
 * @interface MarkdownOption
 */
export interface MarkdownOption {
    /**
     * Context to render  in: body
     * @type {string}
     * @memberof MarkdownOption
     */
    'Context'?: string;
    /**
     * Mode to render (comment, gfm, markdown)  in: body
     * @type {string}
     * @memberof MarkdownOption
     */
    'Mode'?: string;
    /**
     * Text markdown to render  in: body
     * @type {string}
     * @memberof MarkdownOption
     */
    'Text'?: string;
    /**
     * Is it a wiki page ?  in: body
     * @type {boolean}
     * @memberof MarkdownOption
     */
    'Wiki'?: boolean;
}
/**
 * MarkupOption markup options
 * @export
 * @interface MarkupOption
 */
export interface MarkupOption {
    /**
     * Context to render  in: body
     * @type {string}
     * @memberof MarkupOption
     */
    'Context'?: string;
    /**
     * File path for detecting extension in file mode  in: body
     * @type {string}
     * @memberof MarkupOption
     */
    'FilePath'?: string;
    /**
     * Mode to render (comment, gfm, markdown, file)  in: body
     * @type {string}
     * @memberof MarkupOption
     */
    'Mode'?: string;
    /**
     * Text markup to render  in: body
     * @type {string}
     * @memberof MarkupOption
     */
    'Text'?: string;
    /**
     * Is it a wiki page ?  in: body
     * @type {boolean}
     * @memberof MarkupOption
     */
    'Wiki'?: boolean;
}
/**
 * MergePullRequestForm form for merging Pull Request
 * @export
 * @interface MergePullRequestOption
 */
export interface MergePullRequestOption {
    /**
     * 
     * @type {string}
     * @memberof MergePullRequestOption
     */
    'Do': MergePullRequestOptionDoEnum;
    /**
     * 
     * @type {string}
     * @memberof MergePullRequestOption
     */
    'MergeCommitID'?: string;
    /**
     * 
     * @type {string}
     * @memberof MergePullRequestOption
     */
    'MergeMessageField'?: string;
    /**
     * 
     * @type {string}
     * @memberof MergePullRequestOption
     */
    'MergeTitleField'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MergePullRequestOption
     */
    'delete_branch_after_merge'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MergePullRequestOption
     */
    'force_merge'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MergePullRequestOption
     */
    'head_commit_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MergePullRequestOption
     */
    'merge_when_checks_succeed'?: boolean;
}

export const MergePullRequestOptionDoEnum = {
    merge: 'merge',
    rebase: 'rebase',
    rebase_merge: 'rebase-merge',
    squash: 'squash',
    manually_merged: 'manually-merged'
} as const;

export type MergePullRequestOptionDoEnum = typeof MergePullRequestOptionDoEnum[keyof typeof MergePullRequestOptionDoEnum];

/**
 * MigrateRepoOptions options for migrating repository\'s this is used to interact with api v1
 * @export
 * @interface MigrateRepoOptions
 */
export interface MigrateRepoOptions {
    /**
     * 
     * @type {string}
     * @memberof MigrateRepoOptions
     */
    'auth_password'?: string;
    /**
     * 
     * @type {string}
     * @memberof MigrateRepoOptions
     */
    'auth_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof MigrateRepoOptions
     */
    'auth_username'?: string;
    /**
     * 
     * @type {string}
     * @memberof MigrateRepoOptions
     */
    'clone_addr': string;
    /**
     * 
     * @type {string}
     * @memberof MigrateRepoOptions
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MigrateRepoOptions
     */
    'issues'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MigrateRepoOptions
     */
    'labels'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MigrateRepoOptions
     */
    'lfs'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MigrateRepoOptions
     */
    'lfs_endpoint'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MigrateRepoOptions
     */
    'milestones'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MigrateRepoOptions
     */
    'mirror'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MigrateRepoOptions
     */
    'mirror_interval'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MigrateRepoOptions
     */
    'private'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MigrateRepoOptions
     */
    'pull_requests'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MigrateRepoOptions
     */
    'releases'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MigrateRepoOptions
     */
    'repo_name': string;
    /**
     * Name of User or Organisation who will own Repo after migration
     * @type {string}
     * @memberof MigrateRepoOptions
     */
    'repo_owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof MigrateRepoOptions
     */
    'service'?: MigrateRepoOptionsServiceEnum;
    /**
     * deprecated (only for backwards compatibility)
     * @type {number}
     * @memberof MigrateRepoOptions
     */
    'uid'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MigrateRepoOptions
     */
    'wiki'?: boolean;
}

export const MigrateRepoOptionsServiceEnum = {
    git: 'git',
    github: 'github',
    gitea: 'gitea',
    gitlab: 'gitlab',
    gogs: 'gogs',
    onedev: 'onedev',
    gitbucket: 'gitbucket',
    codebase: 'codebase'
} as const;

export type MigrateRepoOptionsServiceEnum = typeof MigrateRepoOptionsServiceEnum[keyof typeof MigrateRepoOptionsServiceEnum];

/**
 * Milestone milestone is a collection of issues on one repository
 * @export
 * @interface Milestone
 */
export interface Milestone {
    /**
     * 
     * @type {string}
     * @memberof Milestone
     */
    'closed_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof Milestone
     */
    'closed_issues'?: number;
    /**
     * 
     * @type {string}
     * @memberof Milestone
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Milestone
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Milestone
     */
    'due_on'?: string;
    /**
     * 
     * @type {number}
     * @memberof Milestone
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Milestone
     */
    'open_issues'?: number;
    /**
     * StateType issue state type
     * @type {string}
     * @memberof Milestone
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof Milestone
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Milestone
     */
    'updated_at'?: string;
}
/**
 * NewIssuePinsAllowed represents an API response that says if new Issue Pins are allowed
 * @export
 * @interface NewIssuePinsAllowed
 */
export interface NewIssuePinsAllowed {
    /**
     * 
     * @type {boolean}
     * @memberof NewIssuePinsAllowed
     */
    'issues'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NewIssuePinsAllowed
     */
    'pull_requests'?: boolean;
}
/**
 * NodeInfo contains standardized way of exposing metadata about a server running one of the distributed social networks
 * @export
 * @interface NodeInfo
 */
export interface NodeInfo {
    /**
     * 
     * @type {object}
     * @memberof NodeInfo
     */
    'metadata'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof NodeInfo
     */
    'openRegistrations'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof NodeInfo
     */
    'protocols'?: Array<string>;
    /**
     * 
     * @type {NodeInfoServices}
     * @memberof NodeInfo
     */
    'services'?: NodeInfoServices;
    /**
     * 
     * @type {NodeInfoSoftware}
     * @memberof NodeInfo
     */
    'software'?: NodeInfoSoftware;
    /**
     * 
     * @type {NodeInfoUsage}
     * @memberof NodeInfo
     */
    'usage'?: NodeInfoUsage;
    /**
     * 
     * @type {string}
     * @memberof NodeInfo
     */
    'version'?: string;
}
/**
 * NodeInfoServices contains the third party sites this server can connect to via their application API
 * @export
 * @interface NodeInfoServices
 */
export interface NodeInfoServices {
    /**
     * 
     * @type {Array<string>}
     * @memberof NodeInfoServices
     */
    'inbound'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof NodeInfoServices
     */
    'outbound'?: Array<string>;
}
/**
 * NodeInfoSoftware contains Metadata about server software in use
 * @export
 * @interface NodeInfoSoftware
 */
export interface NodeInfoSoftware {
    /**
     * 
     * @type {string}
     * @memberof NodeInfoSoftware
     */
    'homepage'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeInfoSoftware
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeInfoSoftware
     */
    'repository'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeInfoSoftware
     */
    'version'?: string;
}
/**
 * NodeInfoUsage contains usage statistics for this server
 * @export
 * @interface NodeInfoUsage
 */
export interface NodeInfoUsage {
    /**
     * 
     * @type {number}
     * @memberof NodeInfoUsage
     */
    'localComments'?: number;
    /**
     * 
     * @type {number}
     * @memberof NodeInfoUsage
     */
    'localPosts'?: number;
    /**
     * 
     * @type {NodeInfoUsageUsers}
     * @memberof NodeInfoUsage
     */
    'users'?: NodeInfoUsageUsers;
}
/**
 * NodeInfoUsageUsers contains statistics about the users of this server
 * @export
 * @interface NodeInfoUsageUsers
 */
export interface NodeInfoUsageUsers {
    /**
     * 
     * @type {number}
     * @memberof NodeInfoUsageUsers
     */
    'activeHalfyear'?: number;
    /**
     * 
     * @type {number}
     * @memberof NodeInfoUsageUsers
     */
    'activeMonth'?: number;
    /**
     * 
     * @type {number}
     * @memberof NodeInfoUsageUsers
     */
    'total'?: number;
}
/**
 * Note contains information related to a git note
 * @export
 * @interface Note
 */
export interface Note {
    /**
     * 
     * @type {Commit}
     * @memberof Note
     */
    'commit'?: Commit;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'message'?: string;
}
/**
 * NotificationCount number of unread notifications
 * @export
 * @interface NotificationCount
 */
export interface NotificationCount {
    /**
     * 
     * @type {number}
     * @memberof NotificationCount
     */
    'new'?: number;
}
/**
 * NotificationSubject contains the notification subject (Issue/Pull/Commit)
 * @export
 * @interface NotificationSubject
 */
export interface NotificationSubject {
    /**
     * 
     * @type {string}
     * @memberof NotificationSubject
     */
    'html_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationSubject
     */
    'latest_comment_html_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationSubject
     */
    'latest_comment_url'?: string;
    /**
     * StateType issue state type
     * @type {string}
     * @memberof NotificationSubject
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationSubject
     */
    'title'?: string;
    /**
     * NotifySubjectType represent type of notification subject
     * @type {string}
     * @memberof NotificationSubject
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationSubject
     */
    'url'?: string;
}
/**
 * NotificationThread expose Notification on API
 * @export
 * @interface NotificationThread
 */
export interface NotificationThread {
    /**
     * 
     * @type {number}
     * @memberof NotificationThread
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationThread
     */
    'pinned'?: boolean;
    /**
     * 
     * @type {Repository}
     * @memberof NotificationThread
     */
    'repository'?: Repository;
    /**
     * 
     * @type {NotificationSubject}
     * @memberof NotificationThread
     */
    'subject'?: NotificationSubject;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationThread
     */
    'unread'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NotificationThread
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationThread
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface OAuth2Application
 */
export interface OAuth2Application {
    /**
     * 
     * @type {string}
     * @memberof OAuth2Application
     */
    'client_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2Application
     */
    'client_secret'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OAuth2Application
     */
    'confidential_client'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OAuth2Application
     */
    'created'?: string;
    /**
     * 
     * @type {number}
     * @memberof OAuth2Application
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OAuth2Application
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OAuth2Application
     */
    'redirect_uris'?: Array<string>;
}
/**
 * Organization represents an organization
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'avatar_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'full_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Organization
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Organization
     */
    'repo_admin_change_team_access'?: boolean;
    /**
     * deprecated
     * @type {string}
     * @memberof Organization
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'visibility'?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'website'?: string;
}
/**
 * OrganizationPermissions list different users permissions on an organization
 * @export
 * @interface OrganizationPermissions
 */
export interface OrganizationPermissions {
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationPermissions
     */
    'can_create_repository'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationPermissions
     */
    'can_read'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationPermissions
     */
    'can_write'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationPermissions
     */
    'is_admin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationPermissions
     */
    'is_owner'?: boolean;
}
/**
 * PRBranchInfo information about a branch
 * @export
 * @interface PRBranchInfo
 */
export interface PRBranchInfo {
    /**
     * 
     * @type {string}
     * @memberof PRBranchInfo
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof PRBranchInfo
     */
    'ref'?: string;
    /**
     * 
     * @type {Repository}
     * @memberof PRBranchInfo
     */
    'repo'?: Repository;
    /**
     * 
     * @type {number}
     * @memberof PRBranchInfo
     */
    'repo_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PRBranchInfo
     */
    'sha'?: string;
}
/**
 * Package represents a package
 * @export
 * @interface Package
 */
export interface Package {
    /**
     * 
     * @type {string}
     * @memberof Package
     */
    'created_at'?: string;
    /**
     * 
     * @type {User}
     * @memberof Package
     */
    'creator'?: User;
    /**
     * 
     * @type {number}
     * @memberof Package
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Package
     */
    'name'?: string;
    /**
     * 
     * @type {User}
     * @memberof Package
     */
    'owner'?: User;
    /**
     * 
     * @type {Repository}
     * @memberof Package
     */
    'repository'?: Repository;
    /**
     * 
     * @type {string}
     * @memberof Package
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Package
     */
    'version'?: string;
}
/**
 * PackageFile represents a package file
 * @export
 * @interface PackageFile
 */
export interface PackageFile {
    /**
     * 
     * @type {number}
     * @memberof PackageFile
     */
    'Size'?: number;
    /**
     * 
     * @type {number}
     * @memberof PackageFile
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PackageFile
     */
    'md5'?: string;
    /**
     * 
     * @type {string}
     * @memberof PackageFile
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PackageFile
     */
    'sha1'?: string;
    /**
     * 
     * @type {string}
     * @memberof PackageFile
     */
    'sha256'?: string;
    /**
     * 
     * @type {string}
     * @memberof PackageFile
     */
    'sha512'?: string;
}
/**
 * PayloadCommit represents a commit
 * @export
 * @interface PayloadCommit
 */
export interface PayloadCommit {
    /**
     * 
     * @type {Array<string>}
     * @memberof PayloadCommit
     */
    'added'?: Array<string>;
    /**
     * 
     * @type {PayloadUser}
     * @memberof PayloadCommit
     */
    'author'?: PayloadUser;
    /**
     * 
     * @type {PayloadUser}
     * @memberof PayloadCommit
     */
    'committer'?: PayloadUser;
    /**
     * sha1 hash of the commit
     * @type {string}
     * @memberof PayloadCommit
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayloadCommit
     */
    'message'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PayloadCommit
     */
    'modified'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PayloadCommit
     */
    'removed'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PayloadCommit
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayloadCommit
     */
    'url'?: string;
    /**
     * 
     * @type {PayloadCommitVerification}
     * @memberof PayloadCommit
     */
    'verification'?: PayloadCommitVerification;
}
/**
 * PayloadCommitVerification represents the GPG verification of a commit
 * @export
 * @interface PayloadCommitVerification
 */
export interface PayloadCommitVerification {
    /**
     * 
     * @type {string}
     * @memberof PayloadCommitVerification
     */
    'payload'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayloadCommitVerification
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayloadCommitVerification
     */
    'signature'?: string;
    /**
     * 
     * @type {PayloadUser}
     * @memberof PayloadCommitVerification
     */
    'signer'?: PayloadUser;
    /**
     * 
     * @type {boolean}
     * @memberof PayloadCommitVerification
     */
    'verified'?: boolean;
}
/**
 * PayloadUser represents the author or committer of a commit
 * @export
 * @interface PayloadUser
 */
export interface PayloadUser {
    /**
     * 
     * @type {string}
     * @memberof PayloadUser
     */
    'email'?: string;
    /**
     * Full name of the commit author
     * @type {string}
     * @memberof PayloadUser
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayloadUser
     */
    'username'?: string;
}
/**
 * Permission represents a set of permissions
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     * 
     * @type {boolean}
     * @memberof Permission
     */
    'admin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Permission
     */
    'pull'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Permission
     */
    'push'?: boolean;
}
/**
 * PublicKey publickey is a user key to push code to repository
 * @export
 * @interface PublicKey
 */
export interface PublicKey {
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    'fingerprint'?: string;
    /**
     * 
     * @type {number}
     * @memberof PublicKey
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    'key_type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PublicKey
     */
    'read_only'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    'url'?: string;
    /**
     * 
     * @type {User}
     * @memberof PublicKey
     */
    'user'?: User;
}
/**
 * PullRequest represents a pull request
 * @export
 * @interface PullRequest
 */
export interface PullRequest {
    /**
     * 
     * @type {boolean}
     * @memberof PullRequest
     */
    'allow_maintainer_edit'?: boolean;
    /**
     * 
     * @type {User}
     * @memberof PullRequest
     */
    'assignee'?: User;
    /**
     * 
     * @type {Array<User>}
     * @memberof PullRequest
     */
    'assignees'?: Array<User>;
    /**
     * 
     * @type {PRBranchInfo}
     * @memberof PullRequest
     */
    'base'?: PRBranchInfo;
    /**
     * 
     * @type {string}
     * @memberof PullRequest
     */
    'body'?: string;
    /**
     * 
     * @type {string}
     * @memberof PullRequest
     */
    'closed_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof PullRequest
     */
    'comments'?: number;
    /**
     * 
     * @type {string}
     * @memberof PullRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PullRequest
     */
    'diff_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PullRequest
     */
    'due_date'?: string;
    /**
     * 
     * @type {PRBranchInfo}
     * @memberof PullRequest
     */
    'head'?: PRBranchInfo;
    /**
     * 
     * @type {string}
     * @memberof PullRequest
     */
    'html_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof PullRequest
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PullRequest
     */
    'is_locked'?: boolean;
    /**
     * 
     * @type {Array<Label>}
     * @memberof PullRequest
     */
    'labels'?: Array<Label>;
    /**
     * 
     * @type {string}
     * @memberof PullRequest
     */
    'merge_base'?: string;
    /**
     * 
     * @type {string}
     * @memberof PullRequest
     */
    'merge_commit_sha'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PullRequest
     */
    'mergeable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PullRequest
     */
    'merged'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PullRequest
     */
    'merged_at'?: string;
    /**
     * 
     * @type {User}
     * @memberof PullRequest
     */
    'merged_by'?: User;
    /**
     * 
     * @type {Milestone}
     * @memberof PullRequest
     */
    'milestone'?: Milestone;
    /**
     * 
     * @type {number}
     * @memberof PullRequest
     */
    'number'?: number;
    /**
     * 
     * @type {string}
     * @memberof PullRequest
     */
    'patch_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof PullRequest
     */
    'pin_order'?: number;
    /**
     * 
     * @type {Array<User>}
     * @memberof PullRequest
     */
    'requested_reviewers'?: Array<User>;
    /**
     * StateType issue state type
     * @type {string}
     * @memberof PullRequest
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof PullRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PullRequest
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PullRequest
     */
    'url'?: string;
    /**
     * 
     * @type {User}
     * @memberof PullRequest
     */
    'user'?: User;
}
/**
 * PullRequestMeta PR info if an issue is a PR
 * @export
 * @interface PullRequestMeta
 */
export interface PullRequestMeta {
    /**
     * 
     * @type {boolean}
     * @memberof PullRequestMeta
     */
    'merged'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PullRequestMeta
     */
    'merged_at'?: string;
}
/**
 * PullReview represents a pull request review
 * @export
 * @interface PullReview
 */
export interface PullReview {
    /**
     * 
     * @type {string}
     * @memberof PullReview
     */
    'body'?: string;
    /**
     * 
     * @type {number}
     * @memberof PullReview
     */
    'comments_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PullReview
     */
    'commit_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PullReview
     */
    'dismissed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PullReview
     */
    'html_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof PullReview
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PullReview
     */
    'official'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PullReview
     */
    'pull_request_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PullReview
     */
    'stale'?: boolean;
    /**
     * ReviewStateType review state type
     * @type {string}
     * @memberof PullReview
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof PullReview
     */
    'submitted_at'?: string;
    /**
     * 
     * @type {Team}
     * @memberof PullReview
     */
    'team'?: Team;
    /**
     * 
     * @type {string}
     * @memberof PullReview
     */
    'updated_at'?: string;
    /**
     * 
     * @type {User}
     * @memberof PullReview
     */
    'user'?: User;
}
/**
 * PullReviewComment represents a comment on a pull request review
 * @export
 * @interface PullReviewComment
 */
export interface PullReviewComment {
    /**
     * 
     * @type {string}
     * @memberof PullReviewComment
     */
    'body'?: string;
    /**
     * 
     * @type {string}
     * @memberof PullReviewComment
     */
    'commit_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PullReviewComment
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PullReviewComment
     */
    'diff_hunk'?: string;
    /**
     * 
     * @type {string}
     * @memberof PullReviewComment
     */
    'html_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof PullReviewComment
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PullReviewComment
     */
    'original_commit_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof PullReviewComment
     */
    'original_position'?: number;
    /**
     * 
     * @type {string}
     * @memberof PullReviewComment
     */
    'path'?: string;
    /**
     * 
     * @type {number}
     * @memberof PullReviewComment
     */
    'position'?: number;
    /**
     * 
     * @type {number}
     * @memberof PullReviewComment
     */
    'pull_request_review_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PullReviewComment
     */
    'pull_request_url'?: string;
    /**
     * 
     * @type {User}
     * @memberof PullReviewComment
     */
    'resolver'?: User;
    /**
     * 
     * @type {string}
     * @memberof PullReviewComment
     */
    'updated_at'?: string;
    /**
     * 
     * @type {User}
     * @memberof PullReviewComment
     */
    'user'?: User;
}
/**
 * PullReviewRequestOptions are options to add or remove pull review requests
 * @export
 * @interface PullReviewRequestOptions
 */
export interface PullReviewRequestOptions {
    /**
     * 
     * @type {Array<string>}
     * @memberof PullReviewRequestOptions
     */
    'reviewers'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PullReviewRequestOptions
     */
    'team_reviewers'?: Array<string>;
}
/**
 * PushMirror represents information of a push mirror
 * @export
 * @interface PushMirror
 */
export interface PushMirror {
    /**
     * 
     * @type {string}
     * @memberof PushMirror
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof PushMirror
     */
    'interval'?: string;
    /**
     * 
     * @type {string}
     * @memberof PushMirror
     */
    'last_error'?: string;
    /**
     * 
     * @type {string}
     * @memberof PushMirror
     */
    'last_update'?: string;
    /**
     * 
     * @type {string}
     * @memberof PushMirror
     */
    'remote_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof PushMirror
     */
    'remote_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PushMirror
     */
    'repo_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PushMirror
     */
    'sync_on_commit'?: boolean;
}
/**
 * Reaction contain one reaction
 * @export
 * @interface Reaction
 */
export interface Reaction {
    /**
     * 
     * @type {string}
     * @memberof Reaction
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof Reaction
     */
    'created_at'?: string;
    /**
     * 
     * @type {User}
     * @memberof Reaction
     */
    'user'?: User;
}
/**
 * 
 * @export
 * @interface Reference
 */
export interface Reference {
    /**
     * 
     * @type {GitObject}
     * @memberof Reference
     */
    'object'?: GitObject;
    /**
     * 
     * @type {string}
     * @memberof Reference
     */
    'ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof Reference
     */
    'url'?: string;
}
/**
 * Release represents a repository release
 * @export
 * @interface Release
 */
export interface Release {
    /**
     * 
     * @type {Array<Attachment>}
     * @memberof Release
     */
    'assets'?: Array<Attachment>;
    /**
     * 
     * @type {User}
     * @memberof Release
     */
    'author'?: User;
    /**
     * 
     * @type {string}
     * @memberof Release
     */
    'body'?: string;
    /**
     * 
     * @type {string}
     * @memberof Release
     */
    'created_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Release
     */
    'draft'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Release
     */
    'html_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof Release
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Release
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Release
     */
    'prerelease'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Release
     */
    'published_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Release
     */
    'tag_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Release
     */
    'tarball_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Release
     */
    'target_commitish'?: string;
    /**
     * 
     * @type {string}
     * @memberof Release
     */
    'upload_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Release
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Release
     */
    'zipball_url'?: string;
}
/**
 * RenameUserOption options when renaming a user
 * @export
 * @interface RenameUserOption
 */
export interface RenameUserOption {
    /**
     * New username for this user. This name cannot be in use yet by any other user.
     * @type {string}
     * @memberof RenameUserOption
     */
    'new_username': string;
}
/**
 * RepoCollaboratorPermission to get repository permission for a collaborator
 * @export
 * @interface RepoCollaboratorPermission
 */
export interface RepoCollaboratorPermission {
    /**
     * 
     * @type {string}
     * @memberof RepoCollaboratorPermission
     */
    'permission'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepoCollaboratorPermission
     */
    'role_name'?: string;
    /**
     * 
     * @type {User}
     * @memberof RepoCollaboratorPermission
     */
    'user'?: User;
}
/**
 * 
 * @export
 * @interface RepoCommit
 */
export interface RepoCommit {
    /**
     * 
     * @type {CommitUser}
     * @memberof RepoCommit
     */
    'author'?: CommitUser;
    /**
     * 
     * @type {CommitUser}
     * @memberof RepoCommit
     */
    'committer'?: CommitUser;
    /**
     * 
     * @type {string}
     * @memberof RepoCommit
     */
    'message'?: string;
    /**
     * 
     * @type {CommitMeta}
     * @memberof RepoCommit
     */
    'tree'?: CommitMeta;
    /**
     * 
     * @type {string}
     * @memberof RepoCommit
     */
    'url'?: string;
    /**
     * 
     * @type {PayloadCommitVerification}
     * @memberof RepoCommit
     */
    'verification'?: PayloadCommitVerification;
}
/**
 * RepoTopicOptions a collection of repo topic names
 * @export
 * @interface RepoTopicOptions
 */
export interface RepoTopicOptions {
    /**
     * list of topic names
     * @type {Array<string>}
     * @memberof RepoTopicOptions
     */
    'topics'?: Array<string>;
}
/**
 * RepoTransfer represents a pending repo transfer
 * @export
 * @interface RepoTransfer
 */
export interface RepoTransfer {
    /**
     * 
     * @type {User}
     * @memberof RepoTransfer
     */
    'doer'?: User;
    /**
     * 
     * @type {User}
     * @memberof RepoTransfer
     */
    'recipient'?: User;
    /**
     * 
     * @type {Array<Team>}
     * @memberof RepoTransfer
     */
    'teams'?: Array<Team>;
}
/**
 * Repository represents a repository
 * @export
 * @interface Repository
 */
export interface Repository {
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'allow_merge_commits'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'allow_rebase'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'allow_rebase_explicit'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'allow_rebase_update'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'allow_squash_merge'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'archived'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'archived_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'avatar_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'clone_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'created_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'default_allow_maintainer_edit'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'default_branch'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'default_delete_branch_after_merge'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'default_merge_style'?: string;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'empty'?: boolean;
    /**
     * 
     * @type {ExternalTracker}
     * @memberof Repository
     */
    'external_tracker'?: ExternalTracker;
    /**
     * 
     * @type {ExternalWiki}
     * @memberof Repository
     */
    'external_wiki'?: ExternalWiki;
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'fork'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Repository
     */
    'forks_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'full_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'has_actions'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'has_issues'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'has_packages'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'has_projects'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'has_pull_requests'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'has_releases'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'has_wiki'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'html_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof Repository
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'ignore_whitespace_conflicts'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'internal'?: boolean;
    /**
     * 
     * @type {InternalTracker}
     * @memberof Repository
     */
    'internal_tracker'?: InternalTracker;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'languages_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'link'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'mirror'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'mirror_interval'?: string;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'mirror_updated'?: string;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Repository
     */
    'open_issues_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof Repository
     */
    'open_pr_counter'?: number;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'original_url'?: string;
    /**
     * 
     * @type {User}
     * @memberof Repository
     */
    'owner'?: User;
    /**
     * 
     * @type {Repository}
     * @memberof Repository
     */
    'parent'?: Repository;
    /**
     * 
     * @type {Permission}
     * @memberof Repository
     */
    'permissions'?: Permission;
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'private'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Repository
     */
    'release_counter'?: number;
    /**
     * 
     * @type {RepoTransfer}
     * @memberof Repository
     */
    'repo_transfer'?: RepoTransfer;
    /**
     * 
     * @type {number}
     * @memberof Repository
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'ssh_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof Repository
     */
    'stars_count'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'template'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof Repository
     */
    'watchers_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'website'?: string;
}
/**
 * RepositoryMeta basic repository information
 * @export
 * @interface RepositoryMeta
 */
export interface RepositoryMeta {
    /**
     * 
     * @type {string}
     * @memberof RepositoryMeta
     */
    'full_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof RepositoryMeta
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RepositoryMeta
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepositoryMeta
     */
    'owner'?: string;
}
/**
 * SearchResults results of a successful search
 * @export
 * @interface SearchResults
 */
export interface SearchResults {
    /**
     * 
     * @type {Array<Repository>}
     * @memberof SearchResults
     */
    'data'?: Array<Repository>;
    /**
     * 
     * @type {boolean}
     * @memberof SearchResults
     */
    'ok'?: boolean;
}
/**
 * Secret represents a secret
 * @export
 * @interface Secret
 */
export interface Secret {
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    'created_at'?: string;
    /**
     * the secret\'s name
     * @type {string}
     * @memberof Secret
     */
    'name'?: string;
}
/**
 * ServerVersion wraps the version of the server
 * @export
 * @interface ServerVersion
 */
export interface ServerVersion {
    /**
     * 
     * @type {string}
     * @memberof ServerVersion
     */
    'version'?: string;
}
/**
 * StopWatch represent a running stopwatch
 * @export
 * @interface StopWatch
 */
export interface StopWatch {
    /**
     * 
     * @type {string}
     * @memberof StopWatch
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof StopWatch
     */
    'duration'?: string;
    /**
     * 
     * @type {number}
     * @memberof StopWatch
     */
    'issue_index'?: number;
    /**
     * 
     * @type {string}
     * @memberof StopWatch
     */
    'issue_title'?: string;
    /**
     * 
     * @type {string}
     * @memberof StopWatch
     */
    'repo_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StopWatch
     */
    'repo_owner_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof StopWatch
     */
    'seconds'?: number;
}
/**
 * SubmitPullReviewOptions are options to submit a pending pull review
 * @export
 * @interface SubmitPullReviewOptions
 */
export interface SubmitPullReviewOptions {
    /**
     * 
     * @type {string}
     * @memberof SubmitPullReviewOptions
     */
    'body'?: string;
    /**
     * ReviewStateType review state type
     * @type {string}
     * @memberof SubmitPullReviewOptions
     */
    'event'?: string;
}
/**
 * Tag represents a repository tag
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {CommitMeta}
     * @memberof Tag
     */
    'commit'?: CommitMeta;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'tarball_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'zipball_url'?: string;
}
/**
 * Team represents a team in an organization
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * 
     * @type {boolean}
     * @memberof Team
     */
    'can_create_org_repo'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof Team
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Team
     */
    'includes_all_repositories'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'name'?: string;
    /**
     * 
     * @type {Organization}
     * @memberof Team
     */
    'organization'?: Organization;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'permission'?: TeamPermissionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof Team
     */
    'units'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Team
     */
    'units_map'?: { [key: string]: string; };
}

export const TeamPermissionEnum = {
    none: 'none',
    read: 'read',
    write: 'write',
    admin: 'admin',
    owner: 'owner'
} as const;

export type TeamPermissionEnum = typeof TeamPermissionEnum[keyof typeof TeamPermissionEnum];

/**
 * 
 * @export
 * @interface TeamSearch200Response
 */
export interface TeamSearch200Response {
    /**
     * 
     * @type {Array<Team>}
     * @memberof TeamSearch200Response
     */
    'data'?: Array<Team>;
    /**
     * 
     * @type {boolean}
     * @memberof TeamSearch200Response
     */
    'ok'?: boolean;
}
/**
 * TimelineComment represents a timeline comment (comment of any type) on a commit or issue
 * @export
 * @interface TimelineComment
 */
export interface TimelineComment {
    /**
     * 
     * @type {User}
     * @memberof TimelineComment
     */
    'assignee'?: User;
    /**
     * 
     * @type {Team}
     * @memberof TimelineComment
     */
    'assignee_team'?: Team;
    /**
     * 
     * @type {string}
     * @memberof TimelineComment
     */
    'body'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimelineComment
     */
    'created_at'?: string;
    /**
     * 
     * @type {Issue}
     * @memberof TimelineComment
     */
    'dependent_issue'?: Issue;
    /**
     * 
     * @type {string}
     * @memberof TimelineComment
     */
    'html_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof TimelineComment
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TimelineComment
     */
    'issue_url'?: string;
    /**
     * 
     * @type {Label}
     * @memberof TimelineComment
     */
    'label'?: Label;
    /**
     * 
     * @type {Milestone}
     * @memberof TimelineComment
     */
    'milestone'?: Milestone;
    /**
     * 
     * @type {string}
     * @memberof TimelineComment
     */
    'new_ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimelineComment
     */
    'new_title'?: string;
    /**
     * 
     * @type {Milestone}
     * @memberof TimelineComment
     */
    'old_milestone'?: Milestone;
    /**
     * 
     * @type {number}
     * @memberof TimelineComment
     */
    'old_project_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TimelineComment
     */
    'old_ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimelineComment
     */
    'old_title'?: string;
    /**
     * 
     * @type {number}
     * @memberof TimelineComment
     */
    'project_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TimelineComment
     */
    'pull_request_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimelineComment
     */
    'ref_action'?: string;
    /**
     * 
     * @type {Comment}
     * @memberof TimelineComment
     */
    'ref_comment'?: Comment;
    /**
     * commit SHA where issue/PR was referenced
     * @type {string}
     * @memberof TimelineComment
     */
    'ref_commit_sha'?: string;
    /**
     * 
     * @type {Issue}
     * @memberof TimelineComment
     */
    'ref_issue'?: Issue;
    /**
     * whether the assignees were removed or added
     * @type {boolean}
     * @memberof TimelineComment
     */
    'removed_assignee'?: boolean;
    /**
     * 
     * @type {User}
     * @memberof TimelineComment
     */
    'resolve_doer'?: User;
    /**
     * 
     * @type {number}
     * @memberof TimelineComment
     */
    'review_id'?: number;
    /**
     * 
     * @type {TrackedTime}
     * @memberof TimelineComment
     */
    'tracked_time'?: TrackedTime;
    /**
     * 
     * @type {string}
     * @memberof TimelineComment
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimelineComment
     */
    'updated_at'?: string;
    /**
     * 
     * @type {User}
     * @memberof TimelineComment
     */
    'user'?: User;
}
/**
 * TopicName a list of repo topic names
 * @export
 * @interface TopicName
 */
export interface TopicName {
    /**
     * 
     * @type {Array<string>}
     * @memberof TopicName
     */
    'topics'?: Array<string>;
}
/**
 * TopicResponse for returning topics
 * @export
 * @interface TopicResponse
 */
export interface TopicResponse {
    /**
     * 
     * @type {string}
     * @memberof TopicResponse
     */
    'created'?: string;
    /**
     * 
     * @type {number}
     * @memberof TopicResponse
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof TopicResponse
     */
    'repo_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof TopicResponse
     */
    'topic_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof TopicResponse
     */
    'updated'?: string;
}
/**
 * TrackedTime worked time for an issue / pr
 * @export
 * @interface TrackedTime
 */
export interface TrackedTime {
    /**
     * 
     * @type {string}
     * @memberof TrackedTime
     */
    'created'?: string;
    /**
     * 
     * @type {number}
     * @memberof TrackedTime
     */
    'id'?: number;
    /**
     * 
     * @type {Issue}
     * @memberof TrackedTime
     */
    'issue'?: Issue;
    /**
     * deprecated (only for backwards compatibility)
     * @type {number}
     * @memberof TrackedTime
     */
    'issue_id'?: number;
    /**
     * Time in seconds
     * @type {number}
     * @memberof TrackedTime
     */
    'time'?: number;
    /**
     * deprecated (only for backwards compatibility)
     * @type {number}
     * @memberof TrackedTime
     */
    'user_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TrackedTime
     */
    'user_name'?: string;
}
/**
 * TransferRepoOption options when transfer a repository\'s ownership
 * @export
 * @interface TransferRepoOption
 */
export interface TransferRepoOption {
    /**
     * 
     * @type {string}
     * @memberof TransferRepoOption
     */
    'new_owner': string;
    /**
     * ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.
     * @type {Array<number>}
     * @memberof TransferRepoOption
     */
    'team_ids'?: Array<number>;
}
/**
 * UpdateFileOptions options for updating files Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
 * @export
 * @interface UpdateFileOptions
 */
export interface UpdateFileOptions {
    /**
     * 
     * @type {Identity}
     * @memberof UpdateFileOptions
     */
    'author'?: Identity;
    /**
     * branch (optional) to base this file from. if not given, the default branch is used
     * @type {string}
     * @memberof UpdateFileOptions
     */
    'branch'?: string;
    /**
     * 
     * @type {Identity}
     * @memberof UpdateFileOptions
     */
    'committer'?: Identity;
    /**
     * content must be base64 encoded
     * @type {string}
     * @memberof UpdateFileOptions
     */
    'content': string;
    /**
     * 
     * @type {CommitDateOptions}
     * @memberof UpdateFileOptions
     */
    'dates'?: CommitDateOptions;
    /**
     * from_path (optional) is the path of the original file which will be moved/renamed to the path in the URL
     * @type {string}
     * @memberof UpdateFileOptions
     */
    'from_path'?: string;
    /**
     * message (optional) for the commit of this file. if not supplied, a default message will be used
     * @type {string}
     * @memberof UpdateFileOptions
     */
    'message'?: string;
    /**
     * new_branch (optional) will make a new branch from `branch` before creating the file
     * @type {string}
     * @memberof UpdateFileOptions
     */
    'new_branch'?: string;
    /**
     * sha is the SHA for the file that already exists
     * @type {string}
     * @memberof UpdateFileOptions
     */
    'sha': string;
    /**
     * Add a Signed-off-by trailer by the committer at the end of the commit log message.
     * @type {boolean}
     * @memberof UpdateFileOptions
     */
    'signoff'?: boolean;
}
/**
 * UpdateRepoAvatarUserOption options when updating the repo avatar
 * @export
 * @interface UpdateRepoAvatarOption
 */
export interface UpdateRepoAvatarOption {
    /**
     * image must be base64 encoded
     * @type {string}
     * @memberof UpdateRepoAvatarOption
     */
    'image'?: string;
}
/**
 * UpdateUserAvatarUserOption options when updating the user avatar
 * @export
 * @interface UpdateUserAvatarOption
 */
export interface UpdateUserAvatarOption {
    /**
     * image must be base64 encoded
     * @type {string}
     * @memberof UpdateUserAvatarOption
     */
    'image'?: string;
}
/**
 * User represents a user
 * @export
 * @interface User
 */
export interface User {
    /**
     * Is user active
     * @type {boolean}
     * @memberof User
     */
    'active'?: boolean;
    /**
     * URL to the user\'s avatar
     * @type {string}
     * @memberof User
     */
    'avatar_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'created'?: string;
    /**
     * the user\'s description
     * @type {string}
     * @memberof User
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * user counts
     * @type {number}
     * @memberof User
     */
    'followers_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'following_count'?: number;
    /**
     * the user\'s full name
     * @type {string}
     * @memberof User
     */
    'full_name'?: string;
    /**
     * the user\'s id
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * Is the user an administrator
     * @type {boolean}
     * @memberof User
     */
    'is_admin'?: boolean;
    /**
     * User locale
     * @type {string}
     * @memberof User
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_login'?: string;
    /**
     * the user\'s location
     * @type {string}
     * @memberof User
     */
    'location'?: string;
    /**
     * the user\'s username
     * @type {string}
     * @memberof User
     */
    'login'?: string;
    /**
     * the user\'s authentication sign-in name.
     * @type {string}
     * @memberof User
     */
    'login_name'?: string;
    /**
     * Is user login prohibited
     * @type {boolean}
     * @memberof User
     */
    'prohibit_login'?: boolean;
    /**
     * Is user restricted
     * @type {boolean}
     * @memberof User
     */
    'restricted'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'starred_repos_count'?: number;
    /**
     * User visibility level option: public, limited, private
     * @type {string}
     * @memberof User
     */
    'visibility'?: string;
    /**
     * the user\'s website
     * @type {string}
     * @memberof User
     */
    'website'?: string;
}
/**
 * UserHeatmapData represents the data needed to create a heatmap
 * @export
 * @interface UserHeatmapData
 */
export interface UserHeatmapData {
    /**
     * 
     * @type {number}
     * @memberof UserHeatmapData
     */
    'contributions'?: number;
    /**
     * TimeStamp defines a timestamp
     * @type {number}
     * @memberof UserHeatmapData
     */
    'timestamp'?: number;
}
/**
 * 
 * @export
 * @interface UserSearch200Response
 */
export interface UserSearch200Response {
    /**
     * 
     * @type {Array<User>}
     * @memberof UserSearch200Response
     */
    'data'?: Array<User>;
    /**
     * 
     * @type {boolean}
     * @memberof UserSearch200Response
     */
    'ok'?: boolean;
}
/**
 * UserSettings represents user settings
 * @export
 * @interface UserSettings
 */
export interface UserSettings {
    /**
     * 
     * @type {string}
     * @memberof UserSettings
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSettings
     */
    'diff_view_style'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSettings
     */
    'full_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserSettings
     */
    'hide_activity'?: boolean;
    /**
     * Privacy
     * @type {boolean}
     * @memberof UserSettings
     */
    'hide_email'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSettings
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSettings
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSettings
     */
    'theme'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSettings
     */
    'website'?: string;
}
/**
 * UserSettingsOptions represents options to change user settings
 * @export
 * @interface UserSettingsOptions
 */
export interface UserSettingsOptions {
    /**
     * 
     * @type {string}
     * @memberof UserSettingsOptions
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSettingsOptions
     */
    'diff_view_style'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSettingsOptions
     */
    'full_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserSettingsOptions
     */
    'hide_activity'?: boolean;
    /**
     * Privacy
     * @type {boolean}
     * @memberof UserSettingsOptions
     */
    'hide_email'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSettingsOptions
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSettingsOptions
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSettingsOptions
     */
    'theme'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSettingsOptions
     */
    'website'?: string;
}
/**
 * WatchInfo represents an API watch status of one repository
 * @export
 * @interface WatchInfo
 */
export interface WatchInfo {
    /**
     * 
     * @type {string}
     * @memberof WatchInfo
     */
    'created_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WatchInfo
     */
    'ignored'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof WatchInfo
     */
    'reason'?: object;
    /**
     * 
     * @type {string}
     * @memberof WatchInfo
     */
    'repository_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WatchInfo
     */
    'subscribed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WatchInfo
     */
    'url'?: string;
}
/**
 * WikiCommit page commit/revision
 * @export
 * @interface WikiCommit
 */
export interface WikiCommit {
    /**
     * 
     * @type {CommitUser}
     * @memberof WikiCommit
     */
    'author'?: CommitUser;
    /**
     * 
     * @type {CommitUser}
     * @memberof WikiCommit
     */
    'commiter'?: CommitUser;
    /**
     * 
     * @type {string}
     * @memberof WikiCommit
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof WikiCommit
     */
    'sha'?: string;
}
/**
 * WikiCommitList commit/revision list
 * @export
 * @interface WikiCommitList
 */
export interface WikiCommitList {
    /**
     * 
     * @type {Array<WikiCommit>}
     * @memberof WikiCommitList
     */
    'commits'?: Array<WikiCommit>;
    /**
     * 
     * @type {number}
     * @memberof WikiCommitList
     */
    'count'?: number;
}
/**
 * WikiPage a wiki page
 * @export
 * @interface WikiPage
 */
export interface WikiPage {
    /**
     * 
     * @type {number}
     * @memberof WikiPage
     */
    'commit_count'?: number;
    /**
     * Page content, base64 encoded
     * @type {string}
     * @memberof WikiPage
     */
    'content_base64'?: string;
    /**
     * 
     * @type {string}
     * @memberof WikiPage
     */
    'footer'?: string;
    /**
     * 
     * @type {string}
     * @memberof WikiPage
     */
    'html_url'?: string;
    /**
     * 
     * @type {WikiCommit}
     * @memberof WikiPage
     */
    'last_commit'?: WikiCommit;
    /**
     * 
     * @type {string}
     * @memberof WikiPage
     */
    'sidebar'?: string;
    /**
     * 
     * @type {string}
     * @memberof WikiPage
     */
    'sub_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof WikiPage
     */
    'title'?: string;
}
/**
 * WikiPageMetaData wiki page meta information
 * @export
 * @interface WikiPageMetaData
 */
export interface WikiPageMetaData {
    /**
     * 
     * @type {string}
     * @memberof WikiPageMetaData
     */
    'html_url'?: string;
    /**
     * 
     * @type {WikiCommit}
     * @memberof WikiPageMetaData
     */
    'last_commit'?: WikiCommit;
    /**
     * 
     * @type {string}
     * @memberof WikiPageMetaData
     */
    'sub_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof WikiPageMetaData
     */
    'title'?: string;
}

/**
 * ActivitypubApi - axios parameter creator
 * @export
 */
export const ActivitypubApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the Person actor for a user
         * @param {number} userId user ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitypubPerson: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('activitypubPerson', 'userId', userId)
            const localVarPath = `/activitypub/user-id/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send to the inbox
         * @param {number} userId user ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitypubPersonInbox: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('activitypubPersonInbox', 'userId', userId)
            const localVarPath = `/activitypub/user-id/{user-id}/inbox`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivitypubApi - functional programming interface
 * @export
 */
export const ActivitypubApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivitypubApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns the Person actor for a user
         * @param {number} userId user ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activitypubPerson(userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityPub>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activitypubPerson(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send to the inbox
         * @param {number} userId user ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activitypubPersonInbox(userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activitypubPersonInbox(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActivitypubApi - factory interface
 * @export
 */
export const ActivitypubApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivitypubApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns the Person actor for a user
         * @param {number} userId user ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitypubPerson(userId: number, options?: any): AxiosPromise<ActivityPub> {
            return localVarFp.activitypubPerson(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send to the inbox
         * @param {number} userId user ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitypubPersonInbox(userId: number, options?: any): AxiosPromise<void> {
            return localVarFp.activitypubPersonInbox(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivitypubApi - interface
 * @export
 * @interface ActivitypubApi
 */
export interface ActivitypubApiInterface {
    /**
     * 
     * @summary Returns the Person actor for a user
     * @param {number} userId user ID of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitypubApiInterface
     */
    activitypubPerson(userId: number, options?: AxiosRequestConfig): AxiosPromise<ActivityPub>;

    /**
     * 
     * @summary Send to the inbox
     * @param {number} userId user ID of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitypubApiInterface
     */
    activitypubPersonInbox(userId: number, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * ActivitypubApi - object-oriented interface
 * @export
 * @class ActivitypubApi
 * @extends {BaseAPI}
 */
export class ActivitypubApi extends BaseAPI implements ActivitypubApiInterface {
    /**
     * 
     * @summary Returns the Person actor for a user
     * @param {number} userId user ID of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitypubApi
     */
    public activitypubPerson(userId: number, options?: AxiosRequestConfig) {
        return ActivitypubApiFp(this.configuration).activitypubPerson(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send to the inbox
     * @param {number} userId user ID of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitypubApi
     */
    public activitypubPersonInbox(userId: number, options?: AxiosRequestConfig) {
        return ActivitypubApiFp(this.configuration).activitypubPersonInbox(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adopt unadopted files as a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAdoptRepository: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('adminAdoptRepository', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('adminAdoptRepository', 'repo', repo)
            const localVarPath = `/admin/unadopted/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a hook
         * @param {CreateHookOption} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateHook: async (body: CreateHookOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('adminCreateHook', 'body', body)
            const localVarPath = `/admin/hooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an organization
         * @param {string} username username of the user that will own the created organization
         * @param {CreateOrgOption} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateOrg: async (username: string, organization: CreateOrgOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('adminCreateOrg', 'username', username)
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('adminCreateOrg', 'organization', organization)
            const localVarPath = `/admin/users/{username}/orgs`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a public key on behalf of a user
         * @param {string} username username of the user
         * @param {CreateKeyOption} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreatePublicKey: async (username: string, key?: CreateKeyOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('adminCreatePublicKey', 'username', username)
            const localVarPath = `/admin/users/{username}/keys`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a repository on behalf of a user
         * @param {string} username username of the user. This user will own the created repository
         * @param {CreateRepoOption} repository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateRepo: async (username: string, repository: CreateRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('adminCreateRepo', 'username', username)
            // verify required parameter 'repository' is not null or undefined
            assertParamExists('adminCreateRepo', 'repository', repository)
            const localVarPath = `/admin/users/{username}/repos`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repository, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a user
         * @param {CreateUserOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateUser: async (body?: CreateUserOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List cron tasks
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCronList: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/cron`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run cron task
         * @param {string} task task to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCronRun: async (task: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'task' is not null or undefined
            assertParamExists('adminCronRun', 'task', task)
            const localVarPath = `/admin/cron/{task}`
                .replace(`{${"task"}}`, encodeURIComponent(String(task)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a hook
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteHook: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminDeleteHook', 'id', id)
            const localVarPath = `/admin/hooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete unadopted files
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUnadoptedRepository: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('adminDeleteUnadoptedRepository', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('adminDeleteUnadoptedRepository', 'repo', repo)
            const localVarPath = `/admin/unadopted/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} username username of user to delete
         * @param {boolean} [purge] purge the user from the system completely
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUser: async (username: string, purge?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('adminDeleteUser', 'username', username)
            const localVarPath = `/admin/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (purge !== undefined) {
                localVarQueryParameter['purge'] = purge;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a user\'s public key
         * @param {string} username username of user
         * @param {number} id id of the key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUserPublicKey: async (username: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('adminDeleteUserPublicKey', 'username', username)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminDeleteUserPublicKey', 'id', id)
            const localVarPath = `/admin/users/{username}/keys/{id}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a hook
         * @param {number} id id of the hook to update
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminEditHook: async (id: number, body?: EditHookOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminEditHook', 'id', id)
            const localVarPath = `/admin/hooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit an existing user
         * @param {string} username username of user to edit
         * @param {EditUserOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminEditUser: async (username: string, body?: EditUserOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('adminEditUser', 'username', username)
            const localVarPath = `/admin/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all emails
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetAllEmails: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/emails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all organizations
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetAllOrgs: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a hook
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetHook: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminGetHook', 'id', id)
            const localVarPath = `/admin/hooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List system\'s webhooks
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminListHooks: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/hooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rename a user
         * @param {string} username existing username of user
         * @param {RenameUserOption} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRenameUser: async (username: string, body: RenameUserOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('adminRenameUser', 'username', username)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('adminRenameUser', 'body', body)
            const localVarPath = `/admin/users/{username}/rename`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search all emails
         * @param {string} [q] keyword
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminSearchEmails: async (q?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/emails/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search users according filter conditions
         * @param {number} [sourceId] ID of the user\&#39;s login source to search for
         * @param {string} [loginName] user\&#39;s login name to search for
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminSearchUsers: async (sourceId?: number, loginName?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (sourceId !== undefined) {
                localVarQueryParameter['source_id'] = sourceId;
            }

            if (loginName !== undefined) {
                localVarQueryParameter['login_name'] = loginName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List unadopted repositories
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {string} [pattern] pattern of repositories to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUnadoptedList: async (page?: number, limit?: number, pattern?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/unadopted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (pattern !== undefined) {
                localVarQueryParameter['pattern'] = pattern;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adopt unadopted files as a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminAdoptRepository(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminAdoptRepository(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a hook
         * @param {CreateHookOption} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCreateHook(body: CreateHookOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreateHook(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an organization
         * @param {string} username username of the user that will own the created organization
         * @param {CreateOrgOption} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCreateOrg(username: string, organization: CreateOrgOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreateOrg(username, organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a public key on behalf of a user
         * @param {string} username username of the user
         * @param {CreateKeyOption} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCreatePublicKey(username: string, key?: CreateKeyOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreatePublicKey(username, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a repository on behalf of a user
         * @param {string} username username of the user. This user will own the created repository
         * @param {CreateRepoOption} repository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCreateRepo(username: string, repository: CreateRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreateRepo(username, repository, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a user
         * @param {CreateUserOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCreateUser(body?: CreateUserOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreateUser(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List cron tasks
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCronList(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Cron>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCronList(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Run cron task
         * @param {string} task task to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCronRun(task: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCronRun(task, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a hook
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteHook(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteHook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete unadopted files
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteUnadoptedRepository(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteUnadoptedRepository(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} username username of user to delete
         * @param {boolean} [purge] purge the user from the system completely
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteUser(username: string, purge?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteUser(username, purge, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a user\'s public key
         * @param {string} username username of user
         * @param {number} id id of the key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteUserPublicKey(username: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteUserPublicKey(username, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a hook
         * @param {number} id id of the hook to update
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminEditHook(id: number, body?: EditHookOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminEditHook(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit an existing user
         * @param {string} username username of user to edit
         * @param {EditUserOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminEditUser(username: string, body?: EditUserOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminEditUser(username, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all emails
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminGetAllEmails(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Email>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetAllEmails(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all organizations
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminGetAllOrgs(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetAllOrgs(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a hook
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminGetHook(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetHook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List system\'s webhooks
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminListHooks(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hook>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminListHooks(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Rename a user
         * @param {string} username existing username of user
         * @param {RenameUserOption} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminRenameUser(username: string, body: RenameUserOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminRenameUser(username, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search all emails
         * @param {string} [q] keyword
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminSearchEmails(q?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Email>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminSearchEmails(q, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search users according filter conditions
         * @param {number} [sourceId] ID of the user\&#39;s login source to search for
         * @param {string} [loginName] user\&#39;s login name to search for
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminSearchUsers(sourceId?: number, loginName?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminSearchUsers(sourceId, loginName, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List unadopted repositories
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {string} [pattern] pattern of repositories to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUnadoptedList(page?: number, limit?: number, pattern?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUnadoptedList(page, limit, pattern, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * 
         * @summary Adopt unadopted files as a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAdoptRepository(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.adminAdoptRepository(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a hook
         * @param {CreateHookOption} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateHook(body: CreateHookOption, options?: any): AxiosPromise<Hook> {
            return localVarFp.adminCreateHook(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an organization
         * @param {string} username username of the user that will own the created organization
         * @param {CreateOrgOption} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateOrg(username: string, organization: CreateOrgOption, options?: any): AxiosPromise<Organization> {
            return localVarFp.adminCreateOrg(username, organization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a public key on behalf of a user
         * @param {string} username username of the user
         * @param {CreateKeyOption} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreatePublicKey(username: string, key?: CreateKeyOption, options?: any): AxiosPromise<PublicKey> {
            return localVarFp.adminCreatePublicKey(username, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a repository on behalf of a user
         * @param {string} username username of the user. This user will own the created repository
         * @param {CreateRepoOption} repository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateRepo(username: string, repository: CreateRepoOption, options?: any): AxiosPromise<Repository> {
            return localVarFp.adminCreateRepo(username, repository, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a user
         * @param {CreateUserOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateUser(body?: CreateUserOption, options?: any): AxiosPromise<User> {
            return localVarFp.adminCreateUser(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List cron tasks
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCronList(page?: number, limit?: number, options?: any): AxiosPromise<Array<Cron>> {
            return localVarFp.adminCronList(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run cron task
         * @param {string} task task to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCronRun(task: string, options?: any): AxiosPromise<void> {
            return localVarFp.adminCronRun(task, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a hook
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteHook(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.adminDeleteHook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete unadopted files
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUnadoptedRepository(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.adminDeleteUnadoptedRepository(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} username username of user to delete
         * @param {boolean} [purge] purge the user from the system completely
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUser(username: string, purge?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.adminDeleteUser(username, purge, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a user\'s public key
         * @param {string} username username of user
         * @param {number} id id of the key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUserPublicKey(username: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.adminDeleteUserPublicKey(username, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a hook
         * @param {number} id id of the hook to update
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminEditHook(id: number, body?: EditHookOption, options?: any): AxiosPromise<Hook> {
            return localVarFp.adminEditHook(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit an existing user
         * @param {string} username username of user to edit
         * @param {EditUserOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminEditUser(username: string, body?: EditUserOption, options?: any): AxiosPromise<User> {
            return localVarFp.adminEditUser(username, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all emails
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetAllEmails(page?: number, limit?: number, options?: any): AxiosPromise<Array<Email>> {
            return localVarFp.adminGetAllEmails(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all organizations
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetAllOrgs(page?: number, limit?: number, options?: any): AxiosPromise<Array<Organization>> {
            return localVarFp.adminGetAllOrgs(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a hook
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetHook(id: number, options?: any): AxiosPromise<Hook> {
            return localVarFp.adminGetHook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List system\'s webhooks
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminListHooks(page?: number, limit?: number, options?: any): AxiosPromise<Array<Hook>> {
            return localVarFp.adminListHooks(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rename a user
         * @param {string} username existing username of user
         * @param {RenameUserOption} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRenameUser(username: string, body: RenameUserOption, options?: any): AxiosPromise<void> {
            return localVarFp.adminRenameUser(username, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search all emails
         * @param {string} [q] keyword
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminSearchEmails(q?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Email>> {
            return localVarFp.adminSearchEmails(q, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search users according filter conditions
         * @param {number} [sourceId] ID of the user\&#39;s login source to search for
         * @param {string} [loginName] user\&#39;s login name to search for
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminSearchUsers(sourceId?: number, loginName?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.adminSearchUsers(sourceId, loginName, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List unadopted repositories
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {string} [pattern] pattern of repositories to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUnadoptedList(page?: number, limit?: number, pattern?: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.adminUnadoptedList(page, limit, pattern, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - interface
 * @export
 * @interface AdminApi
 */
export interface AdminApiInterface {
    /**
     * 
     * @summary Adopt unadopted files as a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminAdoptRepository(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Create a hook
     * @param {CreateHookOption} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminCreateHook(body: CreateHookOption, options?: AxiosRequestConfig): AxiosPromise<Hook>;

    /**
     * 
     * @summary Create an organization
     * @param {string} username username of the user that will own the created organization
     * @param {CreateOrgOption} organization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminCreateOrg(username: string, organization: CreateOrgOption, options?: AxiosRequestConfig): AxiosPromise<Organization>;

    /**
     * 
     * @summary Add a public key on behalf of a user
     * @param {string} username username of the user
     * @param {CreateKeyOption} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminCreatePublicKey(username: string, key?: CreateKeyOption, options?: AxiosRequestConfig): AxiosPromise<PublicKey>;

    /**
     * 
     * @summary Create a repository on behalf of a user
     * @param {string} username username of the user. This user will own the created repository
     * @param {CreateRepoOption} repository 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminCreateRepo(username: string, repository: CreateRepoOption, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Create a user
     * @param {CreateUserOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminCreateUser(body?: CreateUserOption, options?: AxiosRequestConfig): AxiosPromise<User>;

    /**
     * 
     * @summary List cron tasks
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminCronList(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Cron>>;

    /**
     * 
     * @summary Run cron task
     * @param {string} task task to run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminCronRun(task: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a hook
     * @param {number} id id of the hook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminDeleteHook(id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete unadopted files
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminDeleteUnadoptedRepository(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a user
     * @param {string} username username of user to delete
     * @param {boolean} [purge] purge the user from the system completely
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminDeleteUser(username: string, purge?: boolean, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a user\'s public key
     * @param {string} username username of user
     * @param {number} id id of the key to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminDeleteUserPublicKey(username: string, id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Update a hook
     * @param {number} id id of the hook to update
     * @param {EditHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminEditHook(id: number, body?: EditHookOption, options?: AxiosRequestConfig): AxiosPromise<Hook>;

    /**
     * 
     * @summary Edit an existing user
     * @param {string} username username of user to edit
     * @param {EditUserOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminEditUser(username: string, body?: EditUserOption, options?: AxiosRequestConfig): AxiosPromise<User>;

    /**
     * 
     * @summary List all emails
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminGetAllEmails(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Email>>;

    /**
     * 
     * @summary List all organizations
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminGetAllOrgs(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Organization>>;

    /**
     * 
     * @summary Get a hook
     * @param {number} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminGetHook(id: number, options?: AxiosRequestConfig): AxiosPromise<Hook>;

    /**
     * 
     * @summary List system\'s webhooks
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminListHooks(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Hook>>;

    /**
     * 
     * @summary Rename a user
     * @param {string} username existing username of user
     * @param {RenameUserOption} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminRenameUser(username: string, body: RenameUserOption, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Search all emails
     * @param {string} [q] keyword
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminSearchEmails(q?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Email>>;

    /**
     * 
     * @summary Search users according filter conditions
     * @param {number} [sourceId] ID of the user\&#39;s login source to search for
     * @param {string} [loginName] user\&#39;s login name to search for
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminSearchUsers(sourceId?: number, loginName?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary List unadopted repositories
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {string} [pattern] pattern of repositories to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminUnadoptedList(page?: number, limit?: number, pattern?: string, options?: AxiosRequestConfig): AxiosPromise<Array<string>>;

}

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI implements AdminApiInterface {
    /**
     * 
     * @summary Adopt unadopted files as a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminAdoptRepository(owner: string, repo: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminAdoptRepository(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a hook
     * @param {CreateHookOption} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminCreateHook(body: CreateHookOption, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminCreateHook(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an organization
     * @param {string} username username of the user that will own the created organization
     * @param {CreateOrgOption} organization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminCreateOrg(username: string, organization: CreateOrgOption, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminCreateOrg(username, organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a public key on behalf of a user
     * @param {string} username username of the user
     * @param {CreateKeyOption} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminCreatePublicKey(username: string, key?: CreateKeyOption, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminCreatePublicKey(username, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a repository on behalf of a user
     * @param {string} username username of the user. This user will own the created repository
     * @param {CreateRepoOption} repository 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminCreateRepo(username: string, repository: CreateRepoOption, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminCreateRepo(username, repository, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a user
     * @param {CreateUserOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminCreateUser(body?: CreateUserOption, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminCreateUser(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List cron tasks
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminCronList(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminCronList(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run cron task
     * @param {string} task task to run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminCronRun(task: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminCronRun(task, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a hook
     * @param {number} id id of the hook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminDeleteHook(id: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminDeleteHook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete unadopted files
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminDeleteUnadoptedRepository(owner: string, repo: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminDeleteUnadoptedRepository(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a user
     * @param {string} username username of user to delete
     * @param {boolean} [purge] purge the user from the system completely
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminDeleteUser(username: string, purge?: boolean, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminDeleteUser(username, purge, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a user\'s public key
     * @param {string} username username of user
     * @param {number} id id of the key to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminDeleteUserPublicKey(username: string, id: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminDeleteUserPublicKey(username, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a hook
     * @param {number} id id of the hook to update
     * @param {EditHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminEditHook(id: number, body?: EditHookOption, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminEditHook(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit an existing user
     * @param {string} username username of user to edit
     * @param {EditUserOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminEditUser(username: string, body?: EditUserOption, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminEditUser(username, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all emails
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminGetAllEmails(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminGetAllEmails(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all organizations
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminGetAllOrgs(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminGetAllOrgs(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a hook
     * @param {number} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminGetHook(id: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminGetHook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List system\'s webhooks
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminListHooks(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminListHooks(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rename a user
     * @param {string} username existing username of user
     * @param {RenameUserOption} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminRenameUser(username: string, body: RenameUserOption, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminRenameUser(username, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search all emails
     * @param {string} [q] keyword
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminSearchEmails(q?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminSearchEmails(q, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search users according filter conditions
     * @param {number} [sourceId] ID of the user\&#39;s login source to search for
     * @param {string} [loginName] user\&#39;s login name to search for
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminSearchUsers(sourceId?: number, loginName?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminSearchUsers(sourceId, loginName, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List unadopted repositories
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {string} [pattern] pattern of repositories to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUnadoptedList(page?: number, limit?: number, pattern?: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUnadoptedList(page, limit, pattern, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IssueApi - axios parameter creator
 * @export
 */
export const IssueApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a label to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {IssueLabelsOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueAddLabel: async (owner: string, repo: string, index: number, body?: IssueLabelsOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueAddLabel', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueAddLabel', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueAddLabel', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/labels`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Subscribe user to issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} user user to subscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueAddSubscription: async (owner: string, repo: string, index: number, user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueAddSubscription', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueAddSubscription', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueAddSubscription', 'index', index)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('issueAddSubscription', 'user', user)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/subscriptions/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add tracked time to a issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {AddTimeOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueAddTime: async (owner: string, repo: string, index: number, body?: AddTimeOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueAddTime', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueAddTime', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueAddTime', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/times`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if user is subscribed to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCheckSubscription: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCheckSubscription', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCheckSubscription', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueCheckSubscription', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/subscriptions/check`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all labels from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueClearLabels: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueClearLabels', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueClearLabels', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueClearLabels', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/labels`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a comment to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {CreateIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateComment: async (owner: string, repo: string, index: number, body?: CreateIssueCommentOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCreateComment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCreateComment', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueCreateComment', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/comments`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an issue. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateIssueOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateIssue: async (owner: string, repo: string, body?: CreateIssueOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCreateIssue', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCreateIssue', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/issues`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {File} attachment attachment to upload
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateIssueAttachment: async (owner: string, repo: string, index: number, attachment: File, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCreateIssueAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCreateIssueAttachment', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueCreateIssueAttachment', 'index', index)
            // verify required parameter 'attachment' is not null or undefined
            assertParamExists('issueCreateIssueAttachment', 'attachment', attachment)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/assets`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


            if (attachment !== undefined) { 
                localVarFormParams.append('attachment', attachment as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Block the issue given in the body by the issue in path
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateIssueBlocking: async (owner: string, repo: string, index: string, body?: IssueMeta, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCreateIssueBlocking', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCreateIssueBlocking', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueCreateIssueBlocking', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/blocks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {File} attachment attachment to upload
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateIssueCommentAttachment: async (owner: string, repo: string, id: number, attachment: File, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCreateIssueCommentAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCreateIssueCommentAttachment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueCreateIssueCommentAttachment', 'id', id)
            // verify required parameter 'attachment' is not null or undefined
            assertParamExists('issueCreateIssueCommentAttachment', 'attachment', attachment)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}/assets`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


            if (attachment !== undefined) { 
                localVarFormParams.append('attachment', attachment as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Make the issue in the url depend on the issue in the form.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateIssueDependencies: async (owner: string, repo: string, index: string, body?: IssueMeta, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCreateIssueDependencies', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCreateIssueDependencies', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueCreateIssueDependencies', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/dependencies`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateLabel: async (owner: string, repo: string, body?: CreateLabelOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCreateLabel', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCreateLabel', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/labels`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateMilestoneOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateMilestone: async (owner: string, repo: string, body?: CreateMilestoneOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCreateMilestone', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCreateMilestone', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/milestones`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDelete: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDelete', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDelete', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueDelete', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of comment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteComment: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteComment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteComment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueDeleteComment', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index this parameter is ignored
         * @param {number} id id of comment to delete
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        issueDeleteCommentDeprecated: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteCommentDeprecated', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteCommentDeprecated', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueDeleteCommentDeprecated', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueDeleteCommentDeprecated', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/comments/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a reaction from a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteCommentReaction: async (owner: string, repo: string, id: number, content?: EditReactionOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteCommentReaction', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteCommentReaction', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueDeleteCommentReaction', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}/reactions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(content, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteIssueAttachment: async (owner: string, repo: string, index: number, attachmentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteIssueAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteIssueAttachment', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueDeleteIssueAttachment', 'index', index)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('issueDeleteIssueAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteIssueCommentAttachment: async (owner: string, repo: string, id: number, attachmentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteIssueCommentAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteIssueCommentAttachment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueDeleteIssueCommentAttachment', 'id', id)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('issueDeleteIssueCommentAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a reaction from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteIssueReaction: async (owner: string, repo: string, index: number, content?: EditReactionOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteIssueReaction', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteIssueReaction', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueDeleteIssueReaction', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/reactions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(content, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteLabel: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteLabel', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteLabel', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueDeleteLabel', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/labels/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to delete, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteMilestone: async (owner: string, repo: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteMilestone', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteMilestone', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueDeleteMilestone', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/milestones/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an issue\'s existing stopwatch.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to stop the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteStopWatch: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteStopWatch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteStopWatch', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueDeleteStopWatch', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/stopwatch/delete`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unsubscribe user from issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} user user witch unsubscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteSubscription: async (owner: string, repo: string, index: number, user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteSubscription', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteSubscription', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueDeleteSubscription', 'index', index)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('issueDeleteSubscription', 'user', user)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/subscriptions/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete specific tracked time
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} id id of time to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteTime: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteTime', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteTime', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueDeleteTime', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueDeleteTime', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/times/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditComment: async (owner: string, repo: string, id: number, body?: EditIssueCommentOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueEditComment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueEditComment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueEditComment', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index this parameter is ignored
         * @param {number} id id of the comment to edit
         * @param {EditIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        issueEditCommentDeprecated: async (owner: string, repo: string, index: number, id: number, body?: EditIssueCommentOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueEditCommentDeprecated', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueEditCommentDeprecated', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueEditCommentDeprecated', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueEditCommentDeprecated', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/comments/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit an issue. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to edit
         * @param {EditIssueOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditIssue: async (owner: string, repo: string, index: number, body?: EditIssueOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueEditIssue', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueEditIssue', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueEditIssue', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditIssueAttachment: async (owner: string, repo: string, index: number, attachmentId: number, body?: EditAttachmentOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueEditIssueAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueEditIssueAttachment', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueEditIssueAttachment', 'index', index)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('issueEditIssueAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditIssueCommentAttachment: async (owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueEditIssueCommentAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueEditIssueCommentAttachment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueEditIssueCommentAttachment', 'id', id)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('issueEditIssueCommentAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to create or update a deadline on
         * @param {EditDeadlineOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditIssueDeadline: async (owner: string, repo: string, index: number, body?: EditDeadlineOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueEditIssueDeadline', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueEditIssueDeadline', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueEditIssueDeadline', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/deadline`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to edit
         * @param {EditLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditLabel: async (owner: string, repo: string, id: number, body?: EditLabelOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueEditLabel', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueEditLabel', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueEditLabel', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/labels/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to edit, identified by ID and if not available by name
         * @param {EditMilestoneOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditMilestone: async (owner: string, repo: string, id: string, body?: EditMilestoneOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueEditMilestone', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueEditMilestone', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueEditMilestone', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/milestones/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetComment: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetComment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetComment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueGetComment', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of reactions from a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetCommentReactions: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetCommentReactions', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetCommentReactions', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueGetCommentReactions', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}/reactions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all comments on an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [since] if provided, only comments updated since the specified time are returned.
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetComments: async (owner: string, repo: string, index: number, since?: string, before?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetComments', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetComments', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueGetComments', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/comments`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all comments and events on an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [since] if provided, only comments updated since the specified time are returned.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetCommentsAndTimeline: async (owner: string, repo: string, index: number, since?: string, page?: number, limit?: number, before?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetCommentsAndTimeline', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetCommentsAndTimeline', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueGetCommentsAndTimeline', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/timeline`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetIssue: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetIssue', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetIssue', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueGetIssue', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetIssueAttachment: async (owner: string, repo: string, index: number, attachmentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetIssueAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetIssueAttachment', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueGetIssueAttachment', 'index', index)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('issueGetIssueAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetIssueCommentAttachment: async (owner: string, repo: string, id: number, attachmentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetIssueCommentAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetIssueCommentAttachment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueGetIssueCommentAttachment', 'id', id)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('issueGetIssueCommentAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list reactions of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetIssueReactions: async (owner: string, repo: string, index: number, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetIssueReactions', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetIssueReactions', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueGetIssueReactions', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/reactions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetLabel: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetLabel', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetLabel', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueGetLabel', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/labels/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an issue\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetLabels: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetLabels', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetLabels', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueGetLabels', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/labels`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to get, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetMilestone: async (owner: string, repo: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetMilestone', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetMilestone', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueGetMilestone', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/milestones/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all of a repository\'s opened milestones
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [state] Milestone state, Recognized values are open, closed and all. Defaults to \&quot;open\&quot;
         * @param {string} [name] filter by milestone name
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetMilestonesList: async (owner: string, repo: string, state?: string, name?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetMilestonesList', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetMilestonesList', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/milestones`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all comments in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [since] if provided, only comments updated since the provided time are returned.
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetRepoComments: async (owner: string, repo: string, since?: string, before?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetRepoComments', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetRepoComments', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List issues that are blocked by this issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListBlocks: async (owner: string, repo: string, index: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueListBlocks', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueListBlocks', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueListBlocks', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/blocks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List issue\'s attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListIssueAttachments: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueListIssueAttachments', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueListIssueAttachments', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueListIssueAttachments', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/assets`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List comment\'s attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListIssueCommentAttachments: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueListIssueCommentAttachments', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueListIssueCommentAttachments', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueListIssueCommentAttachments', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}/assets`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List an issue\'s dependencies, i.e all issues that block this issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListIssueDependencies: async (owner: string, repo: string, index: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueListIssueDependencies', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueListIssueDependencies', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueListIssueDependencies', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/dependencies`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {IssueListIssuesStateEnum} [state] whether issue is open or closed
         * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
         * @param {string} [q] search string
         * @param {IssueListIssuesTypeEnum} [type] filter by type (issues / pulls) if set
         * @param {string} [milestones] comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded
         * @param {string} [since] Only show items updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show items updated before the given time. This is a timestamp in RFC 3339 format
         * @param {string} [createdBy] Only show items which were created by the the given user
         * @param {string} [assignedBy] Only show items for which the given user is assigned
         * @param {string} [mentionedBy] Only show items in which the given user was mentioned
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListIssues: async (owner: string, repo: string, state?: IssueListIssuesStateEnum, labels?: string, q?: string, type?: IssueListIssuesTypeEnum, milestones?: string, since?: string, before?: string, createdBy?: string, assignedBy?: string, mentionedBy?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueListIssues', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueListIssues', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/issues`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (labels !== undefined) {
                localVarQueryParameter['labels'] = labels;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (milestones !== undefined) {
                localVarQueryParameter['milestones'] = milestones;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (assignedBy !== undefined) {
                localVarQueryParameter['assigned_by'] = assignedBy;
            }

            if (mentionedBy !== undefined) {
                localVarQueryParameter['mentioned_by'] = mentionedBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all of a repository\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListLabels: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueListLabels', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueListLabels', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/labels`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a reaction to a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuePostCommentReaction: async (owner: string, repo: string, id: number, content?: EditReactionOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issuePostCommentReaction', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issuePostCommentReaction', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issuePostCommentReaction', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}/reactions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(content, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a reaction to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuePostIssueReaction: async (owner: string, repo: string, index: number, content?: EditReactionOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issuePostIssueReaction', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issuePostIssueReaction', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issuePostIssueReaction', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/reactions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(content, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unblock the issue given in the body by the issue in path
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueRemoveIssueBlocking: async (owner: string, repo: string, index: string, body?: IssueMeta, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueRemoveIssueBlocking', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueRemoveIssueBlocking', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueRemoveIssueBlocking', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/blocks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an issue dependency
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueRemoveIssueDependencies: async (owner: string, repo: string, index: string, body?: IssueMeta, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueRemoveIssueDependencies', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueRemoveIssueDependencies', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueRemoveIssueDependencies', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/dependencies`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a label from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} id id of the label to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueRemoveLabel: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueRemoveLabel', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueRemoveLabel', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueRemoveLabel', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueRemoveLabel', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/labels/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace an issue\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {IssueLabelsOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueReplaceLabels: async (owner: string, repo: string, index: number, body?: IssueLabelsOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueReplaceLabels', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueReplaceLabels', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueReplaceLabels', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/labels`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset a tracked time of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to add tracked time to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueResetTime: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueResetTime', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueResetTime', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueResetTime', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/times`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for issues across the repositories that the user has access to
         * @param {string} [state] whether issue is open or closed
         * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
         * @param {string} [milestones] comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded
         * @param {string} [q] search string
         * @param {number} [priorityRepoId] repository to prioritize in the results
         * @param {string} [type] filter by type (issues / pulls) if set
         * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
         * @param {boolean} [assigned] filter (issues / pulls) assigned to you, default is false
         * @param {boolean} [created] filter (issues / pulls) created by you, default is false
         * @param {boolean} [mentioned] filter (issues / pulls) mentioning you, default is false
         * @param {boolean} [reviewRequested] filter pulls requesting your review, default is false
         * @param {boolean} [reviewed] filter pulls reviewed by you, default is false
         * @param {string} [owner] filter by owner
         * @param {string} [team] filter by team (requires organization owner parameter to be provided)
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueSearchIssues: async (state?: string, labels?: string, milestones?: string, q?: string, priorityRepoId?: number, type?: string, since?: string, before?: string, assigned?: boolean, created?: boolean, mentioned?: boolean, reviewRequested?: boolean, reviewed?: boolean, owner?: string, team?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/repos/issues/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (labels !== undefined) {
                localVarQueryParameter['labels'] = labels;
            }

            if (milestones !== undefined) {
                localVarQueryParameter['milestones'] = milestones;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (priorityRepoId !== undefined) {
                localVarQueryParameter['priority_repo_id'] = priorityRepoId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (assigned !== undefined) {
                localVarQueryParameter['assigned'] = assigned;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (mentioned !== undefined) {
                localVarQueryParameter['mentioned'] = mentioned;
            }

            if (reviewRequested !== undefined) {
                localVarQueryParameter['review_requested'] = reviewRequested;
            }

            if (reviewed !== undefined) {
                localVarQueryParameter['reviewed'] = reviewed;
            }

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (team !== undefined) {
                localVarQueryParameter['team'] = team;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start stopwatch on an issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to create the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueStartStopWatch: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueStartStopWatch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueStartStopWatch', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueStartStopWatch', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/stopwatch/start`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop an issue\'s existing stopwatch.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to stop the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueStopStopWatch: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueStopStopWatch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueStopStopWatch', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueStopStopWatch', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/stopwatch/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get users who subscribed on an issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueSubscriptions: async (owner: string, repo: string, index: number, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueSubscriptions', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueSubscriptions', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueSubscriptions', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/subscriptions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List an issue\'s tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueTrackedTimes: async (owner: string, repo: string, index: number, user?: string, since?: string, before?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueTrackedTimes', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueTrackedTimes', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueTrackedTimes', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/times`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Moves the Pin to the given Position
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue
         * @param {number} position the new position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveIssuePin: async (owner: string, repo: string, index: number, position: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('moveIssuePin', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('moveIssuePin', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('moveIssuePin', 'index', index)
            // verify required parameter 'position' is not null or undefined
            assertParamExists('moveIssuePin', 'position', position)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/pin/{position}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"position"}}`, encodeURIComponent(String(position)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pin an Issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue to pin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinIssue: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('pinIssue', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('pinIssue', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('pinIssue', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/pin`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unpin an Issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue to unpin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpinIssue: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('unpinIssue', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('unpinIssue', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('unpinIssue', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/pin`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IssueApi - functional programming interface
 * @export
 */
export const IssueApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IssueApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a label to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {IssueLabelsOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueAddLabel(owner: string, repo: string, index: number, body?: IssueLabelsOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Label>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueAddLabel(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Subscribe user to issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} user user to subscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueAddSubscription(owner: string, repo: string, index: number, user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueAddSubscription(owner, repo, index, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add tracked time to a issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {AddTimeOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueAddTime(owner: string, repo: string, index: number, body?: AddTimeOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackedTime>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueAddTime(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if user is subscribed to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCheckSubscription(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCheckSubscription(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove all labels from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueClearLabels(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueClearLabels(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a comment to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {CreateIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCreateComment(owner: string, repo: string, index: number, body?: CreateIssueCommentOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCreateComment(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an issue. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateIssueOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCreateIssue(owner: string, repo: string, body?: CreateIssueOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Issue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCreateIssue(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {File} attachment attachment to upload
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCreateIssueAttachment(owner: string, repo: string, index: number, attachment: File, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCreateIssueAttachment(owner, repo, index, attachment, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Block the issue given in the body by the issue in path
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCreateIssueBlocking(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Issue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCreateIssueBlocking(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {File} attachment attachment to upload
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCreateIssueCommentAttachment(owner: string, repo: string, id: number, attachment: File, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCreateIssueCommentAttachment(owner, repo, id, attachment, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Make the issue in the url depend on the issue in the form.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCreateIssueDependencies(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Issue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCreateIssueDependencies(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCreateLabel(owner: string, repo: string, body?: CreateLabelOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCreateLabel(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateMilestoneOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCreateMilestone(owner: string, repo: string, body?: CreateMilestoneOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Milestone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCreateMilestone(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDelete(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDelete(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of comment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteComment(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteComment(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index this parameter is ignored
         * @param {number} id id of comment to delete
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async issueDeleteCommentDeprecated(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteCommentDeprecated(owner, repo, index, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a reaction from a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteCommentReaction(owner: string, repo: string, id: number, content?: EditReactionOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteCommentReaction(owner, repo, id, content, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteIssueAttachment(owner, repo, index, attachmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteIssueCommentAttachment(owner, repo, id, attachmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a reaction from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteIssueReaction(owner: string, repo: string, index: number, content?: EditReactionOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteIssueReaction(owner, repo, index, content, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteLabel(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteLabel(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to delete, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteMilestone(owner: string, repo: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteMilestone(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an issue\'s existing stopwatch.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to stop the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteStopWatch(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteStopWatch(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unsubscribe user from issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} user user witch unsubscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteSubscription(owner: string, repo: string, index: number, user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteSubscription(owner, repo, index, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete specific tracked time
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} id id of time to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteTime(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteTime(owner, repo, index, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueEditComment(owner: string, repo: string, id: number, body?: EditIssueCommentOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEditComment(owner, repo, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index this parameter is ignored
         * @param {number} id id of the comment to edit
         * @param {EditIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async issueEditCommentDeprecated(owner: string, repo: string, index: number, id: number, body?: EditIssueCommentOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEditCommentDeprecated(owner, repo, index, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit an issue. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to edit
         * @param {EditIssueOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueEditIssue(owner: string, repo: string, index: number, body?: EditIssueOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Issue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEditIssue(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueEditIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, body?: EditAttachmentOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEditIssueAttachment(owner, repo, index, attachmentId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueEditIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEditIssueCommentAttachment(owner, repo, id, attachmentId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to create or update a deadline on
         * @param {EditDeadlineOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueEditIssueDeadline(owner: string, repo: string, index: number, body?: EditDeadlineOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IssueDeadline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEditIssueDeadline(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to edit
         * @param {EditLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueEditLabel(owner: string, repo: string, id: number, body?: EditLabelOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEditLabel(owner, repo, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to edit, identified by ID and if not available by name
         * @param {EditMilestoneOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueEditMilestone(owner: string, repo: string, id: string, body?: EditMilestoneOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Milestone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEditMilestone(owner, repo, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetComment(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetComment(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of reactions from a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetCommentReactions(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetCommentReactions(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all comments on an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [since] if provided, only comments updated since the specified time are returned.
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetComments(owner: string, repo: string, index: number, since?: string, before?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Comment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetComments(owner, repo, index, since, before, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all comments and events on an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [since] if provided, only comments updated since the specified time are returned.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetCommentsAndTimeline(owner: string, repo: string, index: number, since?: string, page?: number, limit?: number, before?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TimelineComment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetCommentsAndTimeline(owner, repo, index, since, page, limit, before, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetIssue(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Issue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetIssue(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetIssueAttachment(owner, repo, index, attachmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetIssueCommentAttachment(owner, repo, id, attachmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list reactions of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetIssueReactions(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetIssueReactions(owner, repo, index, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetLabel(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetLabel(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an issue\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetLabels(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Label>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetLabels(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to get, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetMilestone(owner: string, repo: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Milestone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetMilestone(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all of a repository\'s opened milestones
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [state] Milestone state, Recognized values are open, closed and all. Defaults to \&quot;open\&quot;
         * @param {string} [name] filter by milestone name
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetMilestonesList(owner: string, repo: string, state?: string, name?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Milestone>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetMilestonesList(owner, repo, state, name, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all comments in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [since] if provided, only comments updated since the provided time are returned.
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetRepoComments(owner: string, repo: string, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Comment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetRepoComments(owner, repo, since, before, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List issues that are blocked by this issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueListBlocks(owner: string, repo: string, index: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Issue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueListBlocks(owner, repo, index, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List issue\'s attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueListIssueAttachments(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Attachment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueListIssueAttachments(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List comment\'s attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueListIssueCommentAttachments(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Attachment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueListIssueCommentAttachments(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List an issue\'s dependencies, i.e all issues that block this issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueListIssueDependencies(owner: string, repo: string, index: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Issue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueListIssueDependencies(owner, repo, index, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {IssueListIssuesStateEnum} [state] whether issue is open or closed
         * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
         * @param {string} [q] search string
         * @param {IssueListIssuesTypeEnum} [type] filter by type (issues / pulls) if set
         * @param {string} [milestones] comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded
         * @param {string} [since] Only show items updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show items updated before the given time. This is a timestamp in RFC 3339 format
         * @param {string} [createdBy] Only show items which were created by the the given user
         * @param {string} [assignedBy] Only show items for which the given user is assigned
         * @param {string} [mentionedBy] Only show items in which the given user was mentioned
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueListIssues(owner: string, repo: string, state?: IssueListIssuesStateEnum, labels?: string, q?: string, type?: IssueListIssuesTypeEnum, milestones?: string, since?: string, before?: string, createdBy?: string, assignedBy?: string, mentionedBy?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Issue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueListIssues(owner, repo, state, labels, q, type, milestones, since, before, createdBy, assignedBy, mentionedBy, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all of a repository\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueListLabels(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Label>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueListLabels(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a reaction to a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issuePostCommentReaction(owner: string, repo: string, id: number, content?: EditReactionOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issuePostCommentReaction(owner, repo, id, content, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a reaction to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issuePostIssueReaction(owner: string, repo: string, index: number, content?: EditReactionOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issuePostIssueReaction(owner, repo, index, content, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unblock the issue given in the body by the issue in path
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueRemoveIssueBlocking(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Issue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueRemoveIssueBlocking(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove an issue dependency
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueRemoveIssueDependencies(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Issue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueRemoveIssueDependencies(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a label from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} id id of the label to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueRemoveLabel(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueRemoveLabel(owner, repo, index, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Replace an issue\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {IssueLabelsOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueReplaceLabels(owner: string, repo: string, index: number, body?: IssueLabelsOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Label>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueReplaceLabels(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reset a tracked time of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to add tracked time to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueResetTime(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueResetTime(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search for issues across the repositories that the user has access to
         * @param {string} [state] whether issue is open or closed
         * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
         * @param {string} [milestones] comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded
         * @param {string} [q] search string
         * @param {number} [priorityRepoId] repository to prioritize in the results
         * @param {string} [type] filter by type (issues / pulls) if set
         * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
         * @param {boolean} [assigned] filter (issues / pulls) assigned to you, default is false
         * @param {boolean} [created] filter (issues / pulls) created by you, default is false
         * @param {boolean} [mentioned] filter (issues / pulls) mentioning you, default is false
         * @param {boolean} [reviewRequested] filter pulls requesting your review, default is false
         * @param {boolean} [reviewed] filter pulls reviewed by you, default is false
         * @param {string} [owner] filter by owner
         * @param {string} [team] filter by team (requires organization owner parameter to be provided)
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueSearchIssues(state?: string, labels?: string, milestones?: string, q?: string, priorityRepoId?: number, type?: string, since?: string, before?: string, assigned?: boolean, created?: boolean, mentioned?: boolean, reviewRequested?: boolean, reviewed?: boolean, owner?: string, team?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Issue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueSearchIssues(state, labels, milestones, q, priorityRepoId, type, since, before, assigned, created, mentioned, reviewRequested, reviewed, owner, team, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start stopwatch on an issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to create the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueStartStopWatch(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueStartStopWatch(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop an issue\'s existing stopwatch.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to stop the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueStopStopWatch(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueStopStopWatch(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get users who subscribed on an issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueSubscriptions(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueSubscriptions(owner, repo, index, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List an issue\'s tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueTrackedTimes(owner: string, repo: string, index: number, user?: string, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrackedTime>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueTrackedTimes(owner, repo, index, user, since, before, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Moves the Pin to the given Position
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue
         * @param {number} position the new position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveIssuePin(owner: string, repo: string, index: number, position: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveIssuePin(owner, repo, index, position, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Pin an Issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue to pin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pinIssue(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pinIssue(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unpin an Issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue to unpin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unpinIssue(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unpinIssue(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IssueApi - factory interface
 * @export
 */
export const IssueApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IssueApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a label to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {IssueLabelsOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueAddLabel(owner: string, repo: string, index: number, body?: IssueLabelsOption, options?: any): AxiosPromise<Array<Label>> {
            return localVarFp.issueAddLabel(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Subscribe user to issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} user user to subscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueAddSubscription(owner: string, repo: string, index: number, user: string, options?: any): AxiosPromise<void> {
            return localVarFp.issueAddSubscription(owner, repo, index, user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add tracked time to a issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {AddTimeOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueAddTime(owner: string, repo: string, index: number, body?: AddTimeOption, options?: any): AxiosPromise<TrackedTime> {
            return localVarFp.issueAddTime(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if user is subscribed to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCheckSubscription(owner: string, repo: string, index: number, options?: any): AxiosPromise<WatchInfo> {
            return localVarFp.issueCheckSubscription(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all labels from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueClearLabels(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueClearLabels(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a comment to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {CreateIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateComment(owner: string, repo: string, index: number, body?: CreateIssueCommentOption, options?: any): AxiosPromise<Comment> {
            return localVarFp.issueCreateComment(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an issue. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateIssueOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateIssue(owner: string, repo: string, body?: CreateIssueOption, options?: any): AxiosPromise<Issue> {
            return localVarFp.issueCreateIssue(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {File} attachment attachment to upload
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateIssueAttachment(owner: string, repo: string, index: number, attachment: File, name?: string, options?: any): AxiosPromise<Attachment> {
            return localVarFp.issueCreateIssueAttachment(owner, repo, index, attachment, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Block the issue given in the body by the issue in path
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateIssueBlocking(owner: string, repo: string, index: string, body?: IssueMeta, options?: any): AxiosPromise<Issue> {
            return localVarFp.issueCreateIssueBlocking(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {File} attachment attachment to upload
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateIssueCommentAttachment(owner: string, repo: string, id: number, attachment: File, name?: string, options?: any): AxiosPromise<Attachment> {
            return localVarFp.issueCreateIssueCommentAttachment(owner, repo, id, attachment, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Make the issue in the url depend on the issue in the form.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateIssueDependencies(owner: string, repo: string, index: string, body?: IssueMeta, options?: any): AxiosPromise<Issue> {
            return localVarFp.issueCreateIssueDependencies(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateLabel(owner: string, repo: string, body?: CreateLabelOption, options?: any): AxiosPromise<Label> {
            return localVarFp.issueCreateLabel(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateMilestoneOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateMilestone(owner: string, repo: string, body?: CreateMilestoneOption, options?: any): AxiosPromise<Milestone> {
            return localVarFp.issueCreateMilestone(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDelete(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueDelete(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of comment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteComment(owner: string, repo: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteComment(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index this parameter is ignored
         * @param {number} id id of comment to delete
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        issueDeleteCommentDeprecated(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteCommentDeprecated(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a reaction from a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteCommentReaction(owner: string, repo: string, id: number, content?: EditReactionOption, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteCommentReaction(owner, repo, id, content, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteIssueAttachment(owner, repo, index, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteIssueCommentAttachment(owner, repo, id, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a reaction from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteIssueReaction(owner: string, repo: string, index: number, content?: EditReactionOption, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteIssueReaction(owner, repo, index, content, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteLabel(owner: string, repo: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteLabel(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to delete, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteMilestone(owner: string, repo: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteMilestone(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an issue\'s existing stopwatch.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to stop the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteStopWatch(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteStopWatch(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unsubscribe user from issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} user user witch unsubscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteSubscription(owner: string, repo: string, index: number, user: string, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteSubscription(owner, repo, index, user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete specific tracked time
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} id id of time to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteTime(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteTime(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditComment(owner: string, repo: string, id: number, body?: EditIssueCommentOption, options?: any): AxiosPromise<Comment> {
            return localVarFp.issueEditComment(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index this parameter is ignored
         * @param {number} id id of the comment to edit
         * @param {EditIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        issueEditCommentDeprecated(owner: string, repo: string, index: number, id: number, body?: EditIssueCommentOption, options?: any): AxiosPromise<Comment> {
            return localVarFp.issueEditCommentDeprecated(owner, repo, index, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit an issue. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to edit
         * @param {EditIssueOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditIssue(owner: string, repo: string, index: number, body?: EditIssueOption, options?: any): AxiosPromise<Issue> {
            return localVarFp.issueEditIssue(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, body?: EditAttachmentOptions, options?: any): AxiosPromise<Attachment> {
            return localVarFp.issueEditIssueAttachment(owner, repo, index, attachmentId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: any): AxiosPromise<Attachment> {
            return localVarFp.issueEditIssueCommentAttachment(owner, repo, id, attachmentId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to create or update a deadline on
         * @param {EditDeadlineOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditIssueDeadline(owner: string, repo: string, index: number, body?: EditDeadlineOption, options?: any): AxiosPromise<IssueDeadline> {
            return localVarFp.issueEditIssueDeadline(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to edit
         * @param {EditLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditLabel(owner: string, repo: string, id: number, body?: EditLabelOption, options?: any): AxiosPromise<Label> {
            return localVarFp.issueEditLabel(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to edit, identified by ID and if not available by name
         * @param {EditMilestoneOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditMilestone(owner: string, repo: string, id: string, body?: EditMilestoneOption, options?: any): AxiosPromise<Milestone> {
            return localVarFp.issueEditMilestone(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetComment(owner: string, repo: string, id: number, options?: any): AxiosPromise<Comment> {
            return localVarFp.issueGetComment(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of reactions from a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetCommentReactions(owner: string, repo: string, id: number, options?: any): AxiosPromise<Array<Reaction>> {
            return localVarFp.issueGetCommentReactions(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all comments on an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [since] if provided, only comments updated since the specified time are returned.
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetComments(owner: string, repo: string, index: number, since?: string, before?: string, options?: any): AxiosPromise<Array<Comment>> {
            return localVarFp.issueGetComments(owner, repo, index, since, before, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all comments and events on an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [since] if provided, only comments updated since the specified time are returned.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetCommentsAndTimeline(owner: string, repo: string, index: number, since?: string, page?: number, limit?: number, before?: string, options?: any): AxiosPromise<Array<TimelineComment>> {
            return localVarFp.issueGetCommentsAndTimeline(owner, repo, index, since, page, limit, before, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetIssue(owner: string, repo: string, index: number, options?: any): AxiosPromise<Issue> {
            return localVarFp.issueGetIssue(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, options?: any): AxiosPromise<Attachment> {
            return localVarFp.issueGetIssueAttachment(owner, repo, index, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: any): AxiosPromise<Attachment> {
            return localVarFp.issueGetIssueCommentAttachment(owner, repo, id, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list reactions of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetIssueReactions(owner: string, repo: string, index: number, page?: number, limit?: number, options?: any): AxiosPromise<Array<Reaction>> {
            return localVarFp.issueGetIssueReactions(owner, repo, index, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetLabel(owner: string, repo: string, id: number, options?: any): AxiosPromise<Label> {
            return localVarFp.issueGetLabel(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an issue\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetLabels(owner: string, repo: string, index: number, options?: any): AxiosPromise<Array<Label>> {
            return localVarFp.issueGetLabels(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to get, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetMilestone(owner: string, repo: string, id: string, options?: any): AxiosPromise<Milestone> {
            return localVarFp.issueGetMilestone(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all of a repository\'s opened milestones
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [state] Milestone state, Recognized values are open, closed and all. Defaults to \&quot;open\&quot;
         * @param {string} [name] filter by milestone name
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetMilestonesList(owner: string, repo: string, state?: string, name?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Milestone>> {
            return localVarFp.issueGetMilestonesList(owner, repo, state, name, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all comments in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [since] if provided, only comments updated since the provided time are returned.
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetRepoComments(owner: string, repo: string, since?: string, before?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Comment>> {
            return localVarFp.issueGetRepoComments(owner, repo, since, before, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List issues that are blocked by this issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListBlocks(owner: string, repo: string, index: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Issue>> {
            return localVarFp.issueListBlocks(owner, repo, index, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List issue\'s attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListIssueAttachments(owner: string, repo: string, index: number, options?: any): AxiosPromise<Array<Attachment>> {
            return localVarFp.issueListIssueAttachments(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List comment\'s attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListIssueCommentAttachments(owner: string, repo: string, id: number, options?: any): AxiosPromise<Array<Attachment>> {
            return localVarFp.issueListIssueCommentAttachments(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List an issue\'s dependencies, i.e all issues that block this issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListIssueDependencies(owner: string, repo: string, index: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Issue>> {
            return localVarFp.issueListIssueDependencies(owner, repo, index, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {IssueListIssuesStateEnum} [state] whether issue is open or closed
         * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
         * @param {string} [q] search string
         * @param {IssueListIssuesTypeEnum} [type] filter by type (issues / pulls) if set
         * @param {string} [milestones] comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded
         * @param {string} [since] Only show items updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show items updated before the given time. This is a timestamp in RFC 3339 format
         * @param {string} [createdBy] Only show items which were created by the the given user
         * @param {string} [assignedBy] Only show items for which the given user is assigned
         * @param {string} [mentionedBy] Only show items in which the given user was mentioned
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListIssues(owner: string, repo: string, state?: IssueListIssuesStateEnum, labels?: string, q?: string, type?: IssueListIssuesTypeEnum, milestones?: string, since?: string, before?: string, createdBy?: string, assignedBy?: string, mentionedBy?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Issue>> {
            return localVarFp.issueListIssues(owner, repo, state, labels, q, type, milestones, since, before, createdBy, assignedBy, mentionedBy, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all of a repository\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListLabels(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Label>> {
            return localVarFp.issueListLabels(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a reaction to a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuePostCommentReaction(owner: string, repo: string, id: number, content?: EditReactionOption, options?: any): AxiosPromise<Reaction> {
            return localVarFp.issuePostCommentReaction(owner, repo, id, content, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a reaction to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuePostIssueReaction(owner: string, repo: string, index: number, content?: EditReactionOption, options?: any): AxiosPromise<Reaction> {
            return localVarFp.issuePostIssueReaction(owner, repo, index, content, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unblock the issue given in the body by the issue in path
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueRemoveIssueBlocking(owner: string, repo: string, index: string, body?: IssueMeta, options?: any): AxiosPromise<Issue> {
            return localVarFp.issueRemoveIssueBlocking(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an issue dependency
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueRemoveIssueDependencies(owner: string, repo: string, index: string, body?: IssueMeta, options?: any): AxiosPromise<Issue> {
            return localVarFp.issueRemoveIssueDependencies(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a label from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} id id of the label to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueRemoveLabel(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueRemoveLabel(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Replace an issue\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {IssueLabelsOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueReplaceLabels(owner: string, repo: string, index: number, body?: IssueLabelsOption, options?: any): AxiosPromise<Array<Label>> {
            return localVarFp.issueReplaceLabels(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset a tracked time of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to add tracked time to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueResetTime(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueResetTime(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for issues across the repositories that the user has access to
         * @param {string} [state] whether issue is open or closed
         * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
         * @param {string} [milestones] comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded
         * @param {string} [q] search string
         * @param {number} [priorityRepoId] repository to prioritize in the results
         * @param {string} [type] filter by type (issues / pulls) if set
         * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
         * @param {boolean} [assigned] filter (issues / pulls) assigned to you, default is false
         * @param {boolean} [created] filter (issues / pulls) created by you, default is false
         * @param {boolean} [mentioned] filter (issues / pulls) mentioning you, default is false
         * @param {boolean} [reviewRequested] filter pulls requesting your review, default is false
         * @param {boolean} [reviewed] filter pulls reviewed by you, default is false
         * @param {string} [owner] filter by owner
         * @param {string} [team] filter by team (requires organization owner parameter to be provided)
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueSearchIssues(state?: string, labels?: string, milestones?: string, q?: string, priorityRepoId?: number, type?: string, since?: string, before?: string, assigned?: boolean, created?: boolean, mentioned?: boolean, reviewRequested?: boolean, reviewed?: boolean, owner?: string, team?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Issue>> {
            return localVarFp.issueSearchIssues(state, labels, milestones, q, priorityRepoId, type, since, before, assigned, created, mentioned, reviewRequested, reviewed, owner, team, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start stopwatch on an issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to create the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueStartStopWatch(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueStartStopWatch(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop an issue\'s existing stopwatch.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to stop the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueStopStopWatch(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueStopStopWatch(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get users who subscribed on an issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueSubscriptions(owner: string, repo: string, index: number, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.issueSubscriptions(owner, repo, index, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List an issue\'s tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueTrackedTimes(owner: string, repo: string, index: number, user?: string, since?: string, before?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<TrackedTime>> {
            return localVarFp.issueTrackedTimes(owner, repo, index, user, since, before, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Moves the Pin to the given Position
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue
         * @param {number} position the new position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveIssuePin(owner: string, repo: string, index: number, position: number, options?: any): AxiosPromise<void> {
            return localVarFp.moveIssuePin(owner, repo, index, position, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pin an Issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue to pin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinIssue(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.pinIssue(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unpin an Issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue to unpin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpinIssue(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.unpinIssue(owner, repo, index, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IssueApi - interface
 * @export
 * @interface IssueApi
 */
export interface IssueApiInterface {
    /**
     * 
     * @summary Add a label to an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {IssueLabelsOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueAddLabel(owner: string, repo: string, index: number, body?: IssueLabelsOption, options?: AxiosRequestConfig): AxiosPromise<Array<Label>>;

    /**
     * 
     * @summary Subscribe user to issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {string} user user to subscribe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueAddSubscription(owner: string, repo: string, index: number, user: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Add tracked time to a issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {AddTimeOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueAddTime(owner: string, repo: string, index: number, body?: AddTimeOption, options?: AxiosRequestConfig): AxiosPromise<TrackedTime>;

    /**
     * 
     * @summary Check if user is subscribed to an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueCheckSubscription(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<WatchInfo>;

    /**
     * 
     * @summary Remove all labels from an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueClearLabels(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Add a comment to an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {CreateIssueCommentOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueCreateComment(owner: string, repo: string, index: number, body?: CreateIssueCommentOption, options?: AxiosRequestConfig): AxiosPromise<Comment>;

    /**
     * 
     * @summary Create an issue. If using deadline only the date will be taken into account, and time of day ignored.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateIssueOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueCreateIssue(owner: string, repo: string, body?: CreateIssueOption, options?: AxiosRequestConfig): AxiosPromise<Issue>;

    /**
     * 
     * @summary Create an issue attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {File} attachment attachment to upload
     * @param {string} [name] name of the attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueCreateIssueAttachment(owner: string, repo: string, index: number, attachment: File, name?: string, options?: AxiosRequestConfig): AxiosPromise<Attachment>;

    /**
     * 
     * @summary Block the issue given in the body by the issue in path
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {IssueMeta} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueCreateIssueBlocking(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig): AxiosPromise<Issue>;

    /**
     * 
     * @summary Create a comment attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {File} attachment attachment to upload
     * @param {string} [name] name of the attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueCreateIssueCommentAttachment(owner: string, repo: string, id: number, attachment: File, name?: string, options?: AxiosRequestConfig): AxiosPromise<Attachment>;

    /**
     * 
     * @summary Make the issue in the url depend on the issue in the form.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {IssueMeta} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueCreateIssueDependencies(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig): AxiosPromise<Issue>;

    /**
     * 
     * @summary Create a label
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateLabelOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueCreateLabel(owner: string, repo: string, body?: CreateLabelOption, options?: AxiosRequestConfig): AxiosPromise<Label>;

    /**
     * 
     * @summary Create a milestone
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateMilestoneOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueCreateMilestone(owner: string, repo: string, body?: CreateMilestoneOption, options?: AxiosRequestConfig): AxiosPromise<Milestone>;

    /**
     * 
     * @summary Delete an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of issue to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDelete(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a comment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of comment to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDeleteComment(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a comment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index this parameter is ignored
     * @param {number} id id of comment to delete
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDeleteCommentDeprecated(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Remove a reaction from a comment of an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment to edit
     * @param {EditReactionOption} [content] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDeleteCommentReaction(owner: string, repo: string, id: number, content?: EditReactionOption, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete an issue attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} attachmentId id of the attachment to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDeleteIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a comment attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {number} attachmentId id of the attachment to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDeleteIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Remove a reaction from an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {EditReactionOption} [content] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDeleteIssueReaction(owner: string, repo: string, index: number, content?: EditReactionOption, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a label
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the label to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDeleteLabel(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a milestone
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id the milestone to delete, identified by ID and if not available by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDeleteMilestone(owner: string, repo: string, id: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete an issue\'s existing stopwatch.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to stop the stopwatch on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDeleteStopWatch(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Unsubscribe user from issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {string} user user witch unsubscribe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDeleteSubscription(owner: string, repo: string, index: number, user: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete specific tracked time
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} id id of time to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDeleteTime(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Edit a comment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment to edit
     * @param {EditIssueCommentOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueEditComment(owner: string, repo: string, id: number, body?: EditIssueCommentOption, options?: AxiosRequestConfig): AxiosPromise<Comment>;

    /**
     * 
     * @summary Edit a comment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index this parameter is ignored
     * @param {number} id id of the comment to edit
     * @param {EditIssueCommentOption} [body] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueEditCommentDeprecated(owner: string, repo: string, index: number, id: number, body?: EditIssueCommentOption, options?: AxiosRequestConfig): AxiosPromise<Comment>;

    /**
     * 
     * @summary Edit an issue. If using deadline only the date will be taken into account, and time of day ignored.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to edit
     * @param {EditIssueOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueEditIssue(owner: string, repo: string, index: number, body?: EditIssueOption, options?: AxiosRequestConfig): AxiosPromise<Issue>;

    /**
     * 
     * @summary Edit an issue attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} attachmentId id of the attachment to edit
     * @param {EditAttachmentOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueEditIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, body?: EditAttachmentOptions, options?: AxiosRequestConfig): AxiosPromise<Attachment>;

    /**
     * 
     * @summary Edit a comment attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {number} attachmentId id of the attachment to edit
     * @param {EditAttachmentOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueEditIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: AxiosRequestConfig): AxiosPromise<Attachment>;

    /**
     * 
     * @summary Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to create or update a deadline on
     * @param {EditDeadlineOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueEditIssueDeadline(owner: string, repo: string, index: number, body?: EditDeadlineOption, options?: AxiosRequestConfig): AxiosPromise<IssueDeadline>;

    /**
     * 
     * @summary Update a label
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the label to edit
     * @param {EditLabelOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueEditLabel(owner: string, repo: string, id: number, body?: EditLabelOption, options?: AxiosRequestConfig): AxiosPromise<Label>;

    /**
     * 
     * @summary Update a milestone
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id the milestone to edit, identified by ID and if not available by name
     * @param {EditMilestoneOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueEditMilestone(owner: string, repo: string, id: string, body?: EditMilestoneOption, options?: AxiosRequestConfig): AxiosPromise<Milestone>;

    /**
     * 
     * @summary Get a comment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetComment(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<Comment>;

    /**
     * 
     * @summary Get a list of reactions from a comment of an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment to edit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetCommentReactions(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<Array<Reaction>>;

    /**
     * 
     * @summary List all comments on an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {string} [since] if provided, only comments updated since the specified time are returned.
     * @param {string} [before] if provided, only comments updated before the provided time are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetComments(owner: string, repo: string, index: number, since?: string, before?: string, options?: AxiosRequestConfig): AxiosPromise<Array<Comment>>;

    /**
     * 
     * @summary List all comments and events on an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {string} [since] if provided, only comments updated since the specified time are returned.
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {string} [before] if provided, only comments updated before the provided time are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetCommentsAndTimeline(owner: string, repo: string, index: number, since?: string, page?: number, limit?: number, before?: string, options?: AxiosRequestConfig): AxiosPromise<Array<TimelineComment>>;

    /**
     * 
     * @summary Get an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetIssue(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<Issue>;

    /**
     * 
     * @summary Get an issue attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} attachmentId id of the attachment to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, options?: AxiosRequestConfig): AxiosPromise<Attachment>;

    /**
     * 
     * @summary Get a comment attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {number} attachmentId id of the attachment to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig): AxiosPromise<Attachment>;

    /**
     * 
     * @summary Get a list reactions of an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetIssueReactions(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Reaction>>;

    /**
     * 
     * @summary Get a single label
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the label to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetLabel(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<Label>;

    /**
     * 
     * @summary Get an issue\'s labels
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetLabels(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<Array<Label>>;

    /**
     * 
     * @summary Get a milestone
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id the milestone to get, identified by ID and if not available by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetMilestone(owner: string, repo: string, id: string, options?: AxiosRequestConfig): AxiosPromise<Milestone>;

    /**
     * 
     * @summary Get all of a repository\'s opened milestones
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [state] Milestone state, Recognized values are open, closed and all. Defaults to \&quot;open\&quot;
     * @param {string} [name] filter by milestone name
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetMilestonesList(owner: string, repo: string, state?: string, name?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Milestone>>;

    /**
     * 
     * @summary List all comments in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [since] if provided, only comments updated since the provided time are returned.
     * @param {string} [before] if provided, only comments updated before the provided time are returned.
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetRepoComments(owner: string, repo: string, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Comment>>;

    /**
     * 
     * @summary List issues that are blocked by this issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueListBlocks(owner: string, repo: string, index: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Issue>>;

    /**
     * 
     * @summary List issue\'s attachments
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueListIssueAttachments(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<Array<Attachment>>;

    /**
     * 
     * @summary List comment\'s attachments
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueListIssueCommentAttachments(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<Array<Attachment>>;

    /**
     * 
     * @summary List an issue\'s dependencies, i.e all issues that block this issue.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueListIssueDependencies(owner: string, repo: string, index: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Issue>>;

    /**
     * 
     * @summary List a repository\'s issues
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {IssueListIssuesStateEnum} [state] whether issue is open or closed
     * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
     * @param {string} [q] search string
     * @param {IssueListIssuesTypeEnum} [type] filter by type (issues / pulls) if set
     * @param {string} [milestones] comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded
     * @param {string} [since] Only show items updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show items updated before the given time. This is a timestamp in RFC 3339 format
     * @param {string} [createdBy] Only show items which were created by the the given user
     * @param {string} [assignedBy] Only show items for which the given user is assigned
     * @param {string} [mentionedBy] Only show items in which the given user was mentioned
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueListIssues(owner: string, repo: string, state?: IssueListIssuesStateEnum, labels?: string, q?: string, type?: IssueListIssuesTypeEnum, milestones?: string, since?: string, before?: string, createdBy?: string, assignedBy?: string, mentionedBy?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Issue>>;

    /**
     * 
     * @summary Get all of a repository\'s labels
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueListLabels(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Label>>;

    /**
     * 
     * @summary Add a reaction to a comment of an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment to edit
     * @param {EditReactionOption} [content] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issuePostCommentReaction(owner: string, repo: string, id: number, content?: EditReactionOption, options?: AxiosRequestConfig): AxiosPromise<Reaction>;

    /**
     * 
     * @summary Add a reaction to an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {EditReactionOption} [content] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issuePostIssueReaction(owner: string, repo: string, index: number, content?: EditReactionOption, options?: AxiosRequestConfig): AxiosPromise<Reaction>;

    /**
     * 
     * @summary Unblock the issue given in the body by the issue in path
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {IssueMeta} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueRemoveIssueBlocking(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig): AxiosPromise<Issue>;

    /**
     * 
     * @summary Remove an issue dependency
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {IssueMeta} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueRemoveIssueDependencies(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig): AxiosPromise<Issue>;

    /**
     * 
     * @summary Remove a label from an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} id id of the label to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueRemoveLabel(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Replace an issue\'s labels
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {IssueLabelsOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueReplaceLabels(owner: string, repo: string, index: number, body?: IssueLabelsOption, options?: AxiosRequestConfig): AxiosPromise<Array<Label>>;

    /**
     * 
     * @summary Reset a tracked time of an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to add tracked time to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueResetTime(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Search for issues across the repositories that the user has access to
     * @param {string} [state] whether issue is open or closed
     * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
     * @param {string} [milestones] comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded
     * @param {string} [q] search string
     * @param {number} [priorityRepoId] repository to prioritize in the results
     * @param {string} [type] filter by type (issues / pulls) if set
     * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
     * @param {boolean} [assigned] filter (issues / pulls) assigned to you, default is false
     * @param {boolean} [created] filter (issues / pulls) created by you, default is false
     * @param {boolean} [mentioned] filter (issues / pulls) mentioning you, default is false
     * @param {boolean} [reviewRequested] filter pulls requesting your review, default is false
     * @param {boolean} [reviewed] filter pulls reviewed by you, default is false
     * @param {string} [owner] filter by owner
     * @param {string} [team] filter by team (requires organization owner parameter to be provided)
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueSearchIssues(state?: string, labels?: string, milestones?: string, q?: string, priorityRepoId?: number, type?: string, since?: string, before?: string, assigned?: boolean, created?: boolean, mentioned?: boolean, reviewRequested?: boolean, reviewed?: boolean, owner?: string, team?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Issue>>;

    /**
     * 
     * @summary Start stopwatch on an issue.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to create the stopwatch on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueStartStopWatch(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Stop an issue\'s existing stopwatch.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to stop the stopwatch on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueStopStopWatch(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get users who subscribed on an issue.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueSubscriptions(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary List an issue\'s tracked times
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {string} [user] optional filter by user (available for issue managers)
     * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueTrackedTimes(owner: string, repo: string, index: number, user?: string, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<TrackedTime>>;

    /**
     * 
     * @summary Moves the Pin to the given Position
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of issue
     * @param {number} position the new position
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    moveIssuePin(owner: string, repo: string, index: number, position: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Pin an Issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of issue to pin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    pinIssue(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Unpin an Issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of issue to unpin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    unpinIssue(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * IssueApi - object-oriented interface
 * @export
 * @class IssueApi
 * @extends {BaseAPI}
 */
export class IssueApi extends BaseAPI implements IssueApiInterface {
    /**
     * 
     * @summary Add a label to an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {IssueLabelsOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueAddLabel(owner: string, repo: string, index: number, body?: IssueLabelsOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueAddLabel(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Subscribe user to issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {string} user user to subscribe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueAddSubscription(owner: string, repo: string, index: number, user: string, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueAddSubscription(owner, repo, index, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add tracked time to a issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {AddTimeOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueAddTime(owner: string, repo: string, index: number, body?: AddTimeOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueAddTime(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if user is subscribed to an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCheckSubscription(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCheckSubscription(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all labels from an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueClearLabels(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueClearLabels(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a comment to an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {CreateIssueCommentOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCreateComment(owner: string, repo: string, index: number, body?: CreateIssueCommentOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCreateComment(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an issue. If using deadline only the date will be taken into account, and time of day ignored.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateIssueOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCreateIssue(owner: string, repo: string, body?: CreateIssueOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCreateIssue(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an issue attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {File} attachment attachment to upload
     * @param {string} [name] name of the attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCreateIssueAttachment(owner: string, repo: string, index: number, attachment: File, name?: string, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCreateIssueAttachment(owner, repo, index, attachment, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Block the issue given in the body by the issue in path
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {IssueMeta} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCreateIssueBlocking(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCreateIssueBlocking(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a comment attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {File} attachment attachment to upload
     * @param {string} [name] name of the attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCreateIssueCommentAttachment(owner: string, repo: string, id: number, attachment: File, name?: string, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCreateIssueCommentAttachment(owner, repo, id, attachment, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Make the issue in the url depend on the issue in the form.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {IssueMeta} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCreateIssueDependencies(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCreateIssueDependencies(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a label
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateLabelOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCreateLabel(owner: string, repo: string, body?: CreateLabelOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCreateLabel(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a milestone
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateMilestoneOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCreateMilestone(owner: string, repo: string, body?: CreateMilestoneOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCreateMilestone(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of issue to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDelete(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDelete(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a comment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of comment to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteComment(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteComment(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a comment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index this parameter is ignored
     * @param {number} id id of comment to delete
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteCommentDeprecated(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteCommentDeprecated(owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a reaction from a comment of an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment to edit
     * @param {EditReactionOption} [content] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteCommentReaction(owner: string, repo: string, id: number, content?: EditReactionOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteCommentReaction(owner, repo, id, content, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an issue attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} attachmentId id of the attachment to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteIssueAttachment(owner, repo, index, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a comment attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {number} attachmentId id of the attachment to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteIssueCommentAttachment(owner, repo, id, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a reaction from an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {EditReactionOption} [content] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteIssueReaction(owner: string, repo: string, index: number, content?: EditReactionOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteIssueReaction(owner, repo, index, content, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a label
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the label to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteLabel(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteLabel(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a milestone
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id the milestone to delete, identified by ID and if not available by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteMilestone(owner: string, repo: string, id: string, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteMilestone(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an issue\'s existing stopwatch.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to stop the stopwatch on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteStopWatch(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteStopWatch(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unsubscribe user from issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {string} user user witch unsubscribe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteSubscription(owner: string, repo: string, index: number, user: string, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteSubscription(owner, repo, index, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete specific tracked time
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} id id of time to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteTime(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteTime(owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a comment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment to edit
     * @param {EditIssueCommentOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueEditComment(owner: string, repo: string, id: number, body?: EditIssueCommentOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueEditComment(owner, repo, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a comment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index this parameter is ignored
     * @param {number} id id of the comment to edit
     * @param {EditIssueCommentOption} [body] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueEditCommentDeprecated(owner: string, repo: string, index: number, id: number, body?: EditIssueCommentOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueEditCommentDeprecated(owner, repo, index, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit an issue. If using deadline only the date will be taken into account, and time of day ignored.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to edit
     * @param {EditIssueOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueEditIssue(owner: string, repo: string, index: number, body?: EditIssueOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueEditIssue(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit an issue attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} attachmentId id of the attachment to edit
     * @param {EditAttachmentOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueEditIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, body?: EditAttachmentOptions, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueEditIssueAttachment(owner, repo, index, attachmentId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a comment attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {number} attachmentId id of the attachment to edit
     * @param {EditAttachmentOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueEditIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueEditIssueCommentAttachment(owner, repo, id, attachmentId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to create or update a deadline on
     * @param {EditDeadlineOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueEditIssueDeadline(owner: string, repo: string, index: number, body?: EditDeadlineOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueEditIssueDeadline(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a label
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the label to edit
     * @param {EditLabelOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueEditLabel(owner: string, repo: string, id: number, body?: EditLabelOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueEditLabel(owner, repo, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a milestone
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id the milestone to edit, identified by ID and if not available by name
     * @param {EditMilestoneOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueEditMilestone(owner: string, repo: string, id: string, body?: EditMilestoneOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueEditMilestone(owner, repo, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a comment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetComment(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetComment(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of reactions from a comment of an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment to edit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetCommentReactions(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetCommentReactions(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all comments on an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {string} [since] if provided, only comments updated since the specified time are returned.
     * @param {string} [before] if provided, only comments updated before the provided time are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetComments(owner: string, repo: string, index: number, since?: string, before?: string, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetComments(owner, repo, index, since, before, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all comments and events on an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {string} [since] if provided, only comments updated since the specified time are returned.
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {string} [before] if provided, only comments updated before the provided time are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetCommentsAndTimeline(owner: string, repo: string, index: number, since?: string, page?: number, limit?: number, before?: string, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetCommentsAndTimeline(owner, repo, index, since, page, limit, before, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetIssue(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetIssue(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an issue attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} attachmentId id of the attachment to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetIssueAttachment(owner, repo, index, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a comment attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {number} attachmentId id of the attachment to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetIssueCommentAttachment(owner, repo, id, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list reactions of an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetIssueReactions(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetIssueReactions(owner, repo, index, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single label
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the label to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetLabel(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetLabel(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an issue\'s labels
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetLabels(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetLabels(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a milestone
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id the milestone to get, identified by ID and if not available by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetMilestone(owner: string, repo: string, id: string, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetMilestone(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all of a repository\'s opened milestones
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [state] Milestone state, Recognized values are open, closed and all. Defaults to \&quot;open\&quot;
     * @param {string} [name] filter by milestone name
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetMilestonesList(owner: string, repo: string, state?: string, name?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetMilestonesList(owner, repo, state, name, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all comments in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [since] if provided, only comments updated since the provided time are returned.
     * @param {string} [before] if provided, only comments updated before the provided time are returned.
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetRepoComments(owner: string, repo: string, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetRepoComments(owner, repo, since, before, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List issues that are blocked by this issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueListBlocks(owner: string, repo: string, index: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueListBlocks(owner, repo, index, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List issue\'s attachments
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueListIssueAttachments(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueListIssueAttachments(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List comment\'s attachments
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueListIssueCommentAttachments(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueListIssueCommentAttachments(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List an issue\'s dependencies, i.e all issues that block this issue.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueListIssueDependencies(owner: string, repo: string, index: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueListIssueDependencies(owner, repo, index, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s issues
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {IssueListIssuesStateEnum} [state] whether issue is open or closed
     * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
     * @param {string} [q] search string
     * @param {IssueListIssuesTypeEnum} [type] filter by type (issues / pulls) if set
     * @param {string} [milestones] comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded
     * @param {string} [since] Only show items updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show items updated before the given time. This is a timestamp in RFC 3339 format
     * @param {string} [createdBy] Only show items which were created by the the given user
     * @param {string} [assignedBy] Only show items for which the given user is assigned
     * @param {string} [mentionedBy] Only show items in which the given user was mentioned
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueListIssues(owner: string, repo: string, state?: IssueListIssuesStateEnum, labels?: string, q?: string, type?: IssueListIssuesTypeEnum, milestones?: string, since?: string, before?: string, createdBy?: string, assignedBy?: string, mentionedBy?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueListIssues(owner, repo, state, labels, q, type, milestones, since, before, createdBy, assignedBy, mentionedBy, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all of a repository\'s labels
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueListLabels(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueListLabels(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a reaction to a comment of an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment to edit
     * @param {EditReactionOption} [content] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issuePostCommentReaction(owner: string, repo: string, id: number, content?: EditReactionOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issuePostCommentReaction(owner, repo, id, content, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a reaction to an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {EditReactionOption} [content] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issuePostIssueReaction(owner: string, repo: string, index: number, content?: EditReactionOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issuePostIssueReaction(owner, repo, index, content, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unblock the issue given in the body by the issue in path
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {IssueMeta} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueRemoveIssueBlocking(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueRemoveIssueBlocking(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an issue dependency
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {IssueMeta} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueRemoveIssueDependencies(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueRemoveIssueDependencies(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a label from an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} id id of the label to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueRemoveLabel(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueRemoveLabel(owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Replace an issue\'s labels
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {IssueLabelsOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueReplaceLabels(owner: string, repo: string, index: number, body?: IssueLabelsOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueReplaceLabels(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset a tracked time of an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to add tracked time to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueResetTime(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueResetTime(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for issues across the repositories that the user has access to
     * @param {string} [state] whether issue is open or closed
     * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
     * @param {string} [milestones] comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded
     * @param {string} [q] search string
     * @param {number} [priorityRepoId] repository to prioritize in the results
     * @param {string} [type] filter by type (issues / pulls) if set
     * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
     * @param {boolean} [assigned] filter (issues / pulls) assigned to you, default is false
     * @param {boolean} [created] filter (issues / pulls) created by you, default is false
     * @param {boolean} [mentioned] filter (issues / pulls) mentioning you, default is false
     * @param {boolean} [reviewRequested] filter pulls requesting your review, default is false
     * @param {boolean} [reviewed] filter pulls reviewed by you, default is false
     * @param {string} [owner] filter by owner
     * @param {string} [team] filter by team (requires organization owner parameter to be provided)
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueSearchIssues(state?: string, labels?: string, milestones?: string, q?: string, priorityRepoId?: number, type?: string, since?: string, before?: string, assigned?: boolean, created?: boolean, mentioned?: boolean, reviewRequested?: boolean, reviewed?: boolean, owner?: string, team?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueSearchIssues(state, labels, milestones, q, priorityRepoId, type, since, before, assigned, created, mentioned, reviewRequested, reviewed, owner, team, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start stopwatch on an issue.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to create the stopwatch on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueStartStopWatch(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueStartStopWatch(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop an issue\'s existing stopwatch.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to stop the stopwatch on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueStopStopWatch(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueStopStopWatch(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get users who subscribed on an issue.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueSubscriptions(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueSubscriptions(owner, repo, index, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List an issue\'s tracked times
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {string} [user] optional filter by user (available for issue managers)
     * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueTrackedTimes(owner: string, repo: string, index: number, user?: string, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueTrackedTimes(owner, repo, index, user, since, before, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Moves the Pin to the given Position
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of issue
     * @param {number} position the new position
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public moveIssuePin(owner: string, repo: string, index: number, position: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).moveIssuePin(owner, repo, index, position, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pin an Issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of issue to pin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public pinIssue(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).pinIssue(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unpin an Issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of issue to unpin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public unpinIssue(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).unpinIssue(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const IssueListIssuesStateEnum = {
    closed: 'closed',
    open: 'open',
    all: 'all'
} as const;
export type IssueListIssuesStateEnum = typeof IssueListIssuesStateEnum[keyof typeof IssueListIssuesStateEnum];
/**
 * @export
 */
export const IssueListIssuesTypeEnum = {
    issues: 'issues',
    pulls: 'pulls'
} as const;
export type IssueListIssuesTypeEnum = typeof IssueListIssuesTypeEnum[keyof typeof IssueListIssuesTypeEnum];


/**
 * MiscellaneousApi - axios parameter creator
 * @export
 */
export const MiscellaneousApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns information about a gitignore template
         * @param {string} name name of the template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitignoreTemplateInfo: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getGitignoreTemplateInfo', 'name', name)
            const localVarPath = `/gitignore/templates/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all labels in a template
         * @param {string} name name of the template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabelTemplateInfo: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getLabelTemplateInfo', 'name', name)
            const localVarPath = `/label/templates/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns information about a license template
         * @param {string} name name of the license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseTemplateInfo: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getLicenseTemplateInfo', 'name', name)
            const localVarPath = `/licenses/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the nodeinfo of the Gitea application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/nodeinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get default signing-key.gpg
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSigningKey: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/signing-key.gpg`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the version of the Gitea application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of all gitignore templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGitignoresTemplates: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gitignore/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of all label templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLabelTemplates: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/label/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of all license templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLicenseTemplates: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/licenses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Render a markdown document as HTML
         * @param {MarkdownOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderMarkdown: async (body?: MarkdownOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markdown`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Render raw markdown as HTML
         * @param {string} body Request body to render
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderMarkdownRaw: async (body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('renderMarkdownRaw', 'body', body)
            const localVarPath = `/markdown/raw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Render a markup document as HTML
         * @param {MarkupOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderMarkup: async (body?: MarkupOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiscellaneousApi - functional programming interface
 * @export
 */
export const MiscellaneousApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MiscellaneousApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns information about a gitignore template
         * @param {string} name name of the template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGitignoreTemplateInfo(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitignoreTemplateInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGitignoreTemplateInfo(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all labels in a template
         * @param {string} name name of the template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLabelTemplateInfo(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LabelTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLabelTemplateInfo(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns information about a license template
         * @param {string} name name of the license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicenseTemplateInfo(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LicenseTemplateInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicenseTemplateInfo(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the nodeinfo of the Gitea application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodeInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodeInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodeInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get default signing-key.gpg
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSigningKey(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSigningKey(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the version of the Gitea application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of all gitignore templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGitignoresTemplates(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGitignoresTemplates(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of all label templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLabelTemplates(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLabelTemplates(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of all license templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLicenseTemplates(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LicensesTemplateListEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLicenseTemplates(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Render a markdown document as HTML
         * @param {MarkdownOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renderMarkdown(body?: MarkdownOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renderMarkdown(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Render raw markdown as HTML
         * @param {string} body Request body to render
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renderMarkdownRaw(body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renderMarkdownRaw(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Render a markup document as HTML
         * @param {MarkupOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renderMarkup(body?: MarkupOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renderMarkup(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MiscellaneousApi - factory interface
 * @export
 */
export const MiscellaneousApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MiscellaneousApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns information about a gitignore template
         * @param {string} name name of the template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitignoreTemplateInfo(name: string, options?: any): AxiosPromise<GitignoreTemplateInfo> {
            return localVarFp.getGitignoreTemplateInfo(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all labels in a template
         * @param {string} name name of the template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabelTemplateInfo(name: string, options?: any): AxiosPromise<Array<LabelTemplate>> {
            return localVarFp.getLabelTemplateInfo(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns information about a license template
         * @param {string} name name of the license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseTemplateInfo(name: string, options?: any): AxiosPromise<LicenseTemplateInfo> {
            return localVarFp.getLicenseTemplateInfo(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the nodeinfo of the Gitea application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeInfo(options?: any): AxiosPromise<NodeInfo> {
            return localVarFp.getNodeInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get default signing-key.gpg
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSigningKey(options?: any): AxiosPromise<string> {
            return localVarFp.getSigningKey(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the version of the Gitea application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: any): AxiosPromise<ServerVersion> {
            return localVarFp.getVersion(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of all gitignore templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGitignoresTemplates(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.listGitignoresTemplates(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of all label templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLabelTemplates(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.listLabelTemplates(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of all license templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLicenseTemplates(options?: any): AxiosPromise<Array<LicensesTemplateListEntry>> {
            return localVarFp.listLicenseTemplates(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Render a markdown document as HTML
         * @param {MarkdownOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderMarkdown(body?: MarkdownOption, options?: any): AxiosPromise<string> {
            return localVarFp.renderMarkdown(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Render raw markdown as HTML
         * @param {string} body Request body to render
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderMarkdownRaw(body: string, options?: any): AxiosPromise<string> {
            return localVarFp.renderMarkdownRaw(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Render a markup document as HTML
         * @param {MarkupOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderMarkup(body?: MarkupOption, options?: any): AxiosPromise<string> {
            return localVarFp.renderMarkup(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MiscellaneousApi - interface
 * @export
 * @interface MiscellaneousApi
 */
export interface MiscellaneousApiInterface {
    /**
     * 
     * @summary Returns information about a gitignore template
     * @param {string} name name of the template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApiInterface
     */
    getGitignoreTemplateInfo(name: string, options?: AxiosRequestConfig): AxiosPromise<GitignoreTemplateInfo>;

    /**
     * 
     * @summary Returns all labels in a template
     * @param {string} name name of the template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApiInterface
     */
    getLabelTemplateInfo(name: string, options?: AxiosRequestConfig): AxiosPromise<Array<LabelTemplate>>;

    /**
     * 
     * @summary Returns information about a license template
     * @param {string} name name of the license
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApiInterface
     */
    getLicenseTemplateInfo(name: string, options?: AxiosRequestConfig): AxiosPromise<LicenseTemplateInfo>;

    /**
     * 
     * @summary Returns the nodeinfo of the Gitea application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApiInterface
     */
    getNodeInfo(options?: AxiosRequestConfig): AxiosPromise<NodeInfo>;

    /**
     * 
     * @summary Get default signing-key.gpg
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApiInterface
     */
    getSigningKey(options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Returns the version of the Gitea application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApiInterface
     */
    getVersion(options?: AxiosRequestConfig): AxiosPromise<ServerVersion>;

    /**
     * 
     * @summary Returns a list of all gitignore templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApiInterface
     */
    listGitignoresTemplates(options?: AxiosRequestConfig): AxiosPromise<Array<string>>;

    /**
     * 
     * @summary Returns a list of all label templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApiInterface
     */
    listLabelTemplates(options?: AxiosRequestConfig): AxiosPromise<Array<string>>;

    /**
     * 
     * @summary Returns a list of all license templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApiInterface
     */
    listLicenseTemplates(options?: AxiosRequestConfig): AxiosPromise<Array<LicensesTemplateListEntry>>;

    /**
     * 
     * @summary Render a markdown document as HTML
     * @param {MarkdownOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApiInterface
     */
    renderMarkdown(body?: MarkdownOption, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Render raw markdown as HTML
     * @param {string} body Request body to render
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApiInterface
     */
    renderMarkdownRaw(body: string, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Render a markup document as HTML
     * @param {MarkupOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApiInterface
     */
    renderMarkup(body?: MarkupOption, options?: AxiosRequestConfig): AxiosPromise<string>;

}

/**
 * MiscellaneousApi - object-oriented interface
 * @export
 * @class MiscellaneousApi
 * @extends {BaseAPI}
 */
export class MiscellaneousApi extends BaseAPI implements MiscellaneousApiInterface {
    /**
     * 
     * @summary Returns information about a gitignore template
     * @param {string} name name of the template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public getGitignoreTemplateInfo(name: string, options?: AxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).getGitignoreTemplateInfo(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all labels in a template
     * @param {string} name name of the template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public getLabelTemplateInfo(name: string, options?: AxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).getLabelTemplateInfo(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns information about a license template
     * @param {string} name name of the license
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public getLicenseTemplateInfo(name: string, options?: AxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).getLicenseTemplateInfo(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the nodeinfo of the Gitea application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public getNodeInfo(options?: AxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).getNodeInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get default signing-key.gpg
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public getSigningKey(options?: AxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).getSigningKey(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the version of the Gitea application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public getVersion(options?: AxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).getVersion(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of all gitignore templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public listGitignoresTemplates(options?: AxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).listGitignoresTemplates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of all label templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public listLabelTemplates(options?: AxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).listLabelTemplates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of all license templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public listLicenseTemplates(options?: AxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).listLicenseTemplates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Render a markdown document as HTML
     * @param {MarkdownOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public renderMarkdown(body?: MarkdownOption, options?: AxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).renderMarkdown(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Render raw markdown as HTML
     * @param {string} body Request body to render
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public renderMarkdownRaw(body: string, options?: AxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).renderMarkdownRaw(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Render a markup document as HTML
     * @param {MarkupOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public renderMarkup(body?: MarkupOption, options?: AxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).renderMarkup(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationApi - axios parameter creator
 * @export
 */
export const NotificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List users\'s notification threads
         * @param {boolean} [all] If true, show notifications marked as read. Default value is false
         * @param {Array<string>} [statusTypes] Show notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread &amp; pinned.
         * @param {Array<NotifyGetListSubjectTypeEnum>} [subjectType] filter notifications by subject type
         * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyGetList: async (all?: boolean, statusTypes?: Array<string>, subjectType?: Array<NotifyGetListSubjectTypeEnum>, since?: string, before?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (all !== undefined) {
                localVarQueryParameter['all'] = all;
            }

            if (statusTypes) {
                localVarQueryParameter['status-types'] = statusTypes;
            }

            if (subjectType) {
                localVarQueryParameter['subject-type'] = subjectType;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List users\'s notification threads on a specific repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {boolean} [all] If true, show notifications marked as read. Default value is false
         * @param {Array<string>} [statusTypes] Show notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread &amp; pinned
         * @param {Array<NotifyGetRepoListSubjectTypeEnum>} [subjectType] filter notifications by subject type
         * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyGetRepoList: async (owner: string, repo: string, all?: boolean, statusTypes?: Array<string>, subjectType?: Array<NotifyGetRepoListSubjectTypeEnum>, since?: string, before?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('notifyGetRepoList', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('notifyGetRepoList', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/notifications`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (all !== undefined) {
                localVarQueryParameter['all'] = all;
            }

            if (statusTypes) {
                localVarQueryParameter['status-types'] = statusTypes;
            }

            if (subjectType) {
                localVarQueryParameter['subject-type'] = subjectType;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get notification thread by ID
         * @param {string} id id of notification thread
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyGetThread: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('notifyGetThread', 'id', id)
            const localVarPath = `/notifications/threads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if unread notifications exist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyNewAvailable: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notifications/new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark notification threads as read, pinned or unread
         * @param {string} [lastReadAt] Describes the last point that notifications were checked. Anything updated since this time will not be updated.
         * @param {string} [all] If true, mark all notifications on this repo. Default value is false
         * @param {Array<string>} [statusTypes] Mark notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread.
         * @param {string} [toStatus] Status to mark notifications as, Defaults to read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyReadList: async (lastReadAt?: string, all?: string, statusTypes?: Array<string>, toStatus?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (lastReadAt !== undefined) {
                localVarQueryParameter['last_read_at'] = (lastReadAt as any instanceof Date) ?
                    (lastReadAt as any).toISOString() :
                    lastReadAt;
            }

            if (all !== undefined) {
                localVarQueryParameter['all'] = all;
            }

            if (statusTypes) {
                localVarQueryParameter['status-types'] = statusTypes;
            }

            if (toStatus !== undefined) {
                localVarQueryParameter['to-status'] = toStatus;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark notification threads as read, pinned or unread on a specific repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [all] If true, mark all notifications on this repo. Default value is false
         * @param {Array<string>} [statusTypes] Mark notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread.
         * @param {string} [toStatus] Status to mark notifications as. Defaults to read.
         * @param {string} [lastReadAt] Describes the last point that notifications were checked. Anything updated since this time will not be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyReadRepoList: async (owner: string, repo: string, all?: string, statusTypes?: Array<string>, toStatus?: string, lastReadAt?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('notifyReadRepoList', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('notifyReadRepoList', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/notifications`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (all !== undefined) {
                localVarQueryParameter['all'] = all;
            }

            if (statusTypes) {
                localVarQueryParameter['status-types'] = statusTypes;
            }

            if (toStatus !== undefined) {
                localVarQueryParameter['to-status'] = toStatus;
            }

            if (lastReadAt !== undefined) {
                localVarQueryParameter['last_read_at'] = (lastReadAt as any instanceof Date) ?
                    (lastReadAt as any).toISOString() :
                    lastReadAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark notification thread as read by ID
         * @param {string} id id of notification thread
         * @param {string} [toStatus] Status to mark notifications as
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyReadThread: async (id: string, toStatus?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('notifyReadThread', 'id', id)
            const localVarPath = `/notifications/threads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (toStatus !== undefined) {
                localVarQueryParameter['to-status'] = toStatus;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationApi - functional programming interface
 * @export
 */
export const NotificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List users\'s notification threads
         * @param {boolean} [all] If true, show notifications marked as read. Default value is false
         * @param {Array<string>} [statusTypes] Show notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread &amp; pinned.
         * @param {Array<NotifyGetListSubjectTypeEnum>} [subjectType] filter notifications by subject type
         * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyGetList(all?: boolean, statusTypes?: Array<string>, subjectType?: Array<NotifyGetListSubjectTypeEnum>, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationThread>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyGetList(all, statusTypes, subjectType, since, before, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List users\'s notification threads on a specific repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {boolean} [all] If true, show notifications marked as read. Default value is false
         * @param {Array<string>} [statusTypes] Show notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread &amp; pinned
         * @param {Array<NotifyGetRepoListSubjectTypeEnum>} [subjectType] filter notifications by subject type
         * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyGetRepoList(owner: string, repo: string, all?: boolean, statusTypes?: Array<string>, subjectType?: Array<NotifyGetRepoListSubjectTypeEnum>, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationThread>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyGetRepoList(owner, repo, all, statusTypes, subjectType, since, before, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get notification thread by ID
         * @param {string} id id of notification thread
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyGetThread(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationThread>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyGetThread(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if unread notifications exist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyNewAvailable(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyNewAvailable(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Mark notification threads as read, pinned or unread
         * @param {string} [lastReadAt] Describes the last point that notifications were checked. Anything updated since this time will not be updated.
         * @param {string} [all] If true, mark all notifications on this repo. Default value is false
         * @param {Array<string>} [statusTypes] Mark notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread.
         * @param {string} [toStatus] Status to mark notifications as, Defaults to read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyReadList(lastReadAt?: string, all?: string, statusTypes?: Array<string>, toStatus?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationThread>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyReadList(lastReadAt, all, statusTypes, toStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Mark notification threads as read, pinned or unread on a specific repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [all] If true, mark all notifications on this repo. Default value is false
         * @param {Array<string>} [statusTypes] Mark notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread.
         * @param {string} [toStatus] Status to mark notifications as. Defaults to read.
         * @param {string} [lastReadAt] Describes the last point that notifications were checked. Anything updated since this time will not be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyReadRepoList(owner: string, repo: string, all?: string, statusTypes?: Array<string>, toStatus?: string, lastReadAt?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationThread>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyReadRepoList(owner, repo, all, statusTypes, toStatus, lastReadAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Mark notification thread as read by ID
         * @param {string} id id of notification thread
         * @param {string} [toStatus] Status to mark notifications as
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyReadThread(id: string, toStatus?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationThread>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyReadThread(id, toStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationApi - factory interface
 * @export
 */
export const NotificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationApiFp(configuration)
    return {
        /**
         * 
         * @summary List users\'s notification threads
         * @param {boolean} [all] If true, show notifications marked as read. Default value is false
         * @param {Array<string>} [statusTypes] Show notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread &amp; pinned.
         * @param {Array<NotifyGetListSubjectTypeEnum>} [subjectType] filter notifications by subject type
         * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyGetList(all?: boolean, statusTypes?: Array<string>, subjectType?: Array<NotifyGetListSubjectTypeEnum>, since?: string, before?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<NotificationThread>> {
            return localVarFp.notifyGetList(all, statusTypes, subjectType, since, before, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List users\'s notification threads on a specific repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {boolean} [all] If true, show notifications marked as read. Default value is false
         * @param {Array<string>} [statusTypes] Show notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread &amp; pinned
         * @param {Array<NotifyGetRepoListSubjectTypeEnum>} [subjectType] filter notifications by subject type
         * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyGetRepoList(owner: string, repo: string, all?: boolean, statusTypes?: Array<string>, subjectType?: Array<NotifyGetRepoListSubjectTypeEnum>, since?: string, before?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<NotificationThread>> {
            return localVarFp.notifyGetRepoList(owner, repo, all, statusTypes, subjectType, since, before, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get notification thread by ID
         * @param {string} id id of notification thread
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyGetThread(id: string, options?: any): AxiosPromise<NotificationThread> {
            return localVarFp.notifyGetThread(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if unread notifications exist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyNewAvailable(options?: any): AxiosPromise<NotificationCount> {
            return localVarFp.notifyNewAvailable(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark notification threads as read, pinned or unread
         * @param {string} [lastReadAt] Describes the last point that notifications were checked. Anything updated since this time will not be updated.
         * @param {string} [all] If true, mark all notifications on this repo. Default value is false
         * @param {Array<string>} [statusTypes] Mark notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread.
         * @param {string} [toStatus] Status to mark notifications as, Defaults to read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyReadList(lastReadAt?: string, all?: string, statusTypes?: Array<string>, toStatus?: string, options?: any): AxiosPromise<Array<NotificationThread>> {
            return localVarFp.notifyReadList(lastReadAt, all, statusTypes, toStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark notification threads as read, pinned or unread on a specific repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [all] If true, mark all notifications on this repo. Default value is false
         * @param {Array<string>} [statusTypes] Mark notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread.
         * @param {string} [toStatus] Status to mark notifications as. Defaults to read.
         * @param {string} [lastReadAt] Describes the last point that notifications were checked. Anything updated since this time will not be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyReadRepoList(owner: string, repo: string, all?: string, statusTypes?: Array<string>, toStatus?: string, lastReadAt?: string, options?: any): AxiosPromise<Array<NotificationThread>> {
            return localVarFp.notifyReadRepoList(owner, repo, all, statusTypes, toStatus, lastReadAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark notification thread as read by ID
         * @param {string} id id of notification thread
         * @param {string} [toStatus] Status to mark notifications as
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyReadThread(id: string, toStatus?: string, options?: any): AxiosPromise<NotificationThread> {
            return localVarFp.notifyReadThread(id, toStatus, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationApi - interface
 * @export
 * @interface NotificationApi
 */
export interface NotificationApiInterface {
    /**
     * 
     * @summary List users\'s notification threads
     * @param {boolean} [all] If true, show notifications marked as read. Default value is false
     * @param {Array<string>} [statusTypes] Show notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread &amp; pinned.
     * @param {Array<NotifyGetListSubjectTypeEnum>} [subjectType] filter notifications by subject type
     * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApiInterface
     */
    notifyGetList(all?: boolean, statusTypes?: Array<string>, subjectType?: Array<NotifyGetListSubjectTypeEnum>, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<NotificationThread>>;

    /**
     * 
     * @summary List users\'s notification threads on a specific repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {boolean} [all] If true, show notifications marked as read. Default value is false
     * @param {Array<string>} [statusTypes] Show notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread &amp; pinned
     * @param {Array<NotifyGetRepoListSubjectTypeEnum>} [subjectType] filter notifications by subject type
     * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApiInterface
     */
    notifyGetRepoList(owner: string, repo: string, all?: boolean, statusTypes?: Array<string>, subjectType?: Array<NotifyGetRepoListSubjectTypeEnum>, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<NotificationThread>>;

    /**
     * 
     * @summary Get notification thread by ID
     * @param {string} id id of notification thread
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApiInterface
     */
    notifyGetThread(id: string, options?: AxiosRequestConfig): AxiosPromise<NotificationThread>;

    /**
     * 
     * @summary Check if unread notifications exist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApiInterface
     */
    notifyNewAvailable(options?: AxiosRequestConfig): AxiosPromise<NotificationCount>;

    /**
     * 
     * @summary Mark notification threads as read, pinned or unread
     * @param {string} [lastReadAt] Describes the last point that notifications were checked. Anything updated since this time will not be updated.
     * @param {string} [all] If true, mark all notifications on this repo. Default value is false
     * @param {Array<string>} [statusTypes] Mark notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread.
     * @param {string} [toStatus] Status to mark notifications as, Defaults to read.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApiInterface
     */
    notifyReadList(lastReadAt?: string, all?: string, statusTypes?: Array<string>, toStatus?: string, options?: AxiosRequestConfig): AxiosPromise<Array<NotificationThread>>;

    /**
     * 
     * @summary Mark notification threads as read, pinned or unread on a specific repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [all] If true, mark all notifications on this repo. Default value is false
     * @param {Array<string>} [statusTypes] Mark notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread.
     * @param {string} [toStatus] Status to mark notifications as. Defaults to read.
     * @param {string} [lastReadAt] Describes the last point that notifications were checked. Anything updated since this time will not be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApiInterface
     */
    notifyReadRepoList(owner: string, repo: string, all?: string, statusTypes?: Array<string>, toStatus?: string, lastReadAt?: string, options?: AxiosRequestConfig): AxiosPromise<Array<NotificationThread>>;

    /**
     * 
     * @summary Mark notification thread as read by ID
     * @param {string} id id of notification thread
     * @param {string} [toStatus] Status to mark notifications as
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApiInterface
     */
    notifyReadThread(id: string, toStatus?: string, options?: AxiosRequestConfig): AxiosPromise<NotificationThread>;

}

/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
export class NotificationApi extends BaseAPI implements NotificationApiInterface {
    /**
     * 
     * @summary List users\'s notification threads
     * @param {boolean} [all] If true, show notifications marked as read. Default value is false
     * @param {Array<string>} [statusTypes] Show notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread &amp; pinned.
     * @param {Array<NotifyGetListSubjectTypeEnum>} [subjectType] filter notifications by subject type
     * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public notifyGetList(all?: boolean, statusTypes?: Array<string>, subjectType?: Array<NotifyGetListSubjectTypeEnum>, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).notifyGetList(all, statusTypes, subjectType, since, before, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List users\'s notification threads on a specific repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {boolean} [all] If true, show notifications marked as read. Default value is false
     * @param {Array<string>} [statusTypes] Show notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread &amp; pinned
     * @param {Array<NotifyGetRepoListSubjectTypeEnum>} [subjectType] filter notifications by subject type
     * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public notifyGetRepoList(owner: string, repo: string, all?: boolean, statusTypes?: Array<string>, subjectType?: Array<NotifyGetRepoListSubjectTypeEnum>, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).notifyGetRepoList(owner, repo, all, statusTypes, subjectType, since, before, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get notification thread by ID
     * @param {string} id id of notification thread
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public notifyGetThread(id: string, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).notifyGetThread(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if unread notifications exist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public notifyNewAvailable(options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).notifyNewAvailable(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark notification threads as read, pinned or unread
     * @param {string} [lastReadAt] Describes the last point that notifications were checked. Anything updated since this time will not be updated.
     * @param {string} [all] If true, mark all notifications on this repo. Default value is false
     * @param {Array<string>} [statusTypes] Mark notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread.
     * @param {string} [toStatus] Status to mark notifications as, Defaults to read.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public notifyReadList(lastReadAt?: string, all?: string, statusTypes?: Array<string>, toStatus?: string, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).notifyReadList(lastReadAt, all, statusTypes, toStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark notification threads as read, pinned or unread on a specific repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [all] If true, mark all notifications on this repo. Default value is false
     * @param {Array<string>} [statusTypes] Mark notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread.
     * @param {string} [toStatus] Status to mark notifications as. Defaults to read.
     * @param {string} [lastReadAt] Describes the last point that notifications were checked. Anything updated since this time will not be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public notifyReadRepoList(owner: string, repo: string, all?: string, statusTypes?: Array<string>, toStatus?: string, lastReadAt?: string, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).notifyReadRepoList(owner, repo, all, statusTypes, toStatus, lastReadAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark notification thread as read by ID
     * @param {string} id id of notification thread
     * @param {string} [toStatus] Status to mark notifications as
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public notifyReadThread(id: string, toStatus?: string, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).notifyReadThread(id, toStatus, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const NotifyGetListSubjectTypeEnum = {
    issue: 'issue',
    pull: 'pull',
    commit: 'commit',
    repository: 'repository'
} as const;
export type NotifyGetListSubjectTypeEnum = typeof NotifyGetListSubjectTypeEnum[keyof typeof NotifyGetListSubjectTypeEnum];
/**
 * @export
 */
export const NotifyGetRepoListSubjectTypeEnum = {
    issue: 'issue',
    pull: 'pull',
    commit: 'commit',
    repository: 'repository'
} as const;
export type NotifyGetRepoListSubjectTypeEnum = typeof NotifyGetRepoListSubjectTypeEnum[keyof typeof NotifyGetRepoListSubjectTypeEnum];


/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a repository in an organization
         * @param {string} org name of organization
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrgRepo: async (org: string, body?: CreateRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('createOrgRepo', 'org', org)
            const localVarPath = `/orgs/{org}/repos`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a repository in an organization
         * @param {string} org name of organization
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createOrgRepoDeprecated: async (org: string, body?: CreateRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('createOrgRepoDeprecated', 'org', org)
            const localVarPath = `/org/{org}/repos`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a secret in an organization
         * @param {string} org name of organization
         * @param {string} secretname name of the secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgSecret: async (org: string, secretname: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('deleteOrgSecret', 'org', org)
            // verify required parameter 'secretname' is not null or undefined
            assertParamExists('deleteOrgSecret', 'secretname', secretname)
            const localVarPath = `/orgs/{org}/actions/secrets/{secretname}`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"secretname"}}`, encodeURIComponent(String(secretname)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a team member
         * @param {number} id id of the team
         * @param {string} username username of the user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgAddTeamMember: async (id: number, username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orgAddTeamMember', 'id', id)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('orgAddTeamMember', 'username', username)
            const localVarPath = `/teams/{id}/members/{username}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a repository to a team
         * @param {number} id id of the team
         * @param {string} org organization that owns the repo to add
         * @param {string} repo name of the repo to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgAddTeamRepository: async (id: number, org: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orgAddTeamRepository', 'id', id)
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgAddTeamRepository', 'org', org)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('orgAddTeamRepository', 'repo', repo)
            const localVarPath = `/teams/{id}/repos/{org}/{repo}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Conceal a user\'s membership
         * @param {string} org name of the organization
         * @param {string} username username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgConcealMember: async (org: string, username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgConcealMember', 'org', org)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('orgConcealMember', 'username', username)
            const localVarPath = `/orgs/{org}/public_members/{username}`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an organization
         * @param {CreateOrgOption} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgCreate: async (organization: CreateOrgOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('orgCreate', 'organization', organization)
            const localVarPath = `/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a hook
         * @param {string} org name of the organization
         * @param {CreateHookOption} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgCreateHook: async (org: string, body: CreateHookOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgCreateHook', 'org', org)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgCreateHook', 'body', body)
            const localVarPath = `/orgs/{org}/hooks`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a label for an organization
         * @param {string} org name of the organization
         * @param {CreateLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgCreateLabel: async (org: string, body?: CreateLabelOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgCreateLabel', 'org', org)
            const localVarPath = `/orgs/{org}/labels`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a team
         * @param {string} org name of the organization
         * @param {CreateTeamOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgCreateTeam: async (org: string, body?: CreateTeamOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgCreateTeam', 'org', org)
            const localVarPath = `/orgs/{org}/teams`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an organization
         * @param {string} org organization that is to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgDelete: async (org: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgDelete', 'org', org)
            const localVarPath = `/orgs/{org}`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Avatar
         * @param {string} org name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgDeleteAvatar: async (org: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgDeleteAvatar', 'org', org)
            const localVarPath = `/orgs/{org}/avatar`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a hook
         * @param {string} org name of the organization
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgDeleteHook: async (org: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgDeleteHook', 'org', org)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orgDeleteHook', 'id', id)
            const localVarPath = `/orgs/{org}/hooks/{id}`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a label
         * @param {string} org name of the organization
         * @param {number} id id of the label to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgDeleteLabel: async (org: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgDeleteLabel', 'org', org)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orgDeleteLabel', 'id', id)
            const localVarPath = `/orgs/{org}/labels/{id}`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a member from an organization
         * @param {string} org name of the organization
         * @param {string} username username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgDeleteMember: async (org: string, username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgDeleteMember', 'org', org)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('orgDeleteMember', 'username', username)
            const localVarPath = `/orgs/{org}/members/{username}`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a team
         * @param {number} id id of the team to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgDeleteTeam: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orgDeleteTeam', 'id', id)
            const localVarPath = `/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit an organization
         * @param {string} org name of the organization to edit
         * @param {EditOrgOption} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgEdit: async (org: string, body: EditOrgOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgEdit', 'org', org)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgEdit', 'body', body)
            const localVarPath = `/orgs/{org}`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a hook
         * @param {string} org name of the organization
         * @param {number} id id of the hook to update
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgEditHook: async (org: string, id: number, body?: EditHookOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgEditHook', 'org', org)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orgEditHook', 'id', id)
            const localVarPath = `/orgs/{org}/hooks/{id}`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a label
         * @param {string} org name of the organization
         * @param {number} id id of the label to edit
         * @param {EditLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgEditLabel: async (org: string, id: number, body?: EditLabelOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgEditLabel', 'org', org)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orgEditLabel', 'id', id)
            const localVarPath = `/orgs/{org}/labels/{id}`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a team
         * @param {number} id id of the team to edit
         * @param {EditTeamOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgEditTeam: async (id: number, body?: EditTeamOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orgEditTeam', 'id', id)
            const localVarPath = `/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an organization
         * @param {string} org name of the organization to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgGet: async (org: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgGet', 'org', org)
            const localVarPath = `/orgs/{org}`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of organizations
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgGetAll: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a hook
         * @param {string} org name of the organization
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgGetHook: async (org: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgGetHook', 'org', org)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orgGetHook', 'id', id)
            const localVarPath = `/orgs/{org}/hooks/{id}`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single label
         * @param {string} org name of the organization
         * @param {number} id id of the label to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgGetLabel: async (org: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgGetLabel', 'org', org)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orgGetLabel', 'id', id)
            const localVarPath = `/orgs/{org}/labels/{id}`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a team
         * @param {number} id id of the team to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgGetTeam: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orgGetTeam', 'id', id)
            const localVarPath = `/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user permissions in organization
         * @param {string} username username of user
         * @param {string} org name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgGetUserPermissions: async (username: string, org: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('orgGetUserPermissions', 'username', username)
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgGetUserPermissions', 'org', org)
            const localVarPath = `/users/{username}/orgs/{org}/permissions`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)))
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if a user is a member of an organization
         * @param {string} org name of the organization
         * @param {string} username username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgIsMember: async (org: string, username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgIsMember', 'org', org)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('orgIsMember', 'username', username)
            const localVarPath = `/orgs/{org}/members/{username}`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if a user is a public member of an organization
         * @param {string} org name of the organization
         * @param {string} username username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgIsPublicMember: async (org: string, username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgIsPublicMember', 'org', org)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('orgIsPublicMember', 'username', username)
            const localVarPath = `/orgs/{org}/public_members/{username}`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List an organization\'s actions secrets
         * @param {string} org name of the organization
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListActionsSecrets: async (org: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgListActionsSecrets', 'org', org)
            const localVarPath = `/orgs/{org}/actions/secrets`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List an organization\'s activity feeds
         * @param {string} org name of the org
         * @param {string} [date] the date of the activities to be found
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListActivityFeeds: async (org: string, date?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgListActivityFeeds', 'org', org)
            const localVarPath = `/orgs/{org}/activities/feeds`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substring(0,10) :
                    date;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the current user\'s organizations
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListCurrentUserOrgs: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List an organization\'s webhooks
         * @param {string} org name of the organization
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListHooks: async (org: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgListHooks', 'org', org)
            const localVarPath = `/orgs/{org}/hooks`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List an organization\'s labels
         * @param {string} org name of the organization
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListLabels: async (org: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgListLabels', 'org', org)
            const localVarPath = `/orgs/{org}/labels`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List an organization\'s members
         * @param {string} org name of the organization
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListMembers: async (org: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgListMembers', 'org', org)
            const localVarPath = `/orgs/{org}/members`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List an organization\'s public members
         * @param {string} org name of the organization
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListPublicMembers: async (org: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgListPublicMembers', 'org', org)
            const localVarPath = `/orgs/{org}/public_members`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List an organization\'s repos
         * @param {string} org name of the organization
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListRepos: async (org: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgListRepos', 'org', org)
            const localVarPath = `/orgs/{org}/repos`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a team\'s activity feeds
         * @param {number} id id of the team
         * @param {string} [date] the date of the activities to be found
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListTeamActivityFeeds: async (id: number, date?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orgListTeamActivityFeeds', 'id', id)
            const localVarPath = `/teams/{id}/activities/feeds`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substring(0,10) :
                    date;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a particular member of team
         * @param {number} id id of the team
         * @param {string} username username of the member to list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListTeamMember: async (id: number, username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orgListTeamMember', 'id', id)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('orgListTeamMember', 'username', username)
            const localVarPath = `/teams/{id}/members/{username}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a team\'s members
         * @param {number} id id of the team
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListTeamMembers: async (id: number, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orgListTeamMembers', 'id', id)
            const localVarPath = `/teams/{id}/members`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a particular repo of team
         * @param {number} id id of the team
         * @param {string} org organization that owns the repo to list
         * @param {string} repo name of the repo to list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListTeamRepo: async (id: number, org: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orgListTeamRepo', 'id', id)
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgListTeamRepo', 'org', org)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('orgListTeamRepo', 'repo', repo)
            const localVarPath = `/teams/{id}/repos/{org}/{repo}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a team\'s repos
         * @param {number} id id of the team
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListTeamRepos: async (id: number, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orgListTeamRepos', 'id', id)
            const localVarPath = `/teams/{id}/repos`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List an organization\'s teams
         * @param {string} org name of the organization
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListTeams: async (org: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgListTeams', 'org', org)
            const localVarPath = `/orgs/{org}/teams`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a user\'s organizations
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListUserOrgs: async (username: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('orgListUserOrgs', 'username', username)
            const localVarPath = `/users/{username}/orgs`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Publicize a user\'s membership
         * @param {string} org name of the organization
         * @param {string} username username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgPublicizeMember: async (org: string, username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgPublicizeMember', 'org', org)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('orgPublicizeMember', 'username', username)
            const localVarPath = `/orgs/{org}/public_members/{username}`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a team member
         * @param {number} id id of the team
         * @param {string} username username of the user to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgRemoveTeamMember: async (id: number, username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orgRemoveTeamMember', 'id', id)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('orgRemoveTeamMember', 'username', username)
            const localVarPath = `/teams/{id}/members/{username}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This does not delete the repository, it only removes the repository from the team.
         * @summary Remove a repository from a team
         * @param {number} id id of the team
         * @param {string} org organization that owns the repo to remove
         * @param {string} repo name of the repo to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgRemoveTeamRepository: async (id: number, org: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orgRemoveTeamRepository', 'id', id)
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgRemoveTeamRepository', 'org', org)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('orgRemoveTeamRepository', 'repo', repo)
            const localVarPath = `/teams/{id}/repos/{org}/{repo}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Avatar
         * @param {string} org name of the organization
         * @param {UpdateUserAvatarOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgUpdateAvatar: async (org: string, body?: UpdateUserAvatarOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('orgUpdateAvatar', 'org', org)
            const localVarPath = `/orgs/{org}/avatar`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for teams within an organization
         * @param {string} org name of the organization
         * @param {string} [q] keywords to search
         * @param {boolean} [includeDesc] include search within team description (defaults to true)
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamSearch: async (org: string, q?: string, includeDesc?: boolean, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('teamSearch', 'org', org)
            const localVarPath = `/orgs/{org}/teams/search`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (includeDesc !== undefined) {
                localVarQueryParameter['include_desc'] = includeDesc;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create or Update a secret value in an organization
         * @param {string} org name of organization
         * @param {string} secretname name of the secret
         * @param {CreateOrUpdateSecretOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrgSecret: async (org: string, secretname: string, body?: CreateOrUpdateSecretOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('updateOrgSecret', 'org', org)
            // verify required parameter 'secretname' is not null or undefined
            assertParamExists('updateOrgSecret', 'secretname', secretname)
            const localVarPath = `/orgs/{org}/actions/secrets/{secretname}`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"secretname"}}`, encodeURIComponent(String(secretname)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a repository in an organization
         * @param {string} org name of organization
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrgRepo(org: string, body?: CreateRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrgRepo(org, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a repository in an organization
         * @param {string} org name of organization
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createOrgRepoDeprecated(org: string, body?: CreateRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrgRepoDeprecated(org, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a secret in an organization
         * @param {string} org name of organization
         * @param {string} secretname name of the secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrgSecret(org: string, secretname: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrgSecret(org, secretname, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a team member
         * @param {number} id id of the team
         * @param {string} username username of the user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgAddTeamMember(id: number, username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgAddTeamMember(id, username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a repository to a team
         * @param {number} id id of the team
         * @param {string} org organization that owns the repo to add
         * @param {string} repo name of the repo to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgAddTeamRepository(id: number, org: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgAddTeamRepository(id, org, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Conceal a user\'s membership
         * @param {string} org name of the organization
         * @param {string} username username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgConcealMember(org: string, username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgConcealMember(org, username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an organization
         * @param {CreateOrgOption} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgCreate(organization: CreateOrgOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgCreate(organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a hook
         * @param {string} org name of the organization
         * @param {CreateHookOption} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgCreateHook(org: string, body: CreateHookOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgCreateHook(org, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a label for an organization
         * @param {string} org name of the organization
         * @param {CreateLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgCreateLabel(org: string, body?: CreateLabelOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgCreateLabel(org, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a team
         * @param {string} org name of the organization
         * @param {CreateTeamOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgCreateTeam(org: string, body?: CreateTeamOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgCreateTeam(org, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an organization
         * @param {string} org organization that is to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgDelete(org: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgDelete(org, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Avatar
         * @param {string} org name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgDeleteAvatar(org: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgDeleteAvatar(org, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a hook
         * @param {string} org name of the organization
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgDeleteHook(org: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgDeleteHook(org, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a label
         * @param {string} org name of the organization
         * @param {number} id id of the label to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgDeleteLabel(org: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgDeleteLabel(org, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a member from an organization
         * @param {string} org name of the organization
         * @param {string} username username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgDeleteMember(org: string, username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgDeleteMember(org, username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a team
         * @param {number} id id of the team to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgDeleteTeam(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgDeleteTeam(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit an organization
         * @param {string} org name of the organization to edit
         * @param {EditOrgOption} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgEdit(org: string, body: EditOrgOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgEdit(org, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a hook
         * @param {string} org name of the organization
         * @param {number} id id of the hook to update
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgEditHook(org: string, id: number, body?: EditHookOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgEditHook(org, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a label
         * @param {string} org name of the organization
         * @param {number} id id of the label to edit
         * @param {EditLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgEditLabel(org: string, id: number, body?: EditLabelOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgEditLabel(org, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a team
         * @param {number} id id of the team to edit
         * @param {EditTeamOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgEditTeam(id: number, body?: EditTeamOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgEditTeam(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an organization
         * @param {string} org name of the organization to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgGet(org: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgGet(org, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get list of organizations
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgGetAll(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgGetAll(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a hook
         * @param {string} org name of the organization
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgGetHook(org: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgGetHook(org, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single label
         * @param {string} org name of the organization
         * @param {number} id id of the label to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgGetLabel(org: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgGetLabel(org, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a team
         * @param {number} id id of the team to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgGetTeam(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgGetTeam(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user permissions in organization
         * @param {string} username username of user
         * @param {string} org name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgGetUserPermissions(username: string, org: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationPermissions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgGetUserPermissions(username, org, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if a user is a member of an organization
         * @param {string} org name of the organization
         * @param {string} username username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgIsMember(org: string, username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgIsMember(org, username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if a user is a public member of an organization
         * @param {string} org name of the organization
         * @param {string} username username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgIsPublicMember(org: string, username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgIsPublicMember(org, username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List an organization\'s actions secrets
         * @param {string} org name of the organization
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgListActionsSecrets(org: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Secret>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgListActionsSecrets(org, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List an organization\'s activity feeds
         * @param {string} org name of the org
         * @param {string} [date] the date of the activities to be found
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgListActivityFeeds(org: string, date?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Activity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgListActivityFeeds(org, date, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the current user\'s organizations
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgListCurrentUserOrgs(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgListCurrentUserOrgs(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List an organization\'s webhooks
         * @param {string} org name of the organization
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgListHooks(org: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hook>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgListHooks(org, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List an organization\'s labels
         * @param {string} org name of the organization
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgListLabels(org: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Label>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgListLabels(org, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List an organization\'s members
         * @param {string} org name of the organization
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgListMembers(org: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgListMembers(org, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List an organization\'s public members
         * @param {string} org name of the organization
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgListPublicMembers(org: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgListPublicMembers(org, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List an organization\'s repos
         * @param {string} org name of the organization
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgListRepos(org: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgListRepos(org, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a team\'s activity feeds
         * @param {number} id id of the team
         * @param {string} [date] the date of the activities to be found
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgListTeamActivityFeeds(id: number, date?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Activity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgListTeamActivityFeeds(id, date, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a particular member of team
         * @param {number} id id of the team
         * @param {string} username username of the member to list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgListTeamMember(id: number, username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgListTeamMember(id, username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a team\'s members
         * @param {number} id id of the team
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgListTeamMembers(id: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgListTeamMembers(id, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a particular repo of team
         * @param {number} id id of the team
         * @param {string} org organization that owns the repo to list
         * @param {string} repo name of the repo to list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgListTeamRepo(id: number, org: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgListTeamRepo(id, org, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a team\'s repos
         * @param {number} id id of the team
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgListTeamRepos(id: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgListTeamRepos(id, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List an organization\'s teams
         * @param {string} org name of the organization
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgListTeams(org: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Team>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgListTeams(org, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a user\'s organizations
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgListUserOrgs(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgListUserOrgs(username, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Publicize a user\'s membership
         * @param {string} org name of the organization
         * @param {string} username username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgPublicizeMember(org: string, username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgPublicizeMember(org, username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a team member
         * @param {number} id id of the team
         * @param {string} username username of the user to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgRemoveTeamMember(id: number, username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgRemoveTeamMember(id, username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This does not delete the repository, it only removes the repository from the team.
         * @summary Remove a repository from a team
         * @param {number} id id of the team
         * @param {string} org organization that owns the repo to remove
         * @param {string} repo name of the repo to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgRemoveTeamRepository(id: number, org: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgRemoveTeamRepository(id, org, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Avatar
         * @param {string} org name of the organization
         * @param {UpdateUserAvatarOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgUpdateAvatar(org: string, body?: UpdateUserAvatarOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgUpdateAvatar(org, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search for teams within an organization
         * @param {string} org name of the organization
         * @param {string} [q] keywords to search
         * @param {boolean} [includeDesc] include search within team description (defaults to true)
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamSearch(org: string, q?: string, includeDesc?: boolean, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamSearch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamSearch(org, q, includeDesc, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create or Update a secret value in an organization
         * @param {string} org name of organization
         * @param {string} secretname name of the secret
         * @param {CreateOrUpdateSecretOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrgSecret(org: string, secretname: string, body?: CreateOrUpdateSecretOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrgSecret(org, secretname, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a repository in an organization
         * @param {string} org name of organization
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrgRepo(org: string, body?: CreateRepoOption, options?: any): AxiosPromise<Repository> {
            return localVarFp.createOrgRepo(org, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a repository in an organization
         * @param {string} org name of organization
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createOrgRepoDeprecated(org: string, body?: CreateRepoOption, options?: any): AxiosPromise<Repository> {
            return localVarFp.createOrgRepoDeprecated(org, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a secret in an organization
         * @param {string} org name of organization
         * @param {string} secretname name of the secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgSecret(org: string, secretname: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrgSecret(org, secretname, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a team member
         * @param {number} id id of the team
         * @param {string} username username of the user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgAddTeamMember(id: number, username: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgAddTeamMember(id, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a repository to a team
         * @param {number} id id of the team
         * @param {string} org organization that owns the repo to add
         * @param {string} repo name of the repo to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgAddTeamRepository(id: number, org: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgAddTeamRepository(id, org, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Conceal a user\'s membership
         * @param {string} org name of the organization
         * @param {string} username username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgConcealMember(org: string, username: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgConcealMember(org, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an organization
         * @param {CreateOrgOption} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgCreate(organization: CreateOrgOption, options?: any): AxiosPromise<Organization> {
            return localVarFp.orgCreate(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a hook
         * @param {string} org name of the organization
         * @param {CreateHookOption} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgCreateHook(org: string, body: CreateHookOption, options?: any): AxiosPromise<Hook> {
            return localVarFp.orgCreateHook(org, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a label for an organization
         * @param {string} org name of the organization
         * @param {CreateLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgCreateLabel(org: string, body?: CreateLabelOption, options?: any): AxiosPromise<Label> {
            return localVarFp.orgCreateLabel(org, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a team
         * @param {string} org name of the organization
         * @param {CreateTeamOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgCreateTeam(org: string, body?: CreateTeamOption, options?: any): AxiosPromise<Team> {
            return localVarFp.orgCreateTeam(org, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an organization
         * @param {string} org organization that is to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgDelete(org: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgDelete(org, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Avatar
         * @param {string} org name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgDeleteAvatar(org: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgDeleteAvatar(org, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a hook
         * @param {string} org name of the organization
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgDeleteHook(org: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.orgDeleteHook(org, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a label
         * @param {string} org name of the organization
         * @param {number} id id of the label to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgDeleteLabel(org: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.orgDeleteLabel(org, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a member from an organization
         * @param {string} org name of the organization
         * @param {string} username username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgDeleteMember(org: string, username: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgDeleteMember(org, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a team
         * @param {number} id id of the team to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgDeleteTeam(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.orgDeleteTeam(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit an organization
         * @param {string} org name of the organization to edit
         * @param {EditOrgOption} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgEdit(org: string, body: EditOrgOption, options?: any): AxiosPromise<Organization> {
            return localVarFp.orgEdit(org, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a hook
         * @param {string} org name of the organization
         * @param {number} id id of the hook to update
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgEditHook(org: string, id: number, body?: EditHookOption, options?: any): AxiosPromise<Hook> {
            return localVarFp.orgEditHook(org, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a label
         * @param {string} org name of the organization
         * @param {number} id id of the label to edit
         * @param {EditLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgEditLabel(org: string, id: number, body?: EditLabelOption, options?: any): AxiosPromise<Label> {
            return localVarFp.orgEditLabel(org, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a team
         * @param {number} id id of the team to edit
         * @param {EditTeamOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgEditTeam(id: number, body?: EditTeamOption, options?: any): AxiosPromise<Team> {
            return localVarFp.orgEditTeam(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an organization
         * @param {string} org name of the organization to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgGet(org: string, options?: any): AxiosPromise<Organization> {
            return localVarFp.orgGet(org, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of organizations
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgGetAll(page?: number, limit?: number, options?: any): AxiosPromise<Array<Organization>> {
            return localVarFp.orgGetAll(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a hook
         * @param {string} org name of the organization
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgGetHook(org: string, id: number, options?: any): AxiosPromise<Hook> {
            return localVarFp.orgGetHook(org, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single label
         * @param {string} org name of the organization
         * @param {number} id id of the label to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgGetLabel(org: string, id: number, options?: any): AxiosPromise<Label> {
            return localVarFp.orgGetLabel(org, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a team
         * @param {number} id id of the team to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgGetTeam(id: number, options?: any): AxiosPromise<Team> {
            return localVarFp.orgGetTeam(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user permissions in organization
         * @param {string} username username of user
         * @param {string} org name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgGetUserPermissions(username: string, org: string, options?: any): AxiosPromise<OrganizationPermissions> {
            return localVarFp.orgGetUserPermissions(username, org, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if a user is a member of an organization
         * @param {string} org name of the organization
         * @param {string} username username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgIsMember(org: string, username: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgIsMember(org, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if a user is a public member of an organization
         * @param {string} org name of the organization
         * @param {string} username username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgIsPublicMember(org: string, username: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgIsPublicMember(org, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List an organization\'s actions secrets
         * @param {string} org name of the organization
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListActionsSecrets(org: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Secret>> {
            return localVarFp.orgListActionsSecrets(org, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List an organization\'s activity feeds
         * @param {string} org name of the org
         * @param {string} [date] the date of the activities to be found
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListActivityFeeds(org: string, date?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Activity>> {
            return localVarFp.orgListActivityFeeds(org, date, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the current user\'s organizations
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListCurrentUserOrgs(page?: number, limit?: number, options?: any): AxiosPromise<Array<Organization>> {
            return localVarFp.orgListCurrentUserOrgs(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List an organization\'s webhooks
         * @param {string} org name of the organization
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListHooks(org: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Hook>> {
            return localVarFp.orgListHooks(org, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List an organization\'s labels
         * @param {string} org name of the organization
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListLabels(org: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Label>> {
            return localVarFp.orgListLabels(org, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List an organization\'s members
         * @param {string} org name of the organization
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListMembers(org: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.orgListMembers(org, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List an organization\'s public members
         * @param {string} org name of the organization
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListPublicMembers(org: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.orgListPublicMembers(org, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List an organization\'s repos
         * @param {string} org name of the organization
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListRepos(org: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.orgListRepos(org, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a team\'s activity feeds
         * @param {number} id id of the team
         * @param {string} [date] the date of the activities to be found
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListTeamActivityFeeds(id: number, date?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Activity>> {
            return localVarFp.orgListTeamActivityFeeds(id, date, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a particular member of team
         * @param {number} id id of the team
         * @param {string} username username of the member to list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListTeamMember(id: number, username: string, options?: any): AxiosPromise<User> {
            return localVarFp.orgListTeamMember(id, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a team\'s members
         * @param {number} id id of the team
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListTeamMembers(id: number, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.orgListTeamMembers(id, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a particular repo of team
         * @param {number} id id of the team
         * @param {string} org organization that owns the repo to list
         * @param {string} repo name of the repo to list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListTeamRepo(id: number, org: string, repo: string, options?: any): AxiosPromise<Repository> {
            return localVarFp.orgListTeamRepo(id, org, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a team\'s repos
         * @param {number} id id of the team
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListTeamRepos(id: number, page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.orgListTeamRepos(id, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List an organization\'s teams
         * @param {string} org name of the organization
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListTeams(org: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Team>> {
            return localVarFp.orgListTeams(org, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a user\'s organizations
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgListUserOrgs(username: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Organization>> {
            return localVarFp.orgListUserOrgs(username, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Publicize a user\'s membership
         * @param {string} org name of the organization
         * @param {string} username username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgPublicizeMember(org: string, username: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgPublicizeMember(org, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a team member
         * @param {number} id id of the team
         * @param {string} username username of the user to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgRemoveTeamMember(id: number, username: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgRemoveTeamMember(id, username, options).then((request) => request(axios, basePath));
        },
        /**
         * This does not delete the repository, it only removes the repository from the team.
         * @summary Remove a repository from a team
         * @param {number} id id of the team
         * @param {string} org organization that owns the repo to remove
         * @param {string} repo name of the repo to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgRemoveTeamRepository(id: number, org: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgRemoveTeamRepository(id, org, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Avatar
         * @param {string} org name of the organization
         * @param {UpdateUserAvatarOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgUpdateAvatar(org: string, body?: UpdateUserAvatarOption, options?: any): AxiosPromise<void> {
            return localVarFp.orgUpdateAvatar(org, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for teams within an organization
         * @param {string} org name of the organization
         * @param {string} [q] keywords to search
         * @param {boolean} [includeDesc] include search within team description (defaults to true)
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamSearch(org: string, q?: string, includeDesc?: boolean, page?: number, limit?: number, options?: any): AxiosPromise<TeamSearch200Response> {
            return localVarFp.teamSearch(org, q, includeDesc, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create or Update a secret value in an organization
         * @param {string} org name of organization
         * @param {string} secretname name of the secret
         * @param {CreateOrUpdateSecretOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrgSecret(org: string, secretname: string, body?: CreateOrUpdateSecretOption, options?: any): AxiosPromise<void> {
            return localVarFp.updateOrgSecret(org, secretname, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApi - interface
 * @export
 * @interface OrganizationApi
 */
export interface OrganizationApiInterface {
    /**
     * 
     * @summary Create a repository in an organization
     * @param {string} org name of organization
     * @param {CreateRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    createOrgRepo(org: string, body?: CreateRepoOption, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Create a repository in an organization
     * @param {string} org name of organization
     * @param {CreateRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    createOrgRepoDeprecated(org: string, body?: CreateRepoOption, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Delete a secret in an organization
     * @param {string} org name of organization
     * @param {string} secretname name of the secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    deleteOrgSecret(org: string, secretname: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Add a team member
     * @param {number} id id of the team
     * @param {string} username username of the user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgAddTeamMember(id: number, username: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Add a repository to a team
     * @param {number} id id of the team
     * @param {string} org organization that owns the repo to add
     * @param {string} repo name of the repo to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgAddTeamRepository(id: number, org: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Conceal a user\'s membership
     * @param {string} org name of the organization
     * @param {string} username username of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgConcealMember(org: string, username: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Create an organization
     * @param {CreateOrgOption} organization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgCreate(organization: CreateOrgOption, options?: AxiosRequestConfig): AxiosPromise<Organization>;

    /**
     * 
     * @summary Create a hook
     * @param {string} org name of the organization
     * @param {CreateHookOption} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgCreateHook(org: string, body: CreateHookOption, options?: AxiosRequestConfig): AxiosPromise<Hook>;

    /**
     * 
     * @summary Create a label for an organization
     * @param {string} org name of the organization
     * @param {CreateLabelOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgCreateLabel(org: string, body?: CreateLabelOption, options?: AxiosRequestConfig): AxiosPromise<Label>;

    /**
     * 
     * @summary Create a team
     * @param {string} org name of the organization
     * @param {CreateTeamOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgCreateTeam(org: string, body?: CreateTeamOption, options?: AxiosRequestConfig): AxiosPromise<Team>;

    /**
     * 
     * @summary Delete an organization
     * @param {string} org organization that is to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgDelete(org: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete Avatar
     * @param {string} org name of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgDeleteAvatar(org: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a hook
     * @param {string} org name of the organization
     * @param {number} id id of the hook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgDeleteHook(org: string, id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a label
     * @param {string} org name of the organization
     * @param {number} id id of the label to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgDeleteLabel(org: string, id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Remove a member from an organization
     * @param {string} org name of the organization
     * @param {string} username username of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgDeleteMember(org: string, username: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a team
     * @param {number} id id of the team to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgDeleteTeam(id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Edit an organization
     * @param {string} org name of the organization to edit
     * @param {EditOrgOption} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgEdit(org: string, body: EditOrgOption, options?: AxiosRequestConfig): AxiosPromise<Organization>;

    /**
     * 
     * @summary Update a hook
     * @param {string} org name of the organization
     * @param {number} id id of the hook to update
     * @param {EditHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgEditHook(org: string, id: number, body?: EditHookOption, options?: AxiosRequestConfig): AxiosPromise<Hook>;

    /**
     * 
     * @summary Update a label
     * @param {string} org name of the organization
     * @param {number} id id of the label to edit
     * @param {EditLabelOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgEditLabel(org: string, id: number, body?: EditLabelOption, options?: AxiosRequestConfig): AxiosPromise<Label>;

    /**
     * 
     * @summary Edit a team
     * @param {number} id id of the team to edit
     * @param {EditTeamOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgEditTeam(id: number, body?: EditTeamOption, options?: AxiosRequestConfig): AxiosPromise<Team>;

    /**
     * 
     * @summary Get an organization
     * @param {string} org name of the organization to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgGet(org: string, options?: AxiosRequestConfig): AxiosPromise<Organization>;

    /**
     * 
     * @summary Get list of organizations
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgGetAll(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Organization>>;

    /**
     * 
     * @summary Get a hook
     * @param {string} org name of the organization
     * @param {number} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgGetHook(org: string, id: number, options?: AxiosRequestConfig): AxiosPromise<Hook>;

    /**
     * 
     * @summary Get a single label
     * @param {string} org name of the organization
     * @param {number} id id of the label to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgGetLabel(org: string, id: number, options?: AxiosRequestConfig): AxiosPromise<Label>;

    /**
     * 
     * @summary Get a team
     * @param {number} id id of the team to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgGetTeam(id: number, options?: AxiosRequestConfig): AxiosPromise<Team>;

    /**
     * 
     * @summary Get user permissions in organization
     * @param {string} username username of user
     * @param {string} org name of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgGetUserPermissions(username: string, org: string, options?: AxiosRequestConfig): AxiosPromise<OrganizationPermissions>;

    /**
     * 
     * @summary Check if a user is a member of an organization
     * @param {string} org name of the organization
     * @param {string} username username of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgIsMember(org: string, username: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Check if a user is a public member of an organization
     * @param {string} org name of the organization
     * @param {string} username username of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgIsPublicMember(org: string, username: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary List an organization\'s actions secrets
     * @param {string} org name of the organization
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgListActionsSecrets(org: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Secret>>;

    /**
     * 
     * @summary List an organization\'s activity feeds
     * @param {string} org name of the org
     * @param {string} [date] the date of the activities to be found
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgListActivityFeeds(org: string, date?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Activity>>;

    /**
     * 
     * @summary List the current user\'s organizations
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgListCurrentUserOrgs(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Organization>>;

    /**
     * 
     * @summary List an organization\'s webhooks
     * @param {string} org name of the organization
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgListHooks(org: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Hook>>;

    /**
     * 
     * @summary List an organization\'s labels
     * @param {string} org name of the organization
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgListLabels(org: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Label>>;

    /**
     * 
     * @summary List an organization\'s members
     * @param {string} org name of the organization
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgListMembers(org: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary List an organization\'s public members
     * @param {string} org name of the organization
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgListPublicMembers(org: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary List an organization\'s repos
     * @param {string} org name of the organization
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgListRepos(org: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Repository>>;

    /**
     * 
     * @summary List a team\'s activity feeds
     * @param {number} id id of the team
     * @param {string} [date] the date of the activities to be found
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgListTeamActivityFeeds(id: number, date?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Activity>>;

    /**
     * 
     * @summary List a particular member of team
     * @param {number} id id of the team
     * @param {string} username username of the member to list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgListTeamMember(id: number, username: string, options?: AxiosRequestConfig): AxiosPromise<User>;

    /**
     * 
     * @summary List a team\'s members
     * @param {number} id id of the team
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgListTeamMembers(id: number, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary List a particular repo of team
     * @param {number} id id of the team
     * @param {string} org organization that owns the repo to list
     * @param {string} repo name of the repo to list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgListTeamRepo(id: number, org: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary List a team\'s repos
     * @param {number} id id of the team
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgListTeamRepos(id: number, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Repository>>;

    /**
     * 
     * @summary List an organization\'s teams
     * @param {string} org name of the organization
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgListTeams(org: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Team>>;

    /**
     * 
     * @summary List a user\'s organizations
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgListUserOrgs(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Organization>>;

    /**
     * 
     * @summary Publicize a user\'s membership
     * @param {string} org name of the organization
     * @param {string} username username of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgPublicizeMember(org: string, username: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Remove a team member
     * @param {number} id id of the team
     * @param {string} username username of the user to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgRemoveTeamMember(id: number, username: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * This does not delete the repository, it only removes the repository from the team.
     * @summary Remove a repository from a team
     * @param {number} id id of the team
     * @param {string} org organization that owns the repo to remove
     * @param {string} repo name of the repo to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgRemoveTeamRepository(id: number, org: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Update Avatar
     * @param {string} org name of the organization
     * @param {UpdateUserAvatarOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    orgUpdateAvatar(org: string, body?: UpdateUserAvatarOption, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Search for teams within an organization
     * @param {string} org name of the organization
     * @param {string} [q] keywords to search
     * @param {boolean} [includeDesc] include search within team description (defaults to true)
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    teamSearch(org: string, q?: string, includeDesc?: boolean, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<TeamSearch200Response>;

    /**
     * 
     * @summary Create or Update a secret value in an organization
     * @param {string} org name of organization
     * @param {string} secretname name of the secret
     * @param {CreateOrUpdateSecretOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    updateOrgSecret(org: string, secretname: string, body?: CreateOrUpdateSecretOption, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI implements OrganizationApiInterface {
    /**
     * 
     * @summary Create a repository in an organization
     * @param {string} org name of organization
     * @param {CreateRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public createOrgRepo(org: string, body?: CreateRepoOption, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).createOrgRepo(org, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a repository in an organization
     * @param {string} org name of organization
     * @param {CreateRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public createOrgRepoDeprecated(org: string, body?: CreateRepoOption, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).createOrgRepoDeprecated(org, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a secret in an organization
     * @param {string} org name of organization
     * @param {string} secretname name of the secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public deleteOrgSecret(org: string, secretname: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).deleteOrgSecret(org, secretname, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a team member
     * @param {number} id id of the team
     * @param {string} username username of the user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgAddTeamMember(id: number, username: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgAddTeamMember(id, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a repository to a team
     * @param {number} id id of the team
     * @param {string} org organization that owns the repo to add
     * @param {string} repo name of the repo to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgAddTeamRepository(id: number, org: string, repo: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgAddTeamRepository(id, org, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Conceal a user\'s membership
     * @param {string} org name of the organization
     * @param {string} username username of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgConcealMember(org: string, username: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgConcealMember(org, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an organization
     * @param {CreateOrgOption} organization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgCreate(organization: CreateOrgOption, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgCreate(organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a hook
     * @param {string} org name of the organization
     * @param {CreateHookOption} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgCreateHook(org: string, body: CreateHookOption, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgCreateHook(org, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a label for an organization
     * @param {string} org name of the organization
     * @param {CreateLabelOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgCreateLabel(org: string, body?: CreateLabelOption, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgCreateLabel(org, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a team
     * @param {string} org name of the organization
     * @param {CreateTeamOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgCreateTeam(org: string, body?: CreateTeamOption, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgCreateTeam(org, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an organization
     * @param {string} org organization that is to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgDelete(org: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgDelete(org, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Avatar
     * @param {string} org name of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgDeleteAvatar(org: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgDeleteAvatar(org, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a hook
     * @param {string} org name of the organization
     * @param {number} id id of the hook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgDeleteHook(org: string, id: number, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgDeleteHook(org, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a label
     * @param {string} org name of the organization
     * @param {number} id id of the label to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgDeleteLabel(org: string, id: number, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgDeleteLabel(org, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a member from an organization
     * @param {string} org name of the organization
     * @param {string} username username of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgDeleteMember(org: string, username: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgDeleteMember(org, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a team
     * @param {number} id id of the team to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgDeleteTeam(id: number, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgDeleteTeam(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit an organization
     * @param {string} org name of the organization to edit
     * @param {EditOrgOption} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgEdit(org: string, body: EditOrgOption, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgEdit(org, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a hook
     * @param {string} org name of the organization
     * @param {number} id id of the hook to update
     * @param {EditHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgEditHook(org: string, id: number, body?: EditHookOption, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgEditHook(org, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a label
     * @param {string} org name of the organization
     * @param {number} id id of the label to edit
     * @param {EditLabelOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgEditLabel(org: string, id: number, body?: EditLabelOption, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgEditLabel(org, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a team
     * @param {number} id id of the team to edit
     * @param {EditTeamOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgEditTeam(id: number, body?: EditTeamOption, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgEditTeam(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an organization
     * @param {string} org name of the organization to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgGet(org: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgGet(org, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of organizations
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgGetAll(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgGetAll(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a hook
     * @param {string} org name of the organization
     * @param {number} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgGetHook(org: string, id: number, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgGetHook(org, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single label
     * @param {string} org name of the organization
     * @param {number} id id of the label to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgGetLabel(org: string, id: number, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgGetLabel(org, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a team
     * @param {number} id id of the team to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgGetTeam(id: number, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgGetTeam(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user permissions in organization
     * @param {string} username username of user
     * @param {string} org name of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgGetUserPermissions(username: string, org: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgGetUserPermissions(username, org, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if a user is a member of an organization
     * @param {string} org name of the organization
     * @param {string} username username of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgIsMember(org: string, username: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgIsMember(org, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if a user is a public member of an organization
     * @param {string} org name of the organization
     * @param {string} username username of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgIsPublicMember(org: string, username: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgIsPublicMember(org, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List an organization\'s actions secrets
     * @param {string} org name of the organization
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgListActionsSecrets(org: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgListActionsSecrets(org, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List an organization\'s activity feeds
     * @param {string} org name of the org
     * @param {string} [date] the date of the activities to be found
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgListActivityFeeds(org: string, date?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgListActivityFeeds(org, date, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the current user\'s organizations
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgListCurrentUserOrgs(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgListCurrentUserOrgs(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List an organization\'s webhooks
     * @param {string} org name of the organization
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgListHooks(org: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgListHooks(org, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List an organization\'s labels
     * @param {string} org name of the organization
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgListLabels(org: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgListLabels(org, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List an organization\'s members
     * @param {string} org name of the organization
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgListMembers(org: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgListMembers(org, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List an organization\'s public members
     * @param {string} org name of the organization
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgListPublicMembers(org: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgListPublicMembers(org, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List an organization\'s repos
     * @param {string} org name of the organization
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgListRepos(org: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgListRepos(org, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a team\'s activity feeds
     * @param {number} id id of the team
     * @param {string} [date] the date of the activities to be found
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgListTeamActivityFeeds(id: number, date?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgListTeamActivityFeeds(id, date, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a particular member of team
     * @param {number} id id of the team
     * @param {string} username username of the member to list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgListTeamMember(id: number, username: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgListTeamMember(id, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a team\'s members
     * @param {number} id id of the team
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgListTeamMembers(id: number, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgListTeamMembers(id, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a particular repo of team
     * @param {number} id id of the team
     * @param {string} org organization that owns the repo to list
     * @param {string} repo name of the repo to list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgListTeamRepo(id: number, org: string, repo: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgListTeamRepo(id, org, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a team\'s repos
     * @param {number} id id of the team
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgListTeamRepos(id: number, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgListTeamRepos(id, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List an organization\'s teams
     * @param {string} org name of the organization
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgListTeams(org: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgListTeams(org, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a user\'s organizations
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgListUserOrgs(username: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgListUserOrgs(username, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Publicize a user\'s membership
     * @param {string} org name of the organization
     * @param {string} username username of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgPublicizeMember(org: string, username: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgPublicizeMember(org, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a team member
     * @param {number} id id of the team
     * @param {string} username username of the user to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgRemoveTeamMember(id: number, username: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgRemoveTeamMember(id, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This does not delete the repository, it only removes the repository from the team.
     * @summary Remove a repository from a team
     * @param {number} id id of the team
     * @param {string} org organization that owns the repo to remove
     * @param {string} repo name of the repo to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgRemoveTeamRepository(id: number, org: string, repo: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgRemoveTeamRepository(id, org, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Avatar
     * @param {string} org name of the organization
     * @param {UpdateUserAvatarOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgUpdateAvatar(org: string, body?: UpdateUserAvatarOption, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgUpdateAvatar(org, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for teams within an organization
     * @param {string} org name of the organization
     * @param {string} [q] keywords to search
     * @param {boolean} [includeDesc] include search within team description (defaults to true)
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public teamSearch(org: string, q?: string, includeDesc?: boolean, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).teamSearch(org, q, includeDesc, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create or Update a secret value in an organization
     * @param {string} org name of organization
     * @param {string} secretname name of the secret
     * @param {CreateOrUpdateSecretOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateOrgSecret(org: string, secretname: string, body?: CreateOrUpdateSecretOption, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateOrgSecret(org, secretname, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PackageApi - axios parameter creator
 * @export
 */
export const PackageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a package
         * @param {string} owner owner of the package
         * @param {string} type type of the package
         * @param {string} name name of the package
         * @param {string} version version of the package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePackage: async (owner: string, type: string, name: string, version: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('deletePackage', 'owner', owner)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('deletePackage', 'type', type)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deletePackage', 'name', name)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('deletePackage', 'version', version)
            const localVarPath = `/packages/{owner}/{type}/{name}/{version}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a package
         * @param {string} owner owner of the package
         * @param {string} type type of the package
         * @param {string} name name of the package
         * @param {string} version version of the package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackage: async (owner: string, type: string, name: string, version: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('getPackage', 'owner', owner)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getPackage', 'type', type)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getPackage', 'name', name)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('getPackage', 'version', version)
            const localVarPath = `/packages/{owner}/{type}/{name}/{version}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all files of a package
         * @param {string} owner owner of the package
         * @param {string} type type of the package
         * @param {string} name name of the package
         * @param {string} version version of the package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPackageFiles: async (owner: string, type: string, name: string, version: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('listPackageFiles', 'owner', owner)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('listPackageFiles', 'type', type)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('listPackageFiles', 'name', name)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('listPackageFiles', 'version', version)
            const localVarPath = `/packages/{owner}/{type}/{name}/{version}/files`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all packages of an owner
         * @param {string} owner owner of the packages
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {ListPackagesTypeEnum} [type] package type filter
         * @param {string} [q] name filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPackages: async (owner: string, page?: number, limit?: number, type?: ListPackagesTypeEnum, q?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('listPackages', 'owner', owner)
            const localVarPath = `/packages/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PackageApi - functional programming interface
 * @export
 */
export const PackageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PackageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a package
         * @param {string} owner owner of the package
         * @param {string} type type of the package
         * @param {string} name name of the package
         * @param {string} version version of the package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePackage(owner: string, type: string, name: string, version: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePackage(owner, type, name, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets a package
         * @param {string} owner owner of the package
         * @param {string} type type of the package
         * @param {string} name name of the package
         * @param {string} version version of the package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPackage(owner: string, type: string, name: string, version: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Package>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPackage(owner, type, name, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets all files of a package
         * @param {string} owner owner of the package
         * @param {string} type type of the package
         * @param {string} name name of the package
         * @param {string} version version of the package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPackageFiles(owner: string, type: string, name: string, version: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PackageFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPackageFiles(owner, type, name, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets all packages of an owner
         * @param {string} owner owner of the packages
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {ListPackagesTypeEnum} [type] package type filter
         * @param {string} [q] name filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPackages(owner: string, page?: number, limit?: number, type?: ListPackagesTypeEnum, q?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Package>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPackages(owner, page, limit, type, q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PackageApi - factory interface
 * @export
 */
export const PackageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PackageApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a package
         * @param {string} owner owner of the package
         * @param {string} type type of the package
         * @param {string} name name of the package
         * @param {string} version version of the package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePackage(owner: string, type: string, name: string, version: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePackage(owner, type, name, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a package
         * @param {string} owner owner of the package
         * @param {string} type type of the package
         * @param {string} name name of the package
         * @param {string} version version of the package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackage(owner: string, type: string, name: string, version: string, options?: any): AxiosPromise<Package> {
            return localVarFp.getPackage(owner, type, name, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all files of a package
         * @param {string} owner owner of the package
         * @param {string} type type of the package
         * @param {string} name name of the package
         * @param {string} version version of the package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPackageFiles(owner: string, type: string, name: string, version: string, options?: any): AxiosPromise<Array<PackageFile>> {
            return localVarFp.listPackageFiles(owner, type, name, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all packages of an owner
         * @param {string} owner owner of the packages
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {ListPackagesTypeEnum} [type] package type filter
         * @param {string} [q] name filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPackages(owner: string, page?: number, limit?: number, type?: ListPackagesTypeEnum, q?: string, options?: any): AxiosPromise<Array<Package>> {
            return localVarFp.listPackages(owner, page, limit, type, q, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PackageApi - interface
 * @export
 * @interface PackageApi
 */
export interface PackageApiInterface {
    /**
     * 
     * @summary Delete a package
     * @param {string} owner owner of the package
     * @param {string} type type of the package
     * @param {string} name name of the package
     * @param {string} version version of the package
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApiInterface
     */
    deletePackage(owner: string, type: string, name: string, version: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Gets a package
     * @param {string} owner owner of the package
     * @param {string} type type of the package
     * @param {string} name name of the package
     * @param {string} version version of the package
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApiInterface
     */
    getPackage(owner: string, type: string, name: string, version: string, options?: AxiosRequestConfig): AxiosPromise<Package>;

    /**
     * 
     * @summary Gets all files of a package
     * @param {string} owner owner of the package
     * @param {string} type type of the package
     * @param {string} name name of the package
     * @param {string} version version of the package
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApiInterface
     */
    listPackageFiles(owner: string, type: string, name: string, version: string, options?: AxiosRequestConfig): AxiosPromise<Array<PackageFile>>;

    /**
     * 
     * @summary Gets all packages of an owner
     * @param {string} owner owner of the packages
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {ListPackagesTypeEnum} [type] package type filter
     * @param {string} [q] name filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApiInterface
     */
    listPackages(owner: string, page?: number, limit?: number, type?: ListPackagesTypeEnum, q?: string, options?: AxiosRequestConfig): AxiosPromise<Array<Package>>;

}

/**
 * PackageApi - object-oriented interface
 * @export
 * @class PackageApi
 * @extends {BaseAPI}
 */
export class PackageApi extends BaseAPI implements PackageApiInterface {
    /**
     * 
     * @summary Delete a package
     * @param {string} owner owner of the package
     * @param {string} type type of the package
     * @param {string} name name of the package
     * @param {string} version version of the package
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public deletePackage(owner: string, type: string, name: string, version: string, options?: AxiosRequestConfig) {
        return PackageApiFp(this.configuration).deletePackage(owner, type, name, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a package
     * @param {string} owner owner of the package
     * @param {string} type type of the package
     * @param {string} name name of the package
     * @param {string} version version of the package
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public getPackage(owner: string, type: string, name: string, version: string, options?: AxiosRequestConfig) {
        return PackageApiFp(this.configuration).getPackage(owner, type, name, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all files of a package
     * @param {string} owner owner of the package
     * @param {string} type type of the package
     * @param {string} name name of the package
     * @param {string} version version of the package
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public listPackageFiles(owner: string, type: string, name: string, version: string, options?: AxiosRequestConfig) {
        return PackageApiFp(this.configuration).listPackageFiles(owner, type, name, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all packages of an owner
     * @param {string} owner owner of the packages
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {ListPackagesTypeEnum} [type] package type filter
     * @param {string} [q] name filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public listPackages(owner: string, page?: number, limit?: number, type?: ListPackagesTypeEnum, q?: string, options?: AxiosRequestConfig) {
        return PackageApiFp(this.configuration).listPackages(owner, page, limit, type, q, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListPackagesTypeEnum = {
    alpine: 'alpine',
    cargo: 'cargo',
    chef: 'chef',
    composer: 'composer',
    conan: 'conan',
    conda: 'conda',
    container: 'container',
    cran: 'cran',
    debian: 'debian',
    generic: 'generic',
    go: 'go',
    helm: 'helm',
    maven: 'maven',
    npm: 'npm',
    nuget: 'nuget',
    pub: 'pub',
    pypi: 'pypi',
    rpm: 'rpm',
    rubygems: 'rubygems',
    swift: 'swift',
    vagrant: 'vagrant'
} as const;
export type ListPackagesTypeEnum = typeof ListPackagesTypeEnum[keyof typeof ListPackagesTypeEnum];


/**
 * RepositoryApi - axios parameter creator
 * @export
 */
export const RepositoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accept a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptRepoTransfer: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('acceptRepoTransfer', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('acceptRepoTransfer', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/transfer/accept`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a repository
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrentUserRepo: async (body?: CreateRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/repos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fork a repository
         * @param {string} owner owner of the repo to fork
         * @param {string} repo name of the repo to fork
         * @param {CreateForkOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFork: async (owner: string, repo: string, body?: CreateForkOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('createFork', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('createFork', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/forks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a secret in a repository
         * @param {string} owner owner of the repository
         * @param {string} repo name of the repository
         * @param {string} secretname name of the secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepoSecret: async (owner: string, repo: string, secretname: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('deleteRepoSecret', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('deleteRepoSecret', 'repo', repo)
            // verify required parameter 'secretname' is not null or undefined
            assertParamExists('deleteRepoSecret', 'secretname', secretname)
            const localVarPath = `/repos/{owner}/{repo}/actions/secrets/{secretname}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"secretname"}}`, encodeURIComponent(String(secretname)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a repository using a template
         * @param {string} templateOwner name of the template repository owner
         * @param {string} templateRepo name of the template repository
         * @param {GenerateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateRepo: async (templateOwner: string, templateRepo: string, body?: GenerateRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateOwner' is not null or undefined
            assertParamExists('generateRepo', 'templateOwner', templateOwner)
            // verify required parameter 'templateRepo' is not null or undefined
            assertParamExists('generateRepo', 'templateRepo', templateRepo)
            const localVarPath = `/repos/{template_owner}/{template_repo}/generate`
                .replace(`{${"template_owner"}}`, encodeURIComponent(String(templateOwner)))
                .replace(`{${"template_repo"}}`, encodeURIComponent(String(templateRepo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the tag object of an annotated tag (not lightweight tags)
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotatedTag: async (owner: string, repo: string, sha: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('getAnnotatedTag', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('getAnnotatedTag', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('getAnnotatedTag', 'sha', sha)
            const localVarPath = `/repos/{owner}/{repo}/git/tags/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the blob of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlob: async (owner: string, repo: string, sha: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('getBlob', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('getBlob', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('getBlob', 'sha', sha)
            const localVarPath = `/repos/{owner}/{repo}/git/blobs/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the tree of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {boolean} [recursive] show all directories and files
         * @param {number} [page] page number; the \&#39;truncated\&#39; field in the response will be true if there are still more items after this page, false if the last page
         * @param {number} [perPage] number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTree: async (owner: string, repo: string, sha: string, recursive?: boolean, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('getTree', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('getTree', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('getTree', 'sha', sha)
            const localVarPath = `/repos/{owner}/{repo}/git/trees/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s forks
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForks: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('listForks', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('listForks', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/forks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reject a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectRepoTransfer: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('rejectRepoTransfer', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('rejectRepoTransfer', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/transfer/reject`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a collaborator to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to add
         * @param {AddCollaboratorOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddCollaborator: async (owner: string, repo: string, collaborator: string, body?: AddCollaboratorOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoAddCollaborator', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoAddCollaborator', 'repo', repo)
            // verify required parameter 'collaborator' is not null or undefined
            assertParamExists('repoAddCollaborator', 'collaborator', collaborator)
            const localVarPath = `/repos/{owner}/{repo}/collaborators/{collaborator}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"collaborator"}}`, encodeURIComponent(String(collaborator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary add a push mirror to the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreatePushMirrorOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddPushMirror: async (owner: string, repo: string, body?: CreatePushMirrorOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoAddPushMirror', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoAddPushMirror', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/push_mirrors`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a team to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddTeam: async (owner: string, repo: string, team: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoAddTeam', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoAddTeam', 'repo', repo)
            // verify required parameter 'team' is not null or undefined
            assertParamExists('repoAddTeam', 'team', team)
            const localVarPath = `/repos/{owner}/{repo}/teams/{team}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a topic to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddTopic: async (owner: string, repo: string, topic: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoAddTopic', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoAddTopic', 'repo', repo)
            // verify required parameter 'topic' is not null or undefined
            assertParamExists('repoAddTopic', 'topic', topic)
            const localVarPath = `/repos/{owner}/{repo}/topics/{topic}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Apply diff patch to repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {UpdateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoApplyDiffPatch: async (owner: string, repo: string, body: UpdateFileOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoApplyDiffPatch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoApplyDiffPatch', 'repo', repo)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoApplyDiffPatch', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/diffpatch`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel the scheduled auto merge for the given pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCancelScheduledAutoMerge: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCancelScheduledAutoMerge', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCancelScheduledAutoMerge', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoCancelScheduledAutoMerge', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/merge`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify multiple files in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {ChangeFilesOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoChangeFiles: async (owner: string, repo: string, body: ChangeFilesOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoChangeFiles', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoChangeFiles', 'repo', repo)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoChangeFiles', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/contents`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if a user is a collaborator of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCheckCollaborator: async (owner: string, repo: string, collaborator: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCheckCollaborator', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCheckCollaborator', 'repo', repo)
            // verify required parameter 'collaborator' is not null or undefined
            assertParamExists('repoCheckCollaborator', 'collaborator', collaborator)
            const localVarPath = `/repos/{owner}/{repo}/collaborators/{collaborator}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"collaborator"}}`, encodeURIComponent(String(collaborator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if a team is assigned to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCheckTeam: async (owner: string, repo: string, team: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCheckTeam', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCheckTeam', 'repo', repo)
            // verify required parameter 'team' is not null or undefined
            assertParamExists('repoCheckTeam', 'team', team)
            const localVarPath = `/repos/{owner}/{repo}/teams/{team}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a branch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateBranch: async (owner: string, repo: string, body?: CreateBranchRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateBranch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateBranch', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/branches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateBranchProtection: async (owner: string, repo: string, body?: CreateBranchProtectionOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateBranchProtection', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateBranchProtection', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/branch_protections`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to create
         * @param {CreateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateFile: async (owner: string, repo: string, filepath: string, body: CreateFileOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateFile', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateFile', 'repo', repo)
            // verify required parameter 'filepath' is not null or undefined
            assertParamExists('repoCreateFile', 'filepath', filepath)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoCreateFile', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/contents/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateHook: async (owner: string, repo: string, body?: CreateHookOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateHook', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/hooks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a key to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateKeyOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateKey: async (owner: string, repo: string, body?: CreateKeyOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateKey', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateKey', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/keys`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreatePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullRequest: async (owner: string, repo: string, body?: CreatePullRequestOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreatePullRequest', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreatePullRequest', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/pulls`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a review to an pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {CreatePullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullReview: async (owner: string, repo: string, index: number, body: CreatePullReviewOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreatePullReview', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreatePullReview', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoCreatePullReview', 'index', index)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoCreatePullReview', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create review requests for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {PullReviewRequestOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullReviewRequests: async (owner: string, repo: string, index: number, body: PullReviewRequestOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreatePullReviewRequests', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreatePullReviewRequests', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoCreatePullReviewRequests', 'index', index)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoCreatePullReviewRequests', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/requested_reviewers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateRelease: async (owner: string, repo: string, body?: CreateReleaseOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateRelease', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateRelease', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/releases`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {File} attachment attachment to upload
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateReleaseAttachment: async (owner: string, repo: string, id: number, attachment: File, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateReleaseAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateReleaseAttachment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoCreateReleaseAttachment', 'id', id)
            // verify required parameter 'attachment' is not null or undefined
            assertParamExists('repoCreateReleaseAttachment', 'attachment', attachment)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


            if (attachment !== undefined) { 
                localVarFormParams.append('attachment', attachment as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a commit status
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {CreateStatusOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateStatus: async (owner: string, repo: string, sha: string, body?: CreateStatusOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateStatus', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateStatus', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('repoCreateStatus', 'sha', sha)
            const localVarPath = `/repos/{owner}/{repo}/statuses/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new git tag in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateTagOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateTag: async (owner: string, repo: string, body?: CreateTagOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateTag', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateTag', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/tags`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateWikiPage: async (owner: string, repo: string, body?: CreateWikiPageOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateWikiPage', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateWikiPage', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/wiki/new`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a repository
         * @param {string} owner owner of the repo to delete
         * @param {string} repo name of the repo to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDelete: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDelete', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDelete', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete avatar
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteAvatar: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteAvatar', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteAvatar', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/avatar`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific branch from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteBranch: async (owner: string, repo: string, branch: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteBranch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteBranch', 'repo', repo)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('repoDeleteBranch', 'branch', branch)
            const localVarPath = `/repos/{owner}/{repo}/branches/{branch}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteBranchProtection: async (owner: string, repo: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteBranchProtection', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteBranchProtection', 'repo', repo)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('repoDeleteBranchProtection', 'name', name)
            const localVarPath = `/repos/{owner}/{repo}/branch_protections/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a collaborator from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteCollaborator: async (owner: string, repo: string, collaborator: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteCollaborator', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteCollaborator', 'repo', repo)
            // verify required parameter 'collaborator' is not null or undefined
            assertParamExists('repoDeleteCollaborator', 'collaborator', collaborator)
            const localVarPath = `/repos/{owner}/{repo}/collaborators/{collaborator}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"collaborator"}}`, encodeURIComponent(String(collaborator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to delete
         * @param {DeleteFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteFile: async (owner: string, repo: string, filepath: string, body: DeleteFileOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteFile', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteFile', 'repo', repo)
            // verify required parameter 'filepath' is not null or undefined
            assertParamExists('repoDeleteFile', 'filepath', filepath)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoDeleteFile', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/contents/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteGitHook: async (owner: string, repo: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteGitHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteGitHook', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoDeleteGitHook', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/hooks/git/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteHook: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteHook', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoDeleteHook', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/hooks/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a key from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteKey: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteKey', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteKey', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoDeleteKey', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/keys/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific review from a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeletePullReview: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeletePullReview', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeletePullReview', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoDeletePullReview', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoDeletePullReview', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary cancel review requests for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {PullReviewRequestOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeletePullReviewRequests: async (owner: string, repo: string, index: number, body: PullReviewRequestOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeletePullReviewRequests', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeletePullReviewRequests', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoDeletePullReviewRequests', 'index', index)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoDeletePullReviewRequests', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/requested_reviewers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deletes a push mirror from a repository by remoteName
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name remote name of the pushMirror
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeletePushMirror: async (owner: string, repo: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeletePushMirror', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeletePushMirror', 'repo', repo)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('repoDeletePushMirror', 'name', name)
            const localVarPath = `/repos/{owner}/{repo}/push_mirrors/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteRelease: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteRelease', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteRelease', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoDeleteRelease', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteReleaseAttachment: async (owner: string, repo: string, id: number, attachmentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteReleaseAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteReleaseAttachment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoDeleteReleaseAttachment', 'id', id)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('repoDeleteReleaseAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteReleaseByTag: async (owner: string, repo: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteReleaseByTag', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteReleaseByTag', 'repo', repo)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('repoDeleteReleaseByTag', 'tag', tag)
            const localVarPath = `/repos/{owner}/{repo}/releases/tags/{tag}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a repository\'s tag by name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTag: async (owner: string, repo: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteTag', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteTag', 'repo', repo)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('repoDeleteTag', 'tag', tag)
            const localVarPath = `/repos/{owner}/{repo}/tags/{tag}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a team from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTeam: async (owner: string, repo: string, team: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteTeam', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteTeam', 'repo', repo)
            // verify required parameter 'team' is not null or undefined
            assertParamExists('repoDeleteTeam', 'team', team)
            const localVarPath = `/repos/{owner}/{repo}/teams/{team}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a topic from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTopic: async (owner: string, repo: string, topic: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteTopic', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteTopic', 'repo', repo)
            // verify required parameter 'topic' is not null or undefined
            assertParamExists('repoDeleteTopic', 'topic', topic)
            const localVarPath = `/repos/{owner}/{repo}/topics/{topic}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteWikiPage: async (owner: string, repo: string, pageName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteWikiPage', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteWikiPage', 'repo', repo)
            // verify required parameter 'pageName' is not null or undefined
            assertParamExists('repoDeleteWikiPage', 'pageName', pageName)
            const localVarPath = `/repos/{owner}/{repo}/wiki/page/{pageName}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"pageName"}}`, encodeURIComponent(String(pageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {DismissPullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDismissPullReview: async (owner: string, repo: string, index: number, id: number, body: DismissPullReviewOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDismissPullReview', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDismissPullReview', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoDismissPullReview', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoDismissPullReview', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoDismissPullReview', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/dismissals`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a commit\'s diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha SHA of the commit to get
         * @param {RepoDownloadCommitDiffOrPatchDiffTypeEnum} diffType whether the output is diff or patch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDownloadCommitDiffOrPatch: async (owner: string, repo: string, sha: string, diffType: RepoDownloadCommitDiffOrPatchDiffTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDownloadCommitDiffOrPatch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDownloadCommitDiffOrPatch', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('repoDownloadCommitDiffOrPatch', 'sha', sha)
            // verify required parameter 'diffType' is not null or undefined
            assertParamExists('repoDownloadCommitDiffOrPatch', 'diffType', diffType)
            const localVarPath = `/repos/{owner}/{repo}/git/commits/{sha}.{diffType}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)))
                .replace(`{${"diffType"}}`, encodeURIComponent(String(diffType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a pull request diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {RepoDownloadPullDiffOrPatchDiffTypeEnum} diffType whether the output is diff or patch
         * @param {boolean} [binary] whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDownloadPullDiffOrPatch: async (owner: string, repo: string, index: number, diffType: RepoDownloadPullDiffOrPatchDiffTypeEnum, binary?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDownloadPullDiffOrPatch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDownloadPullDiffOrPatch', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoDownloadPullDiffOrPatch', 'index', index)
            // verify required parameter 'diffType' is not null or undefined
            assertParamExists('repoDownloadPullDiffOrPatch', 'diffType', diffType)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}.{diffType}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"diffType"}}`, encodeURIComponent(String(diffType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (binary !== undefined) {
                localVarQueryParameter['binary'] = binary;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a repository\'s properties. Only fields that are set will be changed.
         * @param {string} owner owner of the repo to edit
         * @param {string} repo name of the repo to edit
         * @param {EditRepoOption} [body] Properties of a repo that you can edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEdit: async (owner: string, repo: string, body?: EditRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEdit', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEdit', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a branch protections for a repository. Only fields that are set will be changed
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {EditBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditBranchProtection: async (owner: string, repo: string, name: string, body?: EditBranchProtectionOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEditBranchProtection', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEditBranchProtection', 'repo', repo)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('repoEditBranchProtection', 'name', name)
            const localVarPath = `/repos/{owner}/{repo}/branch_protections/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {EditGitHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditGitHook: async (owner: string, repo: string, id: string, body?: EditGitHookOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEditGitHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEditGitHook', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoEditGitHook', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/hooks/git/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id index of the hook
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditHook: async (owner: string, repo: string, id: number, body?: EditHookOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEditHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEditHook', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoEditHook', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/hooks/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to edit
         * @param {EditPullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditPullRequest: async (owner: string, repo: string, index: number, body?: EditPullRequestOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEditPullRequest', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEditPullRequest', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoEditPullRequest', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to edit
         * @param {EditReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditRelease: async (owner: string, repo: string, id: number, body?: EditReleaseOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEditRelease', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEditRelease', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoEditRelease', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditReleaseAttachment: async (owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEditReleaseAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEditReleaseAttachment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoEditReleaseAttachment', 'id', id)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('repoEditReleaseAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditWikiPage: async (owner: string, repo: string, pageName: string, body?: CreateWikiPageOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEditWikiPage', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEditWikiPage', 'repo', repo)
            // verify required parameter 'pageName' is not null or undefined
            assertParamExists('repoEditWikiPage', 'pageName', pageName)
            const localVarPath = `/repos/{owner}/{repo}/wiki/page/{pageName}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"pageName"}}`, encodeURIComponent(String(pageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGet: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGet', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGet', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all commits from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [sha] SHA or branch to start listing commits from (usually \&#39;master\&#39;)
         * @param {string} [path] filepath of a file/dir
         * @param {boolean} [stat] include diff stats for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results (ignored if used with \&#39;path\&#39;)
         * @param {string} [not] commits that match the given specifier will not be listed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetAllCommits: async (owner: string, repo: string, sha?: string, path?: string, stat?: boolean, verification?: boolean, files?: boolean, page?: number, limit?: number, not?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetAllCommits', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetAllCommits', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/commits`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (sha !== undefined) {
                localVarQueryParameter['sha'] = sha;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (stat !== undefined) {
                localVarQueryParameter['stat'] = stat;
            }

            if (verification !== undefined) {
                localVarQueryParameter['verification'] = verification;
            }

            if (files !== undefined) {
                localVarQueryParameter['files'] = files;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (not !== undefined) {
                localVarQueryParameter['not'] = not;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an archive of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} archive the git reference for download with attached archive format (e.g. master.zip)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetArchive: async (owner: string, repo: string, archive: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetArchive', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetArchive', 'repo', repo)
            // verify required parameter 'archive' is not null or undefined
            assertParamExists('repoGetArchive', 'archive', archive)
            const localVarPath = `/repos/{owner}/{repo}/archive/{archive}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"archive"}}`, encodeURIComponent(String(archive)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return all users that have write access and can be assigned to issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetAssignees: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetAssignees', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetAssignees', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/assignees`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a specific branch from a repository, including its effective branch protection
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetBranch: async (owner: string, repo: string, branch: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetBranch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetBranch', 'repo', repo)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('repoGetBranch', 'branch', branch)
            const localVarPath = `/repos/{owner}/{repo}/branches/{branch}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetBranchProtection: async (owner: string, repo: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetBranchProtection', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetBranchProtection', 'repo', repo)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('repoGetBranchProtection', 'name', name)
            const localVarPath = `/repos/{owner}/{repo}/branch_protections/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a repository by id
         * @param {number} id id of the repo to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetByID: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetByID', 'id', id)
            const localVarPath = `/repositories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a commit\'s combined status, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetCombinedStatusByRef: async (owner: string, repo: string, ref: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetCombinedStatusByRef', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetCombinedStatusByRef', 'repo', repo)
            // verify required parameter 'ref' is not null or undefined
            assertParamExists('repoGetCombinedStatusByRef', 'ref', ref)
            const localVarPath = `/repos/{owner}/{repo}/commits/{ref}/status`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"ref"}}`, encodeURIComponent(String(ref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the dir, file, symlink or submodule in the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetContents: async (owner: string, repo: string, filepath: string, ref?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetContents', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetContents', 'repo', repo)
            // verify required parameter 'filepath' is not null or undefined
            assertParamExists('repoGetContents', 'filepath', filepath)
            const localVarPath = `/repos/{owner}/{repo}/contents/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the metadata of all the entries of the root dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetContentsList: async (owner: string, repo: string, ref?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetContentsList', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetContentsList', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/contents`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the EditorConfig definitions of a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetEditorConfig: async (owner: string, repo: string, filepath: string, ref?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetEditorConfig', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetEditorConfig', 'repo', repo)
            // verify required parameter 'filepath' is not null or undefined
            assertParamExists('repoGetEditorConfig', 'filepath', filepath)
            const localVarPath = `/repos/{owner}/{repo}/editorconfig/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Git hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetGitHook: async (owner: string, repo: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetGitHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetGitHook', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetGitHook', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/hooks/git/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetHook: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetHook', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetHook', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/hooks/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the issue config for a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetIssueConfig: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetIssueConfig', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetIssueConfig', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/issue_config`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get available issue templates for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetIssueTemplates: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetIssueTemplates', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetIssueTemplates', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/issue_templates`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a repository\'s key by id
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetKey: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetKey', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetKey', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetKey', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/keys/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get languages and number of bytes of code written
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetLanguages: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetLanguages', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetLanguages', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/languages`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetLatestRelease: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetLatestRelease', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetLatestRelease', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/releases/latest`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a note corresponding to a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetNote: async (owner: string, repo: string, sha: string, verification?: boolean, files?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetNote', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetNote', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('repoGetNote', 'sha', sha)
            const localVarPath = `/repos/{owner}/{repo}/git/notes/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (verification !== undefined) {
                localVarQueryParameter['verification'] = verification;
            }

            if (files !== undefined) {
                localVarQueryParameter['files'] = files;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullRequest: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetPullRequest', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetPullRequest', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoGetPullRequest', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get commits for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullRequestCommits: async (owner: string, repo: string, index: number, page?: number, limit?: number, verification?: boolean, files?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetPullRequestCommits', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetPullRequestCommits', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoGetPullRequestCommits', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/commits`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (verification !== undefined) {
                localVarQueryParameter['verification'] = verification;
            }

            if (files !== undefined) {
                localVarQueryParameter['files'] = files;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get changed files for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {string} [skipTo] skip to given file
         * @param {RepoGetPullRequestFilesWhitespaceEnum} [whitespace] whitespace behavior
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullRequestFiles: async (owner: string, repo: string, index: number, skipTo?: string, whitespace?: RepoGetPullRequestFilesWhitespaceEnum, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetPullRequestFiles', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetPullRequestFiles', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoGetPullRequestFiles', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/files`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (skipTo !== undefined) {
                localVarQueryParameter['skip-to'] = skipTo;
            }

            if (whitespace !== undefined) {
                localVarQueryParameter['whitespace'] = whitespace;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullReview: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetPullReview', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetPullReview', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoGetPullReview', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetPullReview', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullReviewComments: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetPullReviewComments', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetPullReviewComments', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoGetPullReviewComments', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetPullReviewComments', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/comments`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get push mirror of the repository by remoteName
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name remote name of push mirror
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPushMirrorByRemoteName: async (owner: string, repo: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetPushMirrorByRemoteName', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetPushMirrorByRemoteName', 'repo', repo)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('repoGetPushMirrorByRemoteName', 'name', name)
            const localVarPath = `/repos/{owner}/{repo}/push_mirrors/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a file from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRawFile: async (owner: string, repo: string, filepath: string, ref?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetRawFile', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetRawFile', 'repo', repo)
            // verify required parameter 'filepath' is not null or undefined
            assertParamExists('repoGetRawFile', 'filepath', filepath)
            const localVarPath = `/repos/{owner}/{repo}/raw/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a file or it\'s LFS object from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRawFileOrLFS: async (owner: string, repo: string, filepath: string, ref?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetRawFileOrLFS', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetRawFileOrLFS', 'repo', repo)
            // verify required parameter 'filepath' is not null or undefined
            assertParamExists('repoGetRawFileOrLFS', 'filepath', filepath)
            const localVarPath = `/repos/{owner}/{repo}/media/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRelease: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetRelease', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetRelease', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetRelease', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReleaseAttachment: async (owner: string, repo: string, id: number, attachmentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetReleaseAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetReleaseAttachment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetReleaseAttachment', 'id', id)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('repoGetReleaseAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReleaseByTag: async (owner: string, repo: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetReleaseByTag', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetReleaseByTag', 'repo', repo)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('repoGetReleaseByTag', 'tag', tag)
            const localVarPath = `/repos/{owner}/{repo}/releases/tags/{tag}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get repository permissions for a user
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRepoPermissions: async (owner: string, repo: string, collaborator: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetRepoPermissions', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetRepoPermissions', 'repo', repo)
            // verify required parameter 'collaborator' is not null or undefined
            assertParamExists('repoGetRepoPermissions', 'collaborator', collaborator)
            const localVarPath = `/repos/{owner}/{repo}/collaborators/{collaborator}/permission`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"collaborator"}}`, encodeURIComponent(String(collaborator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return all users that can be requested to review in this repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReviewers: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetReviewers', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetReviewers', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/reviewers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {boolean} [stat] include diff stats for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetSingleCommit: async (owner: string, repo: string, sha: string, stat?: boolean, verification?: boolean, files?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetSingleCommit', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetSingleCommit', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('repoGetSingleCommit', 'sha', sha)
            const localVarPath = `/repos/{owner}/{repo}/git/commits/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (stat !== undefined) {
                localVarQueryParameter['stat'] = stat;
            }

            if (verification !== undefined) {
                localVarQueryParameter['verification'] = verification;
            }

            if (files !== undefined) {
                localVarQueryParameter['files'] = files;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the tag of a repository by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetTag: async (owner: string, repo: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetTag', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetTag', 'repo', repo)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('repoGetTag', 'tag', tag)
            const localVarPath = `/repos/{owner}/{repo}/tags/{tag}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetWikiPage: async (owner: string, repo: string, pageName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetWikiPage', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetWikiPage', 'repo', repo)
            // verify required parameter 'pageName' is not null or undefined
            assertParamExists('repoGetWikiPage', 'pageName', pageName)
            const localVarPath = `/repos/{owner}/{repo}/wiki/page/{pageName}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"pageName"}}`, encodeURIComponent(String(pageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get revisions of a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {number} [page] page number of results to return (1-based)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetWikiPageRevisions: async (owner: string, repo: string, pageName: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetWikiPageRevisions', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetWikiPageRevisions', 'repo', repo)
            // verify required parameter 'pageName' is not null or undefined
            assertParamExists('repoGetWikiPageRevisions', 'pageName', pageName)
            const localVarPath = `/repos/{owner}/{repo}/wiki/revisions/{pageName}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"pageName"}}`, encodeURIComponent(String(pageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all wiki pages
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetWikiPages: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetWikiPages', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetWikiPages', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/wiki/pages`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s activity feeds
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [date] the date of the activities to be found
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListActivityFeeds: async (owner: string, repo: string, date?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListActivityFeeds', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListActivityFeeds', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/activities/feeds`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substring(0,10) :
                    date;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get specified ref or filtered repository\'s refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListAllGitRefs: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListAllGitRefs', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListAllGitRefs', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/git/refs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListBranchProtection: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListBranchProtection', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListBranchProtection', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/branch_protections`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s branches
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListBranches: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListBranches', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListBranches', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/branches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s collaborators
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListCollaborators: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListCollaborators', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListCollaborators', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/collaborators`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the Git hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListGitHooks: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListGitHooks', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListGitHooks', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/hooks/git`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get specified ref or filtered repository\'s refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref part or full name of the ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListGitRefs: async (owner: string, repo: string, ref: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListGitRefs', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListGitRefs', 'repo', repo)
            // verify required parameter 'ref' is not null or undefined
            assertParamExists('repoListGitRefs', 'ref', ref)
            const localVarPath = `/repos/{owner}/{repo}/git/refs/{ref}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"ref"}}`, encodeURIComponent(String(ref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListHooks: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListHooks', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListHooks', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/hooks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s keys
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [keyId] the key_id to search for
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListKeys: async (owner: string, repo: string, keyId?: number, fingerprint?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListKeys', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListKeys', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/keys`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (keyId !== undefined) {
                localVarQueryParameter['key_id'] = keyId;
            }

            if (fingerprint !== undefined) {
                localVarQueryParameter['fingerprint'] = fingerprint;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo\'s pinned issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPinnedIssues: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListPinnedIssues', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListPinnedIssues', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/issues/pinned`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo\'s pinned pull requests
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPinnedPullRequests: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListPinnedPullRequests', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListPinnedPullRequests', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/pulls/pinned`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo\'s pull requests
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {RepoListPullRequestsStateEnum} [state] State of pull request: open or closed (optional)
         * @param {RepoListPullRequestsSortEnum} [sort] Type of sort
         * @param {number} [milestone] ID of the milestone
         * @param {Array<number>} [labels] Label IDs
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPullRequests: async (owner: string, repo: string, state?: RepoListPullRequestsStateEnum, sort?: RepoListPullRequestsSortEnum, milestone?: number, labels?: Array<number>, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListPullRequests', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListPullRequests', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/pulls`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (milestone !== undefined) {
                localVarQueryParameter['milestone'] = milestone;
            }

            if (labels) {
                localVarQueryParameter['labels'] = labels;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all reviews for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPullReviews: async (owner: string, repo: string, index: number, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListPullReviews', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListPullReviews', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoListPullReviews', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all push mirrors of the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPushMirrors: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListPushMirrors', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListPushMirrors', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/push_mirrors`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List release\'s attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListReleaseAttachments: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListReleaseAttachments', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListReleaseAttachments', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoListReleaseAttachments', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo\'s releases
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {boolean} [draft] filter (exclude / include) drafts, if you dont have repo write access none will show
         * @param {boolean} [preRelease] filter (exclude / include) pre-releases
         * @param {number} [perPage] page size of results, deprecated - use limit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListReleases: async (owner: string, repo: string, draft?: boolean, preRelease?: boolean, perPage?: number, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListReleases', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListReleases', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/releases`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (draft !== undefined) {
                localVarQueryParameter['draft'] = draft;
            }

            if (preRelease !== undefined) {
                localVarQueryParameter['pre-release'] = preRelease;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo\'s stargazers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStargazers: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListStargazers', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListStargazers', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/stargazers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a commit\'s statuses
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {RepoListStatusesSortEnum} [sort] type of sort
         * @param {RepoListStatusesStateEnum} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStatuses: async (owner: string, repo: string, sha: string, sort?: RepoListStatusesSortEnum, state?: RepoListStatusesStateEnum, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListStatuses', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListStatuses', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('repoListStatuses', 'sha', sha)
            const localVarPath = `/repos/{owner}/{repo}/statuses/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a commit\'s statuses, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {RepoListStatusesByRefSortEnum} [sort] type of sort
         * @param {RepoListStatusesByRefStateEnum} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStatusesByRef: async (owner: string, repo: string, ref: string, sort?: RepoListStatusesByRefSortEnum, state?: RepoListStatusesByRefStateEnum, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListStatusesByRef', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListStatusesByRef', 'repo', repo)
            // verify required parameter 'ref' is not null or undefined
            assertParamExists('repoListStatusesByRef', 'ref', ref)
            const localVarPath = `/repos/{owner}/{repo}/commits/{ref}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"ref"}}`, encodeURIComponent(String(ref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo\'s watchers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListSubscribers: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListSubscribers', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListSubscribers', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/subscribers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s tags
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results, default maximum page size is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTags: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListTags', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListTags', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/tags`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s teams
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTeams: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListTeams', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListTeams', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/teams`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of topics that a repository has
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTopics: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListTopics', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListTopics', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/topics`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Merge a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {MergePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMergePullRequest: async (owner: string, repo: string, index: number, body?: MergePullRequestOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoMergePullRequest', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoMergePullRequest', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoMergePullRequest', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/merge`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Migrate a remote git repository
         * @param {MigrateRepoOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMigrate: async (body?: MigrateRepoOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/repos/migrate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sync a mirrored repository
         * @param {string} owner owner of the repo to sync
         * @param {string} repo name of the repo to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMirrorSync: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoMirrorSync', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoMirrorSync', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/mirror-sync`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns if new Issue Pins are allowed
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoNewPinAllowed: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoNewPinAllowed', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoNewPinAllowed', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/new_pin_allowed`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if a pull request has been merged
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoPullRequestIsMerged: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoPullRequestIsMerged', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoPullRequestIsMerged', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoPullRequestIsMerged', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/merge`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sync all push mirrored repository
         * @param {string} owner owner of the repo to sync
         * @param {string} repo name of the repo to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoPushMirrorSync: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoPushMirrorSync', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoPushMirrorSync', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/push_mirrors-sync`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for repositories
         * @param {string} [q] keyword
         * @param {boolean} [topic] Limit search to repositories with keyword as topic
         * @param {boolean} [includeDesc] include search of keyword within repository description
         * @param {number} [uid] search only for repos that the user with the given id owns or contributes to
         * @param {number} [priorityOwnerId] repo owner to prioritize in the results
         * @param {number} [teamId] search only for repos that belong to the given team id
         * @param {number} [starredBy] search only for repos that the user with the given id has starred
         * @param {boolean} [_private] include private repositories this user has access to (defaults to true)
         * @param {boolean} [isPrivate] show only pubic, private or all repositories (defaults to all)
         * @param {boolean} [template] include template repositories this user has access to (defaults to true)
         * @param {boolean} [archived] show only archived, non-archived or all repositories (defaults to all)
         * @param {string} [mode] type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
         * @param {boolean} [exclusive] if &#x60;uid&#x60; is given, search only for repos that the user owns
         * @param {string} [sort] sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
         * @param {string} [order] sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSearch: async (q?: string, topic?: boolean, includeDesc?: boolean, uid?: number, priorityOwnerId?: number, teamId?: number, starredBy?: number, _private?: boolean, isPrivate?: boolean, template?: boolean, archived?: boolean, mode?: string, exclusive?: boolean, sort?: string, order?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/repos/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (topic !== undefined) {
                localVarQueryParameter['topic'] = topic;
            }

            if (includeDesc !== undefined) {
                localVarQueryParameter['includeDesc'] = includeDesc;
            }

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }

            if (priorityOwnerId !== undefined) {
                localVarQueryParameter['priority_owner_id'] = priorityOwnerId;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (starredBy !== undefined) {
                localVarQueryParameter['starredBy'] = starredBy;
            }

            if (_private !== undefined) {
                localVarQueryParameter['private'] = _private;
            }

            if (isPrivate !== undefined) {
                localVarQueryParameter['is_private'] = isPrivate;
            }

            if (template !== undefined) {
                localVarQueryParameter['template'] = template;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (exclusive !== undefined) {
                localVarQueryParameter['exclusive'] = exclusive;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get signing-key.gpg for given repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSigningKey: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoSigningKey', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoSigningKey', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/signing-key.gpg`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit a pending review to an pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {SubmitPullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSubmitPullReview: async (owner: string, repo: string, index: number, id: number, body: SubmitPullReviewOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoSubmitPullReview', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoSubmitPullReview', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoSubmitPullReview', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoSubmitPullReview', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoSubmitPullReview', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test a push webhook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to test
         * @param {string} [ref] The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTestHook: async (owner: string, repo: string, id: number, ref?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoTestHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoTestHook', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoTestHook', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/hooks/{id}/tests`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo\'s tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTrackedTimes: async (owner: string, repo: string, user?: string, since?: string, before?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoTrackedTimes', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoTrackedTimes', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/times`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transfer a repo ownership
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {TransferRepoOption} body Transfer Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTransfer: async (owner: string, repo: string, body: TransferRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoTransfer', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoTransfer', 'repo', repo)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoTransfer', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/transfer`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel to dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUnDismissPullReview: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoUnDismissPullReview', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoUnDismissPullReview', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoUnDismissPullReview', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoUnDismissPullReview', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/undismissals`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update avatar
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {UpdateRepoAvatarOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdateAvatar: async (owner: string, repo: string, body?: UpdateRepoAvatarOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoUpdateAvatar', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoUpdateAvatar', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/avatar`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to update
         * @param {UpdateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdateFile: async (owner: string, repo: string, filepath: string, body: UpdateFileOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoUpdateFile', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoUpdateFile', 'repo', repo)
            // verify required parameter 'filepath' is not null or undefined
            assertParamExists('repoUpdateFile', 'filepath', filepath)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoUpdateFile', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/contents/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Merge PR\'s baseBranch into headBranch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {RepoUpdatePullRequestStyleEnum} [style] how to update pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdatePullRequest: async (owner: string, repo: string, index: number, style?: RepoUpdatePullRequestStyleEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoUpdatePullRequest', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoUpdatePullRequest', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoUpdatePullRequest', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/update`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (style !== undefined) {
                localVarQueryParameter['style'] = style;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace list of topics for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {RepoTopicOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdateTopics: async (owner: string, repo: string, body?: RepoTopicOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoUpdateTopics', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoUpdateTopics', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/topics`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the validation information for a issue config
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoValidateIssueConfig: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoValidateIssueConfig', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoValidateIssueConfig', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/issue_config/validate`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary search topics via keyword
         * @param {string} q keywords to search
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicSearch: async (q: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('topicSearch', 'q', q)
            const localVarPath = `/topics/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create or Update a secret value in a repository
         * @param {string} owner owner of the repository
         * @param {string} repo name of the repository
         * @param {string} secretname name of the secret
         * @param {CreateOrUpdateSecretOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepoSecret: async (owner: string, repo: string, secretname: string, body?: CreateOrUpdateSecretOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('updateRepoSecret', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('updateRepoSecret', 'repo', repo)
            // verify required parameter 'secretname' is not null or undefined
            assertParamExists('updateRepoSecret', 'secretname', secretname)
            const localVarPath = `/repos/{owner}/{repo}/actions/secrets/{secretname}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"secretname"}}`, encodeURIComponent(String(secretname)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if the current user is watching a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentCheckSubscription: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('userCurrentCheckSubscription', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('userCurrentCheckSubscription', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/subscription`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unwatch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteSubscription: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('userCurrentDeleteSubscription', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('userCurrentDeleteSubscription', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/subscription`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Watch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPutSubscription: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('userCurrentPutSubscription', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('userCurrentPutSubscription', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/subscription`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a user\'s tracked times in a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} user username of user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        userTrackedTimes: async (owner: string, repo: string, user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('userTrackedTimes', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('userTrackedTimes', 'repo', repo)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('userTrackedTimes', 'user', user)
            const localVarPath = `/repos/{owner}/{repo}/times/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoryApi - functional programming interface
 * @export
 */
export const RepositoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Accept a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptRepoTransfer(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptRepoTransfer(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a repository
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCurrentUserRepo(body?: CreateRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCurrentUserRepo(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fork a repository
         * @param {string} owner owner of the repo to fork
         * @param {string} repo name of the repo to fork
         * @param {CreateForkOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFork(owner: string, repo: string, body?: CreateForkOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFork(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a secret in a repository
         * @param {string} owner owner of the repository
         * @param {string} repo name of the repository
         * @param {string} secretname name of the secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepoSecret(owner: string, repo: string, secretname: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepoSecret(owner, repo, secretname, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a repository using a template
         * @param {string} templateOwner name of the template repository owner
         * @param {string} templateRepo name of the template repository
         * @param {GenerateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateRepo(templateOwner: string, templateRepo: string, body?: GenerateRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateRepo(templateOwner, templateRepo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the tag object of an annotated tag (not lightweight tags)
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnotatedTag(owner: string, repo: string, sha: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotatedTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnotatedTag(owner, repo, sha, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the blob of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlob(owner: string, repo: string, sha: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitBlobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlob(owner, repo, sha, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the tree of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {boolean} [recursive] show all directories and files
         * @param {number} [page] page number; the \&#39;truncated\&#39; field in the response will be true if there are still more items after this page, false if the last page
         * @param {number} [perPage] number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTree(owner: string, repo: string, sha: string, recursive?: boolean, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitTreeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTree(owner, repo, sha, recursive, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s forks
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listForks(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listForks(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reject a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectRepoTransfer(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectRepoTransfer(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a collaborator to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to add
         * @param {AddCollaboratorOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoAddCollaborator(owner: string, repo: string, collaborator: string, body?: AddCollaboratorOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoAddCollaborator(owner, repo, collaborator, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary add a push mirror to the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreatePushMirrorOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoAddPushMirror(owner: string, repo: string, body?: CreatePushMirrorOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PushMirror>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoAddPushMirror(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a team to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoAddTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoAddTeam(owner, repo, team, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a topic to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoAddTopic(owner: string, repo: string, topic: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoAddTopic(owner, repo, topic, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Apply diff patch to repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {UpdateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoApplyDiffPatch(owner: string, repo: string, body: UpdateFileOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoApplyDiffPatch(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Cancel the scheduled auto merge for the given pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCancelScheduledAutoMerge(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCancelScheduledAutoMerge(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify multiple files in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {ChangeFilesOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoChangeFiles(owner: string, repo: string, body: ChangeFilesOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoChangeFiles(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if a user is a collaborator of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCheckCollaborator(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCheckCollaborator(owner, repo, collaborator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if a team is assigned to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCheckTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCheckTeam(owner, repo, team, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a branch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateBranch(owner: string, repo: string, body?: CreateBranchRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateBranch(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateBranchProtection(owner: string, repo: string, body?: CreateBranchProtectionOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchProtection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateBranchProtection(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to create
         * @param {CreateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateFile(owner: string, repo: string, filepath: string, body: CreateFileOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateFile(owner, repo, filepath, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateHook(owner: string, repo: string, body?: CreateHookOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateHook(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a key to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateKeyOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateKey(owner: string, repo: string, body?: CreateKeyOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateKey(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreatePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreatePullRequest(owner: string, repo: string, body?: CreatePullRequestOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreatePullRequest(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a review to an pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {CreatePullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreatePullReview(owner: string, repo: string, index: number, body: CreatePullReviewOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreatePullReview(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary create review requests for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {PullReviewRequestOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreatePullReviewRequests(owner: string, repo: string, index: number, body: PullReviewRequestOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullReview>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreatePullReviewRequests(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateRelease(owner: string, repo: string, body?: CreateReleaseOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Release>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateRelease(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {File} attachment attachment to upload
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateReleaseAttachment(owner: string, repo: string, id: number, attachment: File, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateReleaseAttachment(owner, repo, id, attachment, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a commit status
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {CreateStatusOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateStatus(owner: string, repo: string, sha: string, body?: CreateStatusOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateStatus(owner, repo, sha, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new git tag in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateTagOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateTag(owner: string, repo: string, body?: CreateTagOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateTag(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateWikiPage(owner: string, repo: string, body?: CreateWikiPageOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WikiPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateWikiPage(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a repository
         * @param {string} owner owner of the repo to delete
         * @param {string} repo name of the repo to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDelete(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDelete(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete avatar
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteAvatar(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteAvatar(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a specific branch from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteBranch(owner: string, repo: string, branch: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteBranch(owner, repo, branch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteBranchProtection(owner: string, repo: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteBranchProtection(owner, repo, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a collaborator from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteCollaborator(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteCollaborator(owner, repo, collaborator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to delete
         * @param {DeleteFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteFile(owner: string, repo: string, filepath: string, body: DeleteFileOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteFile(owner, repo, filepath, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteGitHook(owner: string, repo: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteGitHook(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteHook(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a key from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteKey(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteKey(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a specific review from a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeletePullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeletePullReview(owner, repo, index, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary cancel review requests for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {PullReviewRequestOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeletePullReviewRequests(owner: string, repo: string, index: number, body: PullReviewRequestOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeletePullReviewRequests(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deletes a push mirror from a repository by remoteName
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name remote name of the pushMirror
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeletePushMirror(owner: string, repo: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeletePushMirror(owner, repo, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteRelease(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteRelease(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteReleaseAttachment(owner, repo, id, attachmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteReleaseByTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteReleaseByTag(owner, repo, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a repository\'s tag by name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteTag(owner, repo, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a team from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteTeam(owner, repo, team, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a topic from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteTopic(owner: string, repo: string, topic: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteTopic(owner, repo, topic, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteWikiPage(owner: string, repo: string, pageName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteWikiPage(owner, repo, pageName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {DismissPullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDismissPullReview(owner: string, repo: string, index: number, id: number, body: DismissPullReviewOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDismissPullReview(owner, repo, index, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a commit\'s diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha SHA of the commit to get
         * @param {RepoDownloadCommitDiffOrPatchDiffTypeEnum} diffType whether the output is diff or patch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDownloadCommitDiffOrPatch(owner: string, repo: string, sha: string, diffType: RepoDownloadCommitDiffOrPatchDiffTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDownloadCommitDiffOrPatch(owner, repo, sha, diffType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a pull request diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {RepoDownloadPullDiffOrPatchDiffTypeEnum} diffType whether the output is diff or patch
         * @param {boolean} [binary] whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDownloadPullDiffOrPatch(owner: string, repo: string, index: number, diffType: RepoDownloadPullDiffOrPatchDiffTypeEnum, binary?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDownloadPullDiffOrPatch(owner, repo, index, diffType, binary, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a repository\'s properties. Only fields that are set will be changed.
         * @param {string} owner owner of the repo to edit
         * @param {string} repo name of the repo to edit
         * @param {EditRepoOption} [body] Properties of a repo that you can edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEdit(owner: string, repo: string, body?: EditRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEdit(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a branch protections for a repository. Only fields that are set will be changed
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {EditBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditBranchProtection(owner: string, repo: string, name: string, body?: EditBranchProtectionOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchProtection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEditBranchProtection(owner, repo, name, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {EditGitHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditGitHook(owner: string, repo: string, id: string, body?: EditGitHookOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitHook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEditGitHook(owner, repo, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id index of the hook
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditHook(owner: string, repo: string, id: number, body?: EditHookOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEditHook(owner, repo, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to edit
         * @param {EditPullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditPullRequest(owner: string, repo: string, index: number, body?: EditPullRequestOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEditPullRequest(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to edit
         * @param {EditReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditRelease(owner: string, repo: string, id: number, body?: EditReleaseOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Release>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEditRelease(owner, repo, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEditReleaseAttachment(owner, repo, id, attachmentId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditWikiPage(owner: string, repo: string, pageName: string, body?: CreateWikiPageOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WikiPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEditWikiPage(owner, repo, pageName, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGet(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGet(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of all commits from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [sha] SHA or branch to start listing commits from (usually \&#39;master\&#39;)
         * @param {string} [path] filepath of a file/dir
         * @param {boolean} [stat] include diff stats for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results (ignored if used with \&#39;path\&#39;)
         * @param {string} [not] commits that match the given specifier will not be listed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetAllCommits(owner: string, repo: string, sha?: string, path?: string, stat?: boolean, verification?: boolean, files?: boolean, page?: number, limit?: number, not?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Commit>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetAllCommits(owner, repo, sha, path, stat, verification, files, page, limit, not, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an archive of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} archive the git reference for download with attached archive format (e.g. master.zip)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetArchive(owner: string, repo: string, archive: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetArchive(owner, repo, archive, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return all users that have write access and can be assigned to issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetAssignees(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetAssignees(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a specific branch from a repository, including its effective branch protection
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetBranch(owner: string, repo: string, branch: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetBranch(owner, repo, branch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetBranchProtection(owner: string, repo: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchProtection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetBranchProtection(owner, repo, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a repository by id
         * @param {number} id id of the repo to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetByID(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetByID(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a commit\'s combined status, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetCombinedStatusByRef(owner: string, repo: string, ref: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CombinedStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetCombinedStatusByRef(owner, repo, ref, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the dir, file, symlink or submodule in the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetContents(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetContents(owner, repo, filepath, ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the metadata of all the entries of the root dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetContentsList(owner: string, repo: string, ref?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContentsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetContentsList(owner, repo, ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the EditorConfig definitions of a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetEditorConfig(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetEditorConfig(owner, repo, filepath, ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Git hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetGitHook(owner: string, repo: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitHook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetGitHook(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetHook(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the issue config for a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetIssueConfig(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IssueConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetIssueConfig(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get available issue templates for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetIssueTemplates(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IssueTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetIssueTemplates(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a repository\'s key by id
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetKey(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetKey(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get languages and number of bytes of code written
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetLanguages(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetLanguages(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetLatestRelease(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Release>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetLatestRelease(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a note corresponding to a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetNote(owner: string, repo: string, sha: string, verification?: boolean, files?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Note>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetNote(owner, repo, sha, verification, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullRequest(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetPullRequest(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get commits for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullRequestCommits(owner: string, repo: string, index: number, page?: number, limit?: number, verification?: boolean, files?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Commit>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetPullRequestCommits(owner, repo, index, page, limit, verification, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get changed files for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {string} [skipTo] skip to given file
         * @param {RepoGetPullRequestFilesWhitespaceEnum} [whitespace] whitespace behavior
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullRequestFiles(owner: string, repo: string, index: number, skipTo?: string, whitespace?: RepoGetPullRequestFilesWhitespaceEnum, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChangedFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetPullRequestFiles(owner, repo, index, skipTo, whitespace, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetPullReview(owner, repo, index, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullReviewComments(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullReviewComment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetPullReviewComments(owner, repo, index, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get push mirror of the repository by remoteName
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name remote name of push mirror
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPushMirrorByRemoteName(owner: string, repo: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PushMirror>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetPushMirrorByRemoteName(owner, repo, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a file from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetRawFile(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetRawFile(owner, repo, filepath, ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a file or it\'s LFS object from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetRawFileOrLFS(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetRawFileOrLFS(owner, repo, filepath, ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetRelease(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Release>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetRelease(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetReleaseAttachment(owner, repo, id, attachmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetReleaseByTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Release>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetReleaseByTag(owner, repo, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get repository permissions for a user
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetRepoPermissions(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepoCollaboratorPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetRepoPermissions(owner, repo, collaborator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return all users that can be requested to review in this repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetReviewers(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetReviewers(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {boolean} [stat] include diff stats for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetSingleCommit(owner: string, repo: string, sha: string, stat?: boolean, verification?: boolean, files?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Commit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetSingleCommit(owner, repo, sha, stat, verification, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the tag of a repository by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetTag(owner, repo, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetWikiPage(owner: string, repo: string, pageName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WikiPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetWikiPage(owner, repo, pageName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get revisions of a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {number} [page] page number of results to return (1-based)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetWikiPageRevisions(owner: string, repo: string, pageName: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WikiCommitList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetWikiPageRevisions(owner, repo, pageName, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all wiki pages
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetWikiPages(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WikiPageMetaData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetWikiPages(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s activity feeds
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [date] the date of the activities to be found
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListActivityFeeds(owner: string, repo: string, date?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Activity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListActivityFeeds(owner, repo, date, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get specified ref or filtered repository\'s refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListAllGitRefs(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reference>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListAllGitRefs(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListBranchProtection(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BranchProtection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListBranchProtection(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s branches
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListBranches(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Branch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListBranches(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s collaborators
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListCollaborators(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListCollaborators(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the Git hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListGitHooks(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GitHook>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListGitHooks(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get specified ref or filtered repository\'s refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref part or full name of the ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListGitRefs(owner: string, repo: string, ref: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reference>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListGitRefs(owner, repo, ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListHooks(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hook>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListHooks(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s keys
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [keyId] the key_id to search for
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListKeys(owner: string, repo: string, keyId?: number, fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeployKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListKeys(owner, repo, keyId, fingerprint, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repo\'s pinned issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListPinnedIssues(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Issue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListPinnedIssues(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repo\'s pinned pull requests
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListPinnedPullRequests(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullRequest>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListPinnedPullRequests(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repo\'s pull requests
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {RepoListPullRequestsStateEnum} [state] State of pull request: open or closed (optional)
         * @param {RepoListPullRequestsSortEnum} [sort] Type of sort
         * @param {number} [milestone] ID of the milestone
         * @param {Array<number>} [labels] Label IDs
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListPullRequests(owner: string, repo: string, state?: RepoListPullRequestsStateEnum, sort?: RepoListPullRequestsSortEnum, milestone?: number, labels?: Array<number>, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullRequest>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListPullRequests(owner, repo, state, sort, milestone, labels, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all reviews for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListPullReviews(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullReview>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListPullReviews(owner, repo, index, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all push mirrors of the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListPushMirrors(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PushMirror>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListPushMirrors(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List release\'s attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListReleaseAttachments(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Attachment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListReleaseAttachments(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repo\'s releases
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {boolean} [draft] filter (exclude / include) drafts, if you dont have repo write access none will show
         * @param {boolean} [preRelease] filter (exclude / include) pre-releases
         * @param {number} [perPage] page size of results, deprecated - use limit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListReleases(owner: string, repo: string, draft?: boolean, preRelease?: boolean, perPage?: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Release>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListReleases(owner, repo, draft, preRelease, perPage, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repo\'s stargazers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListStargazers(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListStargazers(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a commit\'s statuses
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {RepoListStatusesSortEnum} [sort] type of sort
         * @param {RepoListStatusesStateEnum} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListStatuses(owner: string, repo: string, sha: string, sort?: RepoListStatusesSortEnum, state?: RepoListStatusesStateEnum, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommitStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListStatuses(owner, repo, sha, sort, state, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a commit\'s statuses, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {RepoListStatusesByRefSortEnum} [sort] type of sort
         * @param {RepoListStatusesByRefStateEnum} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListStatusesByRef(owner: string, repo: string, ref: string, sort?: RepoListStatusesByRefSortEnum, state?: RepoListStatusesByRefStateEnum, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommitStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListStatusesByRef(owner, repo, ref, sort, state, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repo\'s watchers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListSubscribers(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListSubscribers(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s tags
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results, default maximum page size is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListTags(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListTags(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s teams
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListTeams(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Team>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListTeams(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get list of topics that a repository has
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListTopics(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopicName>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListTopics(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Merge a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {MergePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoMergePullRequest(owner: string, repo: string, index: number, body?: MergePullRequestOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoMergePullRequest(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Migrate a remote git repository
         * @param {MigrateRepoOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoMigrate(body?: MigrateRepoOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoMigrate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sync a mirrored repository
         * @param {string} owner owner of the repo to sync
         * @param {string} repo name of the repo to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoMirrorSync(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoMirrorSync(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns if new Issue Pins are allowed
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoNewPinAllowed(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewIssuePinsAllowed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoNewPinAllowed(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if a pull request has been merged
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoPullRequestIsMerged(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoPullRequestIsMerged(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sync all push mirrored repository
         * @param {string} owner owner of the repo to sync
         * @param {string} repo name of the repo to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoPushMirrorSync(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoPushMirrorSync(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search for repositories
         * @param {string} [q] keyword
         * @param {boolean} [topic] Limit search to repositories with keyword as topic
         * @param {boolean} [includeDesc] include search of keyword within repository description
         * @param {number} [uid] search only for repos that the user with the given id owns or contributes to
         * @param {number} [priorityOwnerId] repo owner to prioritize in the results
         * @param {number} [teamId] search only for repos that belong to the given team id
         * @param {number} [starredBy] search only for repos that the user with the given id has starred
         * @param {boolean} [_private] include private repositories this user has access to (defaults to true)
         * @param {boolean} [isPrivate] show only pubic, private or all repositories (defaults to all)
         * @param {boolean} [template] include template repositories this user has access to (defaults to true)
         * @param {boolean} [archived] show only archived, non-archived or all repositories (defaults to all)
         * @param {string} [mode] type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
         * @param {boolean} [exclusive] if &#x60;uid&#x60; is given, search only for repos that the user owns
         * @param {string} [sort] sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
         * @param {string} [order] sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoSearch(q?: string, topic?: boolean, includeDesc?: boolean, uid?: number, priorityOwnerId?: number, teamId?: number, starredBy?: number, _private?: boolean, isPrivate?: boolean, template?: boolean, archived?: boolean, mode?: string, exclusive?: boolean, sort?: string, order?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoSearch(q, topic, includeDesc, uid, priorityOwnerId, teamId, starredBy, _private, isPrivate, template, archived, mode, exclusive, sort, order, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get signing-key.gpg for given repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoSigningKey(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoSigningKey(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Submit a pending review to an pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {SubmitPullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoSubmitPullReview(owner: string, repo: string, index: number, id: number, body: SubmitPullReviewOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoSubmitPullReview(owner, repo, index, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Test a push webhook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to test
         * @param {string} [ref] The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoTestHook(owner: string, repo: string, id: number, ref?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoTestHook(owner, repo, id, ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repo\'s tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoTrackedTimes(owner: string, repo: string, user?: string, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrackedTime>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoTrackedTimes(owner, repo, user, since, before, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Transfer a repo ownership
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {TransferRepoOption} body Transfer Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoTransfer(owner: string, repo: string, body: TransferRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoTransfer(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Cancel to dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUnDismissPullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoUnDismissPullReview(owner, repo, index, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update avatar
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {UpdateRepoAvatarOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUpdateAvatar(owner: string, repo: string, body?: UpdateRepoAvatarOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoUpdateAvatar(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to update
         * @param {UpdateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUpdateFile(owner: string, repo: string, filepath: string, body: UpdateFileOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoUpdateFile(owner, repo, filepath, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Merge PR\'s baseBranch into headBranch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {RepoUpdatePullRequestStyleEnum} [style] how to update pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUpdatePullRequest(owner: string, repo: string, index: number, style?: RepoUpdatePullRequestStyleEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoUpdatePullRequest(owner, repo, index, style, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Replace list of topics for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {RepoTopicOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUpdateTopics(owner: string, repo: string, body?: RepoTopicOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoUpdateTopics(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the validation information for a issue config
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoValidateIssueConfig(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IssueConfigValidation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoValidateIssueConfig(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary search topics via keyword
         * @param {string} q keywords to search
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topicSearch(q: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopicResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topicSearch(q, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create or Update a secret value in a repository
         * @param {string} owner owner of the repository
         * @param {string} repo name of the repository
         * @param {string} secretname name of the secret
         * @param {CreateOrUpdateSecretOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRepoSecret(owner: string, repo: string, secretname: string, body?: CreateOrUpdateSecretOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRepoSecret(owner, repo, secretname, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if the current user is watching a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentCheckSubscription(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentCheckSubscription(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unwatch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentDeleteSubscription(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentDeleteSubscription(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Watch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentPutSubscription(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentPutSubscription(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a user\'s tracked times in a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} user username of user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async userTrackedTimes(owner: string, repo: string, user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrackedTime>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userTrackedTimes(owner, repo, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RepositoryApi - factory interface
 * @export
 */
export const RepositoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Accept a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptRepoTransfer(owner: string, repo: string, options?: any): AxiosPromise<Repository> {
            return localVarFp.acceptRepoTransfer(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a repository
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrentUserRepo(body?: CreateRepoOption, options?: any): AxiosPromise<Repository> {
            return localVarFp.createCurrentUserRepo(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fork a repository
         * @param {string} owner owner of the repo to fork
         * @param {string} repo name of the repo to fork
         * @param {CreateForkOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFork(owner: string, repo: string, body?: CreateForkOption, options?: any): AxiosPromise<Repository> {
            return localVarFp.createFork(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a secret in a repository
         * @param {string} owner owner of the repository
         * @param {string} repo name of the repository
         * @param {string} secretname name of the secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepoSecret(owner: string, repo: string, secretname: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRepoSecret(owner, repo, secretname, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a repository using a template
         * @param {string} templateOwner name of the template repository owner
         * @param {string} templateRepo name of the template repository
         * @param {GenerateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateRepo(templateOwner: string, templateRepo: string, body?: GenerateRepoOption, options?: any): AxiosPromise<Repository> {
            return localVarFp.generateRepo(templateOwner, templateRepo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the tag object of an annotated tag (not lightweight tags)
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotatedTag(owner: string, repo: string, sha: string, options?: any): AxiosPromise<AnnotatedTag> {
            return localVarFp.getAnnotatedTag(owner, repo, sha, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the blob of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlob(owner: string, repo: string, sha: string, options?: any): AxiosPromise<GitBlobResponse> {
            return localVarFp.getBlob(owner, repo, sha, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the tree of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {boolean} [recursive] show all directories and files
         * @param {number} [page] page number; the \&#39;truncated\&#39; field in the response will be true if there are still more items after this page, false if the last page
         * @param {number} [perPage] number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTree(owner: string, repo: string, sha: string, recursive?: boolean, page?: number, perPage?: number, options?: any): AxiosPromise<GitTreeResponse> {
            return localVarFp.getTree(owner, repo, sha, recursive, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s forks
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForks(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.listForks(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reject a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectRepoTransfer(owner: string, repo: string, options?: any): AxiosPromise<Repository> {
            return localVarFp.rejectRepoTransfer(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a collaborator to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to add
         * @param {AddCollaboratorOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddCollaborator(owner: string, repo: string, collaborator: string, body?: AddCollaboratorOption, options?: any): AxiosPromise<void> {
            return localVarFp.repoAddCollaborator(owner, repo, collaborator, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary add a push mirror to the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreatePushMirrorOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddPushMirror(owner: string, repo: string, body?: CreatePushMirrorOption, options?: any): AxiosPromise<PushMirror> {
            return localVarFp.repoAddPushMirror(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a team to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddTeam(owner: string, repo: string, team: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoAddTeam(owner, repo, team, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a topic to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddTopic(owner: string, repo: string, topic: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoAddTopic(owner, repo, topic, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Apply diff patch to repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {UpdateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoApplyDiffPatch(owner: string, repo: string, body: UpdateFileOptions, options?: any): AxiosPromise<FileResponse> {
            return localVarFp.repoApplyDiffPatch(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel the scheduled auto merge for the given pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCancelScheduledAutoMerge(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.repoCancelScheduledAutoMerge(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify multiple files in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {ChangeFilesOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoChangeFiles(owner: string, repo: string, body: ChangeFilesOptions, options?: any): AxiosPromise<FilesResponse> {
            return localVarFp.repoChangeFiles(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if a user is a collaborator of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCheckCollaborator(owner: string, repo: string, collaborator: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoCheckCollaborator(owner, repo, collaborator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if a team is assigned to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCheckTeam(owner: string, repo: string, team: string, options?: any): AxiosPromise<Team> {
            return localVarFp.repoCheckTeam(owner, repo, team, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a branch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateBranch(owner: string, repo: string, body?: CreateBranchRepoOption, options?: any): AxiosPromise<Branch> {
            return localVarFp.repoCreateBranch(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateBranchProtection(owner: string, repo: string, body?: CreateBranchProtectionOption, options?: any): AxiosPromise<BranchProtection> {
            return localVarFp.repoCreateBranchProtection(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to create
         * @param {CreateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateFile(owner: string, repo: string, filepath: string, body: CreateFileOptions, options?: any): AxiosPromise<FileResponse> {
            return localVarFp.repoCreateFile(owner, repo, filepath, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateHook(owner: string, repo: string, body?: CreateHookOption, options?: any): AxiosPromise<Hook> {
            return localVarFp.repoCreateHook(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a key to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateKeyOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateKey(owner: string, repo: string, body?: CreateKeyOption, options?: any): AxiosPromise<DeployKey> {
            return localVarFp.repoCreateKey(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreatePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullRequest(owner: string, repo: string, body?: CreatePullRequestOption, options?: any): AxiosPromise<PullRequest> {
            return localVarFp.repoCreatePullRequest(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a review to an pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {CreatePullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullReview(owner: string, repo: string, index: number, body: CreatePullReviewOptions, options?: any): AxiosPromise<PullReview> {
            return localVarFp.repoCreatePullReview(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary create review requests for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {PullReviewRequestOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullReviewRequests(owner: string, repo: string, index: number, body: PullReviewRequestOptions, options?: any): AxiosPromise<Array<PullReview>> {
            return localVarFp.repoCreatePullReviewRequests(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateRelease(owner: string, repo: string, body?: CreateReleaseOption, options?: any): AxiosPromise<Release> {
            return localVarFp.repoCreateRelease(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {File} attachment attachment to upload
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateReleaseAttachment(owner: string, repo: string, id: number, attachment: File, name?: string, options?: any): AxiosPromise<Attachment> {
            return localVarFp.repoCreateReleaseAttachment(owner, repo, id, attachment, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a commit status
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {CreateStatusOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateStatus(owner: string, repo: string, sha: string, body?: CreateStatusOption, options?: any): AxiosPromise<CommitStatus> {
            return localVarFp.repoCreateStatus(owner, repo, sha, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new git tag in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateTagOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateTag(owner: string, repo: string, body?: CreateTagOption, options?: any): AxiosPromise<Tag> {
            return localVarFp.repoCreateTag(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateWikiPage(owner: string, repo: string, body?: CreateWikiPageOptions, options?: any): AxiosPromise<WikiPage> {
            return localVarFp.repoCreateWikiPage(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a repository
         * @param {string} owner owner of the repo to delete
         * @param {string} repo name of the repo to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDelete(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDelete(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete avatar
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteAvatar(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteAvatar(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific branch from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteBranch(owner: string, repo: string, branch: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteBranch(owner, repo, branch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteBranchProtection(owner: string, repo: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteBranchProtection(owner, repo, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a collaborator from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteCollaborator(owner: string, repo: string, collaborator: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteCollaborator(owner, repo, collaborator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to delete
         * @param {DeleteFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteFile(owner: string, repo: string, filepath: string, body: DeleteFileOptions, options?: any): AxiosPromise<FileDeleteResponse> {
            return localVarFp.repoDeleteFile(owner, repo, filepath, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteGitHook(owner: string, repo: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteGitHook(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteHook(owner: string, repo: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteHook(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a key from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteKey(owner: string, repo: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteKey(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific review from a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeletePullReview(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeletePullReview(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary cancel review requests for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {PullReviewRequestOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeletePullReviewRequests(owner: string, repo: string, index: number, body: PullReviewRequestOptions, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeletePullReviewRequests(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deletes a push mirror from a repository by remoteName
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name remote name of the pushMirror
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeletePushMirror(owner: string, repo: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeletePushMirror(owner, repo, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteRelease(owner: string, repo: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteRelease(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteReleaseAttachment(owner, repo, id, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteReleaseByTag(owner: string, repo: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteReleaseByTag(owner, repo, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a repository\'s tag by name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTag(owner: string, repo: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteTag(owner, repo, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a team from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTeam(owner: string, repo: string, team: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteTeam(owner, repo, team, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a topic from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTopic(owner: string, repo: string, topic: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteTopic(owner, repo, topic, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteWikiPage(owner: string, repo: string, pageName: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteWikiPage(owner, repo, pageName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {DismissPullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDismissPullReview(owner: string, repo: string, index: number, id: number, body: DismissPullReviewOptions, options?: any): AxiosPromise<PullReview> {
            return localVarFp.repoDismissPullReview(owner, repo, index, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a commit\'s diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha SHA of the commit to get
         * @param {RepoDownloadCommitDiffOrPatchDiffTypeEnum} diffType whether the output is diff or patch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDownloadCommitDiffOrPatch(owner: string, repo: string, sha: string, diffType: RepoDownloadCommitDiffOrPatchDiffTypeEnum, options?: any): AxiosPromise<string> {
            return localVarFp.repoDownloadCommitDiffOrPatch(owner, repo, sha, diffType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a pull request diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {RepoDownloadPullDiffOrPatchDiffTypeEnum} diffType whether the output is diff or patch
         * @param {boolean} [binary] whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDownloadPullDiffOrPatch(owner: string, repo: string, index: number, diffType: RepoDownloadPullDiffOrPatchDiffTypeEnum, binary?: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.repoDownloadPullDiffOrPatch(owner, repo, index, diffType, binary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a repository\'s properties. Only fields that are set will be changed.
         * @param {string} owner owner of the repo to edit
         * @param {string} repo name of the repo to edit
         * @param {EditRepoOption} [body] Properties of a repo that you can edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEdit(owner: string, repo: string, body?: EditRepoOption, options?: any): AxiosPromise<Repository> {
            return localVarFp.repoEdit(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a branch protections for a repository. Only fields that are set will be changed
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {EditBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditBranchProtection(owner: string, repo: string, name: string, body?: EditBranchProtectionOption, options?: any): AxiosPromise<BranchProtection> {
            return localVarFp.repoEditBranchProtection(owner, repo, name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {EditGitHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditGitHook(owner: string, repo: string, id: string, body?: EditGitHookOption, options?: any): AxiosPromise<GitHook> {
            return localVarFp.repoEditGitHook(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id index of the hook
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditHook(owner: string, repo: string, id: number, body?: EditHookOption, options?: any): AxiosPromise<Hook> {
            return localVarFp.repoEditHook(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to edit
         * @param {EditPullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditPullRequest(owner: string, repo: string, index: number, body?: EditPullRequestOption, options?: any): AxiosPromise<PullRequest> {
            return localVarFp.repoEditPullRequest(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to edit
         * @param {EditReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditRelease(owner: string, repo: string, id: number, body?: EditReleaseOption, options?: any): AxiosPromise<Release> {
            return localVarFp.repoEditRelease(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: any): AxiosPromise<Attachment> {
            return localVarFp.repoEditReleaseAttachment(owner, repo, id, attachmentId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditWikiPage(owner: string, repo: string, pageName: string, body?: CreateWikiPageOptions, options?: any): AxiosPromise<WikiPage> {
            return localVarFp.repoEditWikiPage(owner, repo, pageName, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGet(owner: string, repo: string, options?: any): AxiosPromise<Repository> {
            return localVarFp.repoGet(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all commits from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [sha] SHA or branch to start listing commits from (usually \&#39;master\&#39;)
         * @param {string} [path] filepath of a file/dir
         * @param {boolean} [stat] include diff stats for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results (ignored if used with \&#39;path\&#39;)
         * @param {string} [not] commits that match the given specifier will not be listed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetAllCommits(owner: string, repo: string, sha?: string, path?: string, stat?: boolean, verification?: boolean, files?: boolean, page?: number, limit?: number, not?: string, options?: any): AxiosPromise<Array<Commit>> {
            return localVarFp.repoGetAllCommits(owner, repo, sha, path, stat, verification, files, page, limit, not, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an archive of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} archive the git reference for download with attached archive format (e.g. master.zip)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetArchive(owner: string, repo: string, archive: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoGetArchive(owner, repo, archive, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return all users that have write access and can be assigned to issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetAssignees(owner: string, repo: string, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.repoGetAssignees(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a specific branch from a repository, including its effective branch protection
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetBranch(owner: string, repo: string, branch: string, options?: any): AxiosPromise<Branch> {
            return localVarFp.repoGetBranch(owner, repo, branch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetBranchProtection(owner: string, repo: string, name: string, options?: any): AxiosPromise<BranchProtection> {
            return localVarFp.repoGetBranchProtection(owner, repo, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a repository by id
         * @param {number} id id of the repo to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetByID(id: number, options?: any): AxiosPromise<Repository> {
            return localVarFp.repoGetByID(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a commit\'s combined status, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetCombinedStatusByRef(owner: string, repo: string, ref: string, page?: number, limit?: number, options?: any): AxiosPromise<CombinedStatus> {
            return localVarFp.repoGetCombinedStatusByRef(owner, repo, ref, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the dir, file, symlink or submodule in the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetContents(owner: string, repo: string, filepath: string, ref?: string, options?: any): AxiosPromise<ContentsResponse> {
            return localVarFp.repoGetContents(owner, repo, filepath, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the metadata of all the entries of the root dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetContentsList(owner: string, repo: string, ref?: string, options?: any): AxiosPromise<Array<ContentsResponse>> {
            return localVarFp.repoGetContentsList(owner, repo, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the EditorConfig definitions of a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetEditorConfig(owner: string, repo: string, filepath: string, ref?: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoGetEditorConfig(owner, repo, filepath, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Git hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetGitHook(owner: string, repo: string, id: string, options?: any): AxiosPromise<GitHook> {
            return localVarFp.repoGetGitHook(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetHook(owner: string, repo: string, id: number, options?: any): AxiosPromise<Hook> {
            return localVarFp.repoGetHook(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the issue config for a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetIssueConfig(owner: string, repo: string, options?: any): AxiosPromise<IssueConfig> {
            return localVarFp.repoGetIssueConfig(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get available issue templates for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetIssueTemplates(owner: string, repo: string, options?: any): AxiosPromise<Array<IssueTemplate>> {
            return localVarFp.repoGetIssueTemplates(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a repository\'s key by id
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetKey(owner: string, repo: string, id: number, options?: any): AxiosPromise<DeployKey> {
            return localVarFp.repoGetKey(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get languages and number of bytes of code written
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetLanguages(owner: string, repo: string, options?: any): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.repoGetLanguages(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetLatestRelease(owner: string, repo: string, options?: any): AxiosPromise<Release> {
            return localVarFp.repoGetLatestRelease(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a note corresponding to a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetNote(owner: string, repo: string, sha: string, verification?: boolean, files?: boolean, options?: any): AxiosPromise<Note> {
            return localVarFp.repoGetNote(owner, repo, sha, verification, files, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullRequest(owner: string, repo: string, index: number, options?: any): AxiosPromise<PullRequest> {
            return localVarFp.repoGetPullRequest(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get commits for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullRequestCommits(owner: string, repo: string, index: number, page?: number, limit?: number, verification?: boolean, files?: boolean, options?: any): AxiosPromise<Array<Commit>> {
            return localVarFp.repoGetPullRequestCommits(owner, repo, index, page, limit, verification, files, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get changed files for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {string} [skipTo] skip to given file
         * @param {RepoGetPullRequestFilesWhitespaceEnum} [whitespace] whitespace behavior
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullRequestFiles(owner: string, repo: string, index: number, skipTo?: string, whitespace?: RepoGetPullRequestFilesWhitespaceEnum, page?: number, limit?: number, options?: any): AxiosPromise<Array<ChangedFile>> {
            return localVarFp.repoGetPullRequestFiles(owner, repo, index, skipTo, whitespace, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullReview(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<PullReview> {
            return localVarFp.repoGetPullReview(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullReviewComments(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<Array<PullReviewComment>> {
            return localVarFp.repoGetPullReviewComments(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get push mirror of the repository by remoteName
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name remote name of push mirror
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPushMirrorByRemoteName(owner: string, repo: string, name: string, options?: any): AxiosPromise<PushMirror> {
            return localVarFp.repoGetPushMirrorByRemoteName(owner, repo, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a file from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRawFile(owner: string, repo: string, filepath: string, ref?: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoGetRawFile(owner, repo, filepath, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a file or it\'s LFS object from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRawFileOrLFS(owner: string, repo: string, filepath: string, ref?: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoGetRawFileOrLFS(owner, repo, filepath, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRelease(owner: string, repo: string, id: number, options?: any): AxiosPromise<Release> {
            return localVarFp.repoGetRelease(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: any): AxiosPromise<Attachment> {
            return localVarFp.repoGetReleaseAttachment(owner, repo, id, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReleaseByTag(owner: string, repo: string, tag: string, options?: any): AxiosPromise<Release> {
            return localVarFp.repoGetReleaseByTag(owner, repo, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get repository permissions for a user
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRepoPermissions(owner: string, repo: string, collaborator: string, options?: any): AxiosPromise<RepoCollaboratorPermission> {
            return localVarFp.repoGetRepoPermissions(owner, repo, collaborator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return all users that can be requested to review in this repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReviewers(owner: string, repo: string, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.repoGetReviewers(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {boolean} [stat] include diff stats for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetSingleCommit(owner: string, repo: string, sha: string, stat?: boolean, verification?: boolean, files?: boolean, options?: any): AxiosPromise<Commit> {
            return localVarFp.repoGetSingleCommit(owner, repo, sha, stat, verification, files, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the tag of a repository by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetTag(owner: string, repo: string, tag: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.repoGetTag(owner, repo, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetWikiPage(owner: string, repo: string, pageName: string, options?: any): AxiosPromise<WikiPage> {
            return localVarFp.repoGetWikiPage(owner, repo, pageName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get revisions of a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {number} [page] page number of results to return (1-based)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetWikiPageRevisions(owner: string, repo: string, pageName: string, page?: number, options?: any): AxiosPromise<WikiCommitList> {
            return localVarFp.repoGetWikiPageRevisions(owner, repo, pageName, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all wiki pages
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetWikiPages(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<WikiPageMetaData>> {
            return localVarFp.repoGetWikiPages(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s activity feeds
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [date] the date of the activities to be found
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListActivityFeeds(owner: string, repo: string, date?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Activity>> {
            return localVarFp.repoListActivityFeeds(owner, repo, date, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get specified ref or filtered repository\'s refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListAllGitRefs(owner: string, repo: string, options?: any): AxiosPromise<Array<Reference>> {
            return localVarFp.repoListAllGitRefs(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListBranchProtection(owner: string, repo: string, options?: any): AxiosPromise<Array<BranchProtection>> {
            return localVarFp.repoListBranchProtection(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s branches
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListBranches(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Branch>> {
            return localVarFp.repoListBranches(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s collaborators
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListCollaborators(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.repoListCollaborators(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the Git hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListGitHooks(owner: string, repo: string, options?: any): AxiosPromise<Array<GitHook>> {
            return localVarFp.repoListGitHooks(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get specified ref or filtered repository\'s refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref part or full name of the ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListGitRefs(owner: string, repo: string, ref: string, options?: any): AxiosPromise<Array<Reference>> {
            return localVarFp.repoListGitRefs(owner, repo, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListHooks(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Hook>> {
            return localVarFp.repoListHooks(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s keys
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [keyId] the key_id to search for
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListKeys(owner: string, repo: string, keyId?: number, fingerprint?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<DeployKey>> {
            return localVarFp.repoListKeys(owner, repo, keyId, fingerprint, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo\'s pinned issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPinnedIssues(owner: string, repo: string, options?: any): AxiosPromise<Array<Issue>> {
            return localVarFp.repoListPinnedIssues(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo\'s pinned pull requests
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPinnedPullRequests(owner: string, repo: string, options?: any): AxiosPromise<Array<PullRequest>> {
            return localVarFp.repoListPinnedPullRequests(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo\'s pull requests
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {RepoListPullRequestsStateEnum} [state] State of pull request: open or closed (optional)
         * @param {RepoListPullRequestsSortEnum} [sort] Type of sort
         * @param {number} [milestone] ID of the milestone
         * @param {Array<number>} [labels] Label IDs
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPullRequests(owner: string, repo: string, state?: RepoListPullRequestsStateEnum, sort?: RepoListPullRequestsSortEnum, milestone?: number, labels?: Array<number>, page?: number, limit?: number, options?: any): AxiosPromise<Array<PullRequest>> {
            return localVarFp.repoListPullRequests(owner, repo, state, sort, milestone, labels, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all reviews for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPullReviews(owner: string, repo: string, index: number, page?: number, limit?: number, options?: any): AxiosPromise<Array<PullReview>> {
            return localVarFp.repoListPullReviews(owner, repo, index, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all push mirrors of the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPushMirrors(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<PushMirror>> {
            return localVarFp.repoListPushMirrors(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List release\'s attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListReleaseAttachments(owner: string, repo: string, id: number, options?: any): AxiosPromise<Array<Attachment>> {
            return localVarFp.repoListReleaseAttachments(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo\'s releases
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {boolean} [draft] filter (exclude / include) drafts, if you dont have repo write access none will show
         * @param {boolean} [preRelease] filter (exclude / include) pre-releases
         * @param {number} [perPage] page size of results, deprecated - use limit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListReleases(owner: string, repo: string, draft?: boolean, preRelease?: boolean, perPage?: number, page?: number, limit?: number, options?: any): AxiosPromise<Array<Release>> {
            return localVarFp.repoListReleases(owner, repo, draft, preRelease, perPage, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo\'s stargazers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStargazers(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.repoListStargazers(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a commit\'s statuses
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {RepoListStatusesSortEnum} [sort] type of sort
         * @param {RepoListStatusesStateEnum} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStatuses(owner: string, repo: string, sha: string, sort?: RepoListStatusesSortEnum, state?: RepoListStatusesStateEnum, page?: number, limit?: number, options?: any): AxiosPromise<Array<CommitStatus>> {
            return localVarFp.repoListStatuses(owner, repo, sha, sort, state, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a commit\'s statuses, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {RepoListStatusesByRefSortEnum} [sort] type of sort
         * @param {RepoListStatusesByRefStateEnum} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStatusesByRef(owner: string, repo: string, ref: string, sort?: RepoListStatusesByRefSortEnum, state?: RepoListStatusesByRefStateEnum, page?: number, limit?: number, options?: any): AxiosPromise<Array<CommitStatus>> {
            return localVarFp.repoListStatusesByRef(owner, repo, ref, sort, state, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo\'s watchers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListSubscribers(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.repoListSubscribers(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s tags
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results, default maximum page size is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTags(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.repoListTags(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s teams
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTeams(owner: string, repo: string, options?: any): AxiosPromise<Array<Team>> {
            return localVarFp.repoListTeams(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of topics that a repository has
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTopics(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<TopicName> {
            return localVarFp.repoListTopics(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Merge a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {MergePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMergePullRequest(owner: string, repo: string, index: number, body?: MergePullRequestOption, options?: any): AxiosPromise<void> {
            return localVarFp.repoMergePullRequest(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Migrate a remote git repository
         * @param {MigrateRepoOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMigrate(body?: MigrateRepoOptions, options?: any): AxiosPromise<Repository> {
            return localVarFp.repoMigrate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sync a mirrored repository
         * @param {string} owner owner of the repo to sync
         * @param {string} repo name of the repo to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMirrorSync(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoMirrorSync(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns if new Issue Pins are allowed
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoNewPinAllowed(owner: string, repo: string, options?: any): AxiosPromise<NewIssuePinsAllowed> {
            return localVarFp.repoNewPinAllowed(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if a pull request has been merged
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoPullRequestIsMerged(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.repoPullRequestIsMerged(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sync all push mirrored repository
         * @param {string} owner owner of the repo to sync
         * @param {string} repo name of the repo to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoPushMirrorSync(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoPushMirrorSync(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for repositories
         * @param {string} [q] keyword
         * @param {boolean} [topic] Limit search to repositories with keyword as topic
         * @param {boolean} [includeDesc] include search of keyword within repository description
         * @param {number} [uid] search only for repos that the user with the given id owns or contributes to
         * @param {number} [priorityOwnerId] repo owner to prioritize in the results
         * @param {number} [teamId] search only for repos that belong to the given team id
         * @param {number} [starredBy] search only for repos that the user with the given id has starred
         * @param {boolean} [_private] include private repositories this user has access to (defaults to true)
         * @param {boolean} [isPrivate] show only pubic, private or all repositories (defaults to all)
         * @param {boolean} [template] include template repositories this user has access to (defaults to true)
         * @param {boolean} [archived] show only archived, non-archived or all repositories (defaults to all)
         * @param {string} [mode] type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
         * @param {boolean} [exclusive] if &#x60;uid&#x60; is given, search only for repos that the user owns
         * @param {string} [sort] sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
         * @param {string} [order] sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSearch(q?: string, topic?: boolean, includeDesc?: boolean, uid?: number, priorityOwnerId?: number, teamId?: number, starredBy?: number, _private?: boolean, isPrivate?: boolean, template?: boolean, archived?: boolean, mode?: string, exclusive?: boolean, sort?: string, order?: string, page?: number, limit?: number, options?: any): AxiosPromise<SearchResults> {
            return localVarFp.repoSearch(q, topic, includeDesc, uid, priorityOwnerId, teamId, starredBy, _private, isPrivate, template, archived, mode, exclusive, sort, order, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get signing-key.gpg for given repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSigningKey(owner: string, repo: string, options?: any): AxiosPromise<string> {
            return localVarFp.repoSigningKey(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit a pending review to an pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {SubmitPullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSubmitPullReview(owner: string, repo: string, index: number, id: number, body: SubmitPullReviewOptions, options?: any): AxiosPromise<PullReview> {
            return localVarFp.repoSubmitPullReview(owner, repo, index, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Test a push webhook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to test
         * @param {string} [ref] The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTestHook(owner: string, repo: string, id: number, ref?: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoTestHook(owner, repo, id, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo\'s tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTrackedTimes(owner: string, repo: string, user?: string, since?: string, before?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<TrackedTime>> {
            return localVarFp.repoTrackedTimes(owner, repo, user, since, before, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transfer a repo ownership
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {TransferRepoOption} body Transfer Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTransfer(owner: string, repo: string, body: TransferRepoOption, options?: any): AxiosPromise<Repository> {
            return localVarFp.repoTransfer(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel to dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUnDismissPullReview(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<PullReview> {
            return localVarFp.repoUnDismissPullReview(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update avatar
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {UpdateRepoAvatarOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdateAvatar(owner: string, repo: string, body?: UpdateRepoAvatarOption, options?: any): AxiosPromise<void> {
            return localVarFp.repoUpdateAvatar(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to update
         * @param {UpdateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdateFile(owner: string, repo: string, filepath: string, body: UpdateFileOptions, options?: any): AxiosPromise<FileResponse> {
            return localVarFp.repoUpdateFile(owner, repo, filepath, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Merge PR\'s baseBranch into headBranch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {RepoUpdatePullRequestStyleEnum} [style] how to update pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdatePullRequest(owner: string, repo: string, index: number, style?: RepoUpdatePullRequestStyleEnum, options?: any): AxiosPromise<void> {
            return localVarFp.repoUpdatePullRequest(owner, repo, index, style, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Replace list of topics for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {RepoTopicOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdateTopics(owner: string, repo: string, body?: RepoTopicOptions, options?: any): AxiosPromise<void> {
            return localVarFp.repoUpdateTopics(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the validation information for a issue config
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoValidateIssueConfig(owner: string, repo: string, options?: any): AxiosPromise<IssueConfigValidation> {
            return localVarFp.repoValidateIssueConfig(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary search topics via keyword
         * @param {string} q keywords to search
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicSearch(q: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<TopicResponse>> {
            return localVarFp.topicSearch(q, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create or Update a secret value in a repository
         * @param {string} owner owner of the repository
         * @param {string} repo name of the repository
         * @param {string} secretname name of the secret
         * @param {CreateOrUpdateSecretOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepoSecret(owner: string, repo: string, secretname: string, body?: CreateOrUpdateSecretOption, options?: any): AxiosPromise<void> {
            return localVarFp.updateRepoSecret(owner, repo, secretname, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if the current user is watching a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentCheckSubscription(owner: string, repo: string, options?: any): AxiosPromise<WatchInfo> {
            return localVarFp.userCurrentCheckSubscription(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unwatch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteSubscription(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentDeleteSubscription(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Watch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPutSubscription(owner: string, repo: string, options?: any): AxiosPromise<WatchInfo> {
            return localVarFp.userCurrentPutSubscription(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a user\'s tracked times in a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} user username of user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        userTrackedTimes(owner: string, repo: string, user: string, options?: any): AxiosPromise<Array<TrackedTime>> {
            return localVarFp.userTrackedTimes(owner, repo, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoryApi - interface
 * @export
 * @interface RepositoryApi
 */
export interface RepositoryApiInterface {
    /**
     * 
     * @summary Accept a repo transfer
     * @param {string} owner owner of the repo to transfer
     * @param {string} repo name of the repo to transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    acceptRepoTransfer(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Create a repository
     * @param {CreateRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    createCurrentUserRepo(body?: CreateRepoOption, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Fork a repository
     * @param {string} owner owner of the repo to fork
     * @param {string} repo name of the repo to fork
     * @param {CreateForkOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    createFork(owner: string, repo: string, body?: CreateForkOption, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Delete a secret in a repository
     * @param {string} owner owner of the repository
     * @param {string} repo name of the repository
     * @param {string} secretname name of the secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    deleteRepoSecret(owner: string, repo: string, secretname: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Create a repository using a template
     * @param {string} templateOwner name of the template repository owner
     * @param {string} templateRepo name of the template repository
     * @param {GenerateRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    generateRepo(templateOwner: string, templateRepo: string, body?: GenerateRepoOption, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Gets the tag object of an annotated tag (not lightweight tags)
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    getAnnotatedTag(owner: string, repo: string, sha: string, options?: AxiosRequestConfig): AxiosPromise<AnnotatedTag>;

    /**
     * 
     * @summary Gets the blob of a repository.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    getBlob(owner: string, repo: string, sha: string, options?: AxiosRequestConfig): AxiosPromise<GitBlobResponse>;

    /**
     * 
     * @summary Gets the tree of a repository.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {boolean} [recursive] show all directories and files
     * @param {number} [page] page number; the \&#39;truncated\&#39; field in the response will be true if there are still more items after this page, false if the last page
     * @param {number} [perPage] number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    getTree(owner: string, repo: string, sha: string, recursive?: boolean, page?: number, perPage?: number, options?: AxiosRequestConfig): AxiosPromise<GitTreeResponse>;

    /**
     * 
     * @summary List a repository\'s forks
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    listForks(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Repository>>;

    /**
     * 
     * @summary Reject a repo transfer
     * @param {string} owner owner of the repo to transfer
     * @param {string} repo name of the repo to transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    rejectRepoTransfer(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Add a collaborator to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} collaborator username of the collaborator to add
     * @param {AddCollaboratorOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoAddCollaborator(owner: string, repo: string, collaborator: string, body?: AddCollaboratorOption, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary add a push mirror to the repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreatePushMirrorOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoAddPushMirror(owner: string, repo: string, body?: CreatePushMirrorOption, options?: AxiosRequestConfig): AxiosPromise<PushMirror>;

    /**
     * 
     * @summary Add a team to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} team team name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoAddTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Add a topic to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} topic name of the topic to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoAddTopic(owner: string, repo: string, topic: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Apply diff patch to repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {UpdateFileOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoApplyDiffPatch(owner: string, repo: string, body: UpdateFileOptions, options?: AxiosRequestConfig): AxiosPromise<FileResponse>;

    /**
     * 
     * @summary Cancel the scheduled auto merge for the given pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to merge
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCancelScheduledAutoMerge(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Modify multiple files in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {ChangeFilesOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoChangeFiles(owner: string, repo: string, body: ChangeFilesOptions, options?: AxiosRequestConfig): AxiosPromise<FilesResponse>;

    /**
     * 
     * @summary Check if a user is a collaborator of a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} collaborator username of the collaborator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCheckCollaborator(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Check if a team is assigned to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} team team name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCheckTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig): AxiosPromise<Team>;

    /**
     * 
     * @summary Create a branch
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateBranchRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreateBranch(owner: string, repo: string, body?: CreateBranchRepoOption, options?: AxiosRequestConfig): AxiosPromise<Branch>;

    /**
     * 
     * @summary Create a branch protections for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateBranchProtectionOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreateBranchProtection(owner: string, repo: string, body?: CreateBranchProtectionOption, options?: AxiosRequestConfig): AxiosPromise<BranchProtection>;

    /**
     * 
     * @summary Create a file in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the file to create
     * @param {CreateFileOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreateFile(owner: string, repo: string, filepath: string, body: CreateFileOptions, options?: AxiosRequestConfig): AxiosPromise<FileResponse>;

    /**
     * 
     * @summary Create a hook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreateHook(owner: string, repo: string, body?: CreateHookOption, options?: AxiosRequestConfig): AxiosPromise<Hook>;

    /**
     * 
     * @summary Add a key to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateKeyOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreateKey(owner: string, repo: string, body?: CreateKeyOption, options?: AxiosRequestConfig): AxiosPromise<DeployKey>;

    /**
     * 
     * @summary Create a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreatePullRequestOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreatePullRequest(owner: string, repo: string, body?: CreatePullRequestOption, options?: AxiosRequestConfig): AxiosPromise<PullRequest>;

    /**
     * 
     * @summary Create a review to an pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {CreatePullReviewOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreatePullReview(owner: string, repo: string, index: number, body: CreatePullReviewOptions, options?: AxiosRequestConfig): AxiosPromise<PullReview>;

    /**
     * 
     * @summary create review requests for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {PullReviewRequestOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreatePullReviewRequests(owner: string, repo: string, index: number, body: PullReviewRequestOptions, options?: AxiosRequestConfig): AxiosPromise<Array<PullReview>>;

    /**
     * 
     * @summary Create a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateReleaseOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreateRelease(owner: string, repo: string, body?: CreateReleaseOption, options?: AxiosRequestConfig): AxiosPromise<Release>;

    /**
     * 
     * @summary Create a release attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {File} attachment attachment to upload
     * @param {string} [name] name of the attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreateReleaseAttachment(owner: string, repo: string, id: number, attachment: File, name?: string, options?: AxiosRequestConfig): AxiosPromise<Attachment>;

    /**
     * 
     * @summary Create a commit status
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {CreateStatusOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreateStatus(owner: string, repo: string, sha: string, body?: CreateStatusOption, options?: AxiosRequestConfig): AxiosPromise<CommitStatus>;

    /**
     * 
     * @summary Create a new git tag in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateTagOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreateTag(owner: string, repo: string, body?: CreateTagOption, options?: AxiosRequestConfig): AxiosPromise<Tag>;

    /**
     * 
     * @summary Create a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateWikiPageOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreateWikiPage(owner: string, repo: string, body?: CreateWikiPageOptions, options?: AxiosRequestConfig): AxiosPromise<WikiPage>;

    /**
     * 
     * @summary Delete a repository
     * @param {string} owner owner of the repo to delete
     * @param {string} repo name of the repo to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDelete(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete avatar
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteAvatar(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a specific branch from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} branch branch to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteBranch(owner: string, repo: string, branch: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a specific branch protection for the repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name name of protected branch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteBranchProtection(owner: string, repo: string, name: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a collaborator from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} collaborator username of the collaborator to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteCollaborator(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a file in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the file to delete
     * @param {DeleteFileOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteFile(owner: string, repo: string, filepath: string, body: DeleteFileOptions, options?: AxiosRequestConfig): AxiosPromise<FileDeleteResponse>;

    /**
     * 
     * @summary Delete a Git hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteGitHook(owner: string, repo: string, id: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the hook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a key from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the key to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteKey(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a specific review from a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeletePullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary cancel review requests for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {PullReviewRequestOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeletePullReviewRequests(owner: string, repo: string, index: number, body: PullReviewRequestOptions, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary deletes a push mirror from a repository by remoteName
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name remote name of the pushMirror
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeletePushMirror(owner: string, repo: string, name: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteRelease(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a release attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {number} attachmentId id of the attachment to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a release by tag name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag tag name of the release to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteReleaseByTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a repository\'s tag by name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag name of tag to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a team from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} team team name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a topic from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} topic name of the topic to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteTopic(owner: string, repo: string, topic: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} pageName name of the page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteWikiPage(owner: string, repo: string, pageName: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Dismiss a review for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {DismissPullReviewOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDismissPullReview(owner: string, repo: string, index: number, id: number, body: DismissPullReviewOptions, options?: AxiosRequestConfig): AxiosPromise<PullReview>;

    /**
     * 
     * @summary Get a commit\'s diff or patch
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha SHA of the commit to get
     * @param {RepoDownloadCommitDiffOrPatchDiffTypeEnum} diffType whether the output is diff or patch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDownloadCommitDiffOrPatch(owner: string, repo: string, sha: string, diffType: RepoDownloadCommitDiffOrPatchDiffTypeEnum, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Get a pull request diff or patch
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {RepoDownloadPullDiffOrPatchDiffTypeEnum} diffType whether the output is diff or patch
     * @param {boolean} [binary] whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDownloadPullDiffOrPatch(owner: string, repo: string, index: number, diffType: RepoDownloadPullDiffOrPatchDiffTypeEnum, binary?: boolean, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Edit a repository\'s properties. Only fields that are set will be changed.
     * @param {string} owner owner of the repo to edit
     * @param {string} repo name of the repo to edit
     * @param {EditRepoOption} [body] Properties of a repo that you can edit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoEdit(owner: string, repo: string, body?: EditRepoOption, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Edit a branch protections for a repository. Only fields that are set will be changed
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name name of protected branch
     * @param {EditBranchProtectionOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoEditBranchProtection(owner: string, repo: string, name: string, body?: EditBranchProtectionOption, options?: AxiosRequestConfig): AxiosPromise<BranchProtection>;

    /**
     * 
     * @summary Edit a Git hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id id of the hook to get
     * @param {EditGitHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoEditGitHook(owner: string, repo: string, id: string, body?: EditGitHookOption, options?: AxiosRequestConfig): AxiosPromise<GitHook>;

    /**
     * 
     * @summary Edit a hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id index of the hook
     * @param {EditHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoEditHook(owner: string, repo: string, id: number, body?: EditHookOption, options?: AxiosRequestConfig): AxiosPromise<Hook>;

    /**
     * 
     * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to edit
     * @param {EditPullRequestOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoEditPullRequest(owner: string, repo: string, index: number, body?: EditPullRequestOption, options?: AxiosRequestConfig): AxiosPromise<PullRequest>;

    /**
     * 
     * @summary Update a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release to edit
     * @param {EditReleaseOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoEditRelease(owner: string, repo: string, id: number, body?: EditReleaseOption, options?: AxiosRequestConfig): AxiosPromise<Release>;

    /**
     * 
     * @summary Edit a release attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {number} attachmentId id of the attachment to edit
     * @param {EditAttachmentOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoEditReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: AxiosRequestConfig): AxiosPromise<Attachment>;

    /**
     * 
     * @summary Edit a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} pageName name of the page
     * @param {CreateWikiPageOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoEditWikiPage(owner: string, repo: string, pageName: string, body?: CreateWikiPageOptions, options?: AxiosRequestConfig): AxiosPromise<WikiPage>;

    /**
     * 
     * @summary Get a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGet(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Get a list of all commits from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [sha] SHA or branch to start listing commits from (usually \&#39;master\&#39;)
     * @param {string} [path] filepath of a file/dir
     * @param {boolean} [stat] include diff stats for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results (ignored if used with \&#39;path\&#39;)
     * @param {string} [not] commits that match the given specifier will not be listed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetAllCommits(owner: string, repo: string, sha?: string, path?: string, stat?: boolean, verification?: boolean, files?: boolean, page?: number, limit?: number, not?: string, options?: AxiosRequestConfig): AxiosPromise<Array<Commit>>;

    /**
     * 
     * @summary Get an archive of a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} archive the git reference for download with attached archive format (e.g. master.zip)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetArchive(owner: string, repo: string, archive: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Return all users that have write access and can be assigned to issues
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetAssignees(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary Retrieve a specific branch from a repository, including its effective branch protection
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} branch branch to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetBranch(owner: string, repo: string, branch: string, options?: AxiosRequestConfig): AxiosPromise<Branch>;

    /**
     * 
     * @summary Get a specific branch protection for the repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name name of protected branch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetBranchProtection(owner: string, repo: string, name: string, options?: AxiosRequestConfig): AxiosPromise<BranchProtection>;

    /**
     * 
     * @summary Get a repository by id
     * @param {number} id id of the repo to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetByID(id: number, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Get a commit\'s combined status, by branch/tag/commit reference
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} ref name of branch/tag/commit
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetCombinedStatusByRef(owner: string, repo: string, ref: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<CombinedStatus>;

    /**
     * 
     * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the dir, file, symlink or submodule in the repo
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetContents(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): AxiosPromise<ContentsResponse>;

    /**
     * 
     * @summary Gets the metadata of all the entries of the root dir
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetContentsList(owner: string, repo: string, ref?: string, options?: AxiosRequestConfig): AxiosPromise<Array<ContentsResponse>>;

    /**
     * 
     * @summary Get the EditorConfig definitions of a file in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath filepath of file to get
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetEditorConfig(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get a Git hook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetGitHook(owner: string, repo: string, id: string, options?: AxiosRequestConfig): AxiosPromise<GitHook>;

    /**
     * 
     * @summary Get a hook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<Hook>;

    /**
     * 
     * @summary Returns the issue config for a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetIssueConfig(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<IssueConfig>;

    /**
     * 
     * @summary Get available issue templates for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetIssueTemplates(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Array<IssueTemplate>>;

    /**
     * 
     * @summary Get a repository\'s key by id
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the key to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetKey(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<DeployKey>;

    /**
     * 
     * @summary Get languages and number of bytes of code written
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetLanguages(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: number; }>;

    /**
     * 
     * @summary Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetLatestRelease(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Release>;

    /**
     * 
     * @summary Get a note corresponding to a single commit from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha a git ref or commit sha
     * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetNote(owner: string, repo: string, sha: string, verification?: boolean, files?: boolean, options?: AxiosRequestConfig): AxiosPromise<Note>;

    /**
     * 
     * @summary Get a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetPullRequest(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<PullRequest>;

    /**
     * 
     * @summary Get commits for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetPullRequestCommits(owner: string, repo: string, index: number, page?: number, limit?: number, verification?: boolean, files?: boolean, options?: AxiosRequestConfig): AxiosPromise<Array<Commit>>;

    /**
     * 
     * @summary Get changed files for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {string} [skipTo] skip to given file
     * @param {RepoGetPullRequestFilesWhitespaceEnum} [whitespace] whitespace behavior
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetPullRequestFiles(owner: string, repo: string, index: number, skipTo?: string, whitespace?: RepoGetPullRequestFilesWhitespaceEnum, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<ChangedFile>>;

    /**
     * 
     * @summary Get a specific review for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetPullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): AxiosPromise<PullReview>;

    /**
     * 
     * @summary Get a specific review for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetPullReviewComments(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): AxiosPromise<Array<PullReviewComment>>;

    /**
     * 
     * @summary Get push mirror of the repository by remoteName
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name remote name of push mirror
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetPushMirrorByRemoteName(owner: string, repo: string, name: string, options?: AxiosRequestConfig): AxiosPromise<PushMirror>;

    /**
     * 
     * @summary Get a file from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath filepath of the file to get
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetRawFile(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get a file or it\'s LFS object from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath filepath of the file to get
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetRawFileOrLFS(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetRelease(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<Release>;

    /**
     * 
     * @summary Get a release attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {number} attachmentId id of the attachment to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig): AxiosPromise<Attachment>;

    /**
     * 
     * @summary Get a release by tag name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag tag name of the release to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetReleaseByTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): AxiosPromise<Release>;

    /**
     * 
     * @summary Get repository permissions for a user
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} collaborator username of the collaborator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetRepoPermissions(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig): AxiosPromise<RepoCollaboratorPermission>;

    /**
     * 
     * @summary Return all users that can be requested to review in this repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetReviewers(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary Get a single commit from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha a git ref or commit sha
     * @param {boolean} [stat] include diff stats for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetSingleCommit(owner: string, repo: string, sha: string, stat?: boolean, verification?: boolean, files?: boolean, options?: AxiosRequestConfig): AxiosPromise<Commit>;

    /**
     * 
     * @summary Get the tag of a repository by tag name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag name of tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): AxiosPromise<Tag>;

    /**
     * 
     * @summary Get a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} pageName name of the page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetWikiPage(owner: string, repo: string, pageName: string, options?: AxiosRequestConfig): AxiosPromise<WikiPage>;

    /**
     * 
     * @summary Get revisions of a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} pageName name of the page
     * @param {number} [page] page number of results to return (1-based)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetWikiPageRevisions(owner: string, repo: string, pageName: string, page?: number, options?: AxiosRequestConfig): AxiosPromise<WikiCommitList>;

    /**
     * 
     * @summary Get all wiki pages
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetWikiPages(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<WikiPageMetaData>>;

    /**
     * 
     * @summary List a repository\'s activity feeds
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [date] the date of the activities to be found
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListActivityFeeds(owner: string, repo: string, date?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Activity>>;

    /**
     * 
     * @summary Get specified ref or filtered repository\'s refs
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListAllGitRefs(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Array<Reference>>;

    /**
     * 
     * @summary List branch protections for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListBranchProtection(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Array<BranchProtection>>;

    /**
     * 
     * @summary List a repository\'s branches
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListBranches(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Branch>>;

    /**
     * 
     * @summary List a repository\'s collaborators
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListCollaborators(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary List the Git hooks in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListGitHooks(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Array<GitHook>>;

    /**
     * 
     * @summary Get specified ref or filtered repository\'s refs
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} ref part or full name of the ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListGitRefs(owner: string, repo: string, ref: string, options?: AxiosRequestConfig): AxiosPromise<Array<Reference>>;

    /**
     * 
     * @summary List the hooks in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListHooks(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Hook>>;

    /**
     * 
     * @summary List a repository\'s keys
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [keyId] the key_id to search for
     * @param {string} [fingerprint] fingerprint of the key
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListKeys(owner: string, repo: string, keyId?: number, fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<DeployKey>>;

    /**
     * 
     * @summary List a repo\'s pinned issues
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListPinnedIssues(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Array<Issue>>;

    /**
     * 
     * @summary List a repo\'s pinned pull requests
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListPinnedPullRequests(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Array<PullRequest>>;

    /**
     * 
     * @summary List a repo\'s pull requests
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {RepoListPullRequestsStateEnum} [state] State of pull request: open or closed (optional)
     * @param {RepoListPullRequestsSortEnum} [sort] Type of sort
     * @param {number} [milestone] ID of the milestone
     * @param {Array<number>} [labels] Label IDs
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListPullRequests(owner: string, repo: string, state?: RepoListPullRequestsStateEnum, sort?: RepoListPullRequestsSortEnum, milestone?: number, labels?: Array<number>, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<PullRequest>>;

    /**
     * 
     * @summary List all reviews for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListPullReviews(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<PullReview>>;

    /**
     * 
     * @summary Get all push mirrors of the repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListPushMirrors(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<PushMirror>>;

    /**
     * 
     * @summary List release\'s attachments
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListReleaseAttachments(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<Array<Attachment>>;

    /**
     * 
     * @summary List a repo\'s releases
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {boolean} [draft] filter (exclude / include) drafts, if you dont have repo write access none will show
     * @param {boolean} [preRelease] filter (exclude / include) pre-releases
     * @param {number} [perPage] page size of results, deprecated - use limit
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListReleases(owner: string, repo: string, draft?: boolean, preRelease?: boolean, perPage?: number, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Release>>;

    /**
     * 
     * @summary List a repo\'s stargazers
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListStargazers(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary Get a commit\'s statuses
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {RepoListStatusesSortEnum} [sort] type of sort
     * @param {RepoListStatusesStateEnum} [state] type of state
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListStatuses(owner: string, repo: string, sha: string, sort?: RepoListStatusesSortEnum, state?: RepoListStatusesStateEnum, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<CommitStatus>>;

    /**
     * 
     * @summary Get a commit\'s statuses, by branch/tag/commit reference
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} ref name of branch/tag/commit
     * @param {RepoListStatusesByRefSortEnum} [sort] type of sort
     * @param {RepoListStatusesByRefStateEnum} [state] type of state
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListStatusesByRef(owner: string, repo: string, ref: string, sort?: RepoListStatusesByRefSortEnum, state?: RepoListStatusesByRefStateEnum, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<CommitStatus>>;

    /**
     * 
     * @summary List a repo\'s watchers
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListSubscribers(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary List a repository\'s tags
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results, default maximum page size is 50
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListTags(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Tag>>;

    /**
     * 
     * @summary List a repository\'s teams
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListTeams(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Array<Team>>;

    /**
     * 
     * @summary Get list of topics that a repository has
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListTopics(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<TopicName>;

    /**
     * 
     * @summary Merge a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to merge
     * @param {MergePullRequestOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoMergePullRequest(owner: string, repo: string, index: number, body?: MergePullRequestOption, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Migrate a remote git repository
     * @param {MigrateRepoOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoMigrate(body?: MigrateRepoOptions, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Sync a mirrored repository
     * @param {string} owner owner of the repo to sync
     * @param {string} repo name of the repo to sync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoMirrorSync(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Returns if new Issue Pins are allowed
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoNewPinAllowed(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<NewIssuePinsAllowed>;

    /**
     * 
     * @summary Check if a pull request has been merged
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoPullRequestIsMerged(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Sync all push mirrored repository
     * @param {string} owner owner of the repo to sync
     * @param {string} repo name of the repo to sync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoPushMirrorSync(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Search for repositories
     * @param {string} [q] keyword
     * @param {boolean} [topic] Limit search to repositories with keyword as topic
     * @param {boolean} [includeDesc] include search of keyword within repository description
     * @param {number} [uid] search only for repos that the user with the given id owns or contributes to
     * @param {number} [priorityOwnerId] repo owner to prioritize in the results
     * @param {number} [teamId] search only for repos that belong to the given team id
     * @param {number} [starredBy] search only for repos that the user with the given id has starred
     * @param {boolean} [_private] include private repositories this user has access to (defaults to true)
     * @param {boolean} [isPrivate] show only pubic, private or all repositories (defaults to all)
     * @param {boolean} [template] include template repositories this user has access to (defaults to true)
     * @param {boolean} [archived] show only archived, non-archived or all repositories (defaults to all)
     * @param {string} [mode] type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
     * @param {boolean} [exclusive] if &#x60;uid&#x60; is given, search only for repos that the user owns
     * @param {string} [sort] sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
     * @param {string} [order] sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoSearch(q?: string, topic?: boolean, includeDesc?: boolean, uid?: number, priorityOwnerId?: number, teamId?: number, starredBy?: number, _private?: boolean, isPrivate?: boolean, template?: boolean, archived?: boolean, mode?: string, exclusive?: boolean, sort?: string, order?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<SearchResults>;

    /**
     * 
     * @summary Get signing-key.gpg for given repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoSigningKey(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Submit a pending review to an pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {SubmitPullReviewOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoSubmitPullReview(owner: string, repo: string, index: number, id: number, body: SubmitPullReviewOptions, options?: AxiosRequestConfig): AxiosPromise<PullReview>;

    /**
     * 
     * @summary Test a push webhook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the hook to test
     * @param {string} [ref] The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoTestHook(owner: string, repo: string, id: number, ref?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary List a repo\'s tracked times
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [user] optional filter by user (available for issue managers)
     * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoTrackedTimes(owner: string, repo: string, user?: string, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<TrackedTime>>;

    /**
     * 
     * @summary Transfer a repo ownership
     * @param {string} owner owner of the repo to transfer
     * @param {string} repo name of the repo to transfer
     * @param {TransferRepoOption} body Transfer Options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoTransfer(owner: string, repo: string, body: TransferRepoOption, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Cancel to dismiss a review for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoUnDismissPullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): AxiosPromise<PullReview>;

    /**
     * 
     * @summary Update avatar
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {UpdateRepoAvatarOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoUpdateAvatar(owner: string, repo: string, body?: UpdateRepoAvatarOption, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Update a file in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the file to update
     * @param {UpdateFileOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoUpdateFile(owner: string, repo: string, filepath: string, body: UpdateFileOptions, options?: AxiosRequestConfig): AxiosPromise<FileResponse>;

    /**
     * 
     * @summary Merge PR\'s baseBranch into headBranch
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {RepoUpdatePullRequestStyleEnum} [style] how to update pull request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoUpdatePullRequest(owner: string, repo: string, index: number, style?: RepoUpdatePullRequestStyleEnum, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Replace list of topics for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {RepoTopicOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoUpdateTopics(owner: string, repo: string, body?: RepoTopicOptions, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Returns the validation information for a issue config
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoValidateIssueConfig(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<IssueConfigValidation>;

    /**
     * 
     * @summary search topics via keyword
     * @param {string} q keywords to search
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    topicSearch(q: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<TopicResponse>>;

    /**
     * 
     * @summary Create or Update a secret value in a repository
     * @param {string} owner owner of the repository
     * @param {string} repo name of the repository
     * @param {string} secretname name of the secret
     * @param {CreateOrUpdateSecretOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    updateRepoSecret(owner: string, repo: string, secretname: string, body?: CreateOrUpdateSecretOption, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Check if the current user is watching a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    userCurrentCheckSubscription(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<WatchInfo>;

    /**
     * 
     * @summary Unwatch a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    userCurrentDeleteSubscription(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Watch a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    userCurrentPutSubscription(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<WatchInfo>;

    /**
     * 
     * @summary List a user\'s tracked times in a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} user username of user
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    userTrackedTimes(owner: string, repo: string, user: string, options?: AxiosRequestConfig): AxiosPromise<Array<TrackedTime>>;

}

/**
 * RepositoryApi - object-oriented interface
 * @export
 * @class RepositoryApi
 * @extends {BaseAPI}
 */
export class RepositoryApi extends BaseAPI implements RepositoryApiInterface {
    /**
     * 
     * @summary Accept a repo transfer
     * @param {string} owner owner of the repo to transfer
     * @param {string} repo name of the repo to transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public acceptRepoTransfer(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).acceptRepoTransfer(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a repository
     * @param {CreateRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public createCurrentUserRepo(body?: CreateRepoOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).createCurrentUserRepo(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fork a repository
     * @param {string} owner owner of the repo to fork
     * @param {string} repo name of the repo to fork
     * @param {CreateForkOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public createFork(owner: string, repo: string, body?: CreateForkOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).createFork(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a secret in a repository
     * @param {string} owner owner of the repository
     * @param {string} repo name of the repository
     * @param {string} secretname name of the secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public deleteRepoSecret(owner: string, repo: string, secretname: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).deleteRepoSecret(owner, repo, secretname, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a repository using a template
     * @param {string} templateOwner name of the template repository owner
     * @param {string} templateRepo name of the template repository
     * @param {GenerateRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public generateRepo(templateOwner: string, templateRepo: string, body?: GenerateRepoOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).generateRepo(templateOwner, templateRepo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the tag object of an annotated tag (not lightweight tags)
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getAnnotatedTag(owner: string, repo: string, sha: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getAnnotatedTag(owner, repo, sha, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the blob of a repository.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getBlob(owner: string, repo: string, sha: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getBlob(owner, repo, sha, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the tree of a repository.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {boolean} [recursive] show all directories and files
     * @param {number} [page] page number; the \&#39;truncated\&#39; field in the response will be true if there are still more items after this page, false if the last page
     * @param {number} [perPage] number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTree(owner: string, repo: string, sha: string, recursive?: boolean, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getTree(owner, repo, sha, recursive, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s forks
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public listForks(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).listForks(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reject a repo transfer
     * @param {string} owner owner of the repo to transfer
     * @param {string} repo name of the repo to transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public rejectRepoTransfer(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).rejectRepoTransfer(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a collaborator to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} collaborator username of the collaborator to add
     * @param {AddCollaboratorOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoAddCollaborator(owner: string, repo: string, collaborator: string, body?: AddCollaboratorOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoAddCollaborator(owner, repo, collaborator, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary add a push mirror to the repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreatePushMirrorOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoAddPushMirror(owner: string, repo: string, body?: CreatePushMirrorOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoAddPushMirror(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a team to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} team team name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoAddTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoAddTeam(owner, repo, team, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a topic to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} topic name of the topic to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoAddTopic(owner: string, repo: string, topic: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoAddTopic(owner, repo, topic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Apply diff patch to repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {UpdateFileOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoApplyDiffPatch(owner: string, repo: string, body: UpdateFileOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoApplyDiffPatch(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel the scheduled auto merge for the given pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to merge
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCancelScheduledAutoMerge(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCancelScheduledAutoMerge(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify multiple files in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {ChangeFilesOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoChangeFiles(owner: string, repo: string, body: ChangeFilesOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoChangeFiles(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if a user is a collaborator of a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} collaborator username of the collaborator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCheckCollaborator(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCheckCollaborator(owner, repo, collaborator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if a team is assigned to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} team team name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCheckTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCheckTeam(owner, repo, team, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a branch
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateBranchRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateBranch(owner: string, repo: string, body?: CreateBranchRepoOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateBranch(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a branch protections for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateBranchProtectionOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateBranchProtection(owner: string, repo: string, body?: CreateBranchProtectionOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateBranchProtection(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a file in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the file to create
     * @param {CreateFileOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateFile(owner: string, repo: string, filepath: string, body: CreateFileOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateFile(owner, repo, filepath, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a hook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateHook(owner: string, repo: string, body?: CreateHookOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateHook(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a key to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateKeyOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateKey(owner: string, repo: string, body?: CreateKeyOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateKey(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreatePullRequestOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreatePullRequest(owner: string, repo: string, body?: CreatePullRequestOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreatePullRequest(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a review to an pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {CreatePullReviewOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreatePullReview(owner: string, repo: string, index: number, body: CreatePullReviewOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreatePullReview(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary create review requests for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {PullReviewRequestOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreatePullReviewRequests(owner: string, repo: string, index: number, body: PullReviewRequestOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreatePullReviewRequests(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateReleaseOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateRelease(owner: string, repo: string, body?: CreateReleaseOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateRelease(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a release attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {File} attachment attachment to upload
     * @param {string} [name] name of the attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateReleaseAttachment(owner: string, repo: string, id: number, attachment: File, name?: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateReleaseAttachment(owner, repo, id, attachment, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a commit status
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {CreateStatusOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateStatus(owner: string, repo: string, sha: string, body?: CreateStatusOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateStatus(owner, repo, sha, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new git tag in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateTagOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateTag(owner: string, repo: string, body?: CreateTagOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateTag(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateWikiPageOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateWikiPage(owner: string, repo: string, body?: CreateWikiPageOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateWikiPage(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a repository
     * @param {string} owner owner of the repo to delete
     * @param {string} repo name of the repo to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDelete(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDelete(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete avatar
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteAvatar(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteAvatar(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific branch from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} branch branch to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteBranch(owner: string, repo: string, branch: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteBranch(owner, repo, branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific branch protection for the repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name name of protected branch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteBranchProtection(owner: string, repo: string, name: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteBranchProtection(owner, repo, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a collaborator from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} collaborator username of the collaborator to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteCollaborator(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteCollaborator(owner, repo, collaborator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a file in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the file to delete
     * @param {DeleteFileOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteFile(owner: string, repo: string, filepath: string, body: DeleteFileOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteFile(owner, repo, filepath, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Git hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteGitHook(owner: string, repo: string, id: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteGitHook(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the hook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteHook(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a key from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the key to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteKey(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteKey(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific review from a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeletePullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeletePullReview(owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary cancel review requests for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {PullReviewRequestOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeletePullReviewRequests(owner: string, repo: string, index: number, body: PullReviewRequestOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeletePullReviewRequests(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deletes a push mirror from a repository by remoteName
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name remote name of the pushMirror
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeletePushMirror(owner: string, repo: string, name: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeletePushMirror(owner, repo, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteRelease(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteRelease(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a release attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {number} attachmentId id of the attachment to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteReleaseAttachment(owner, repo, id, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a release by tag name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag tag name of the release to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteReleaseByTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteReleaseByTag(owner, repo, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a repository\'s tag by name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag name of tag to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteTag(owner, repo, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a team from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} team team name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteTeam(owner, repo, team, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a topic from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} topic name of the topic to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteTopic(owner: string, repo: string, topic: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteTopic(owner, repo, topic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} pageName name of the page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteWikiPage(owner: string, repo: string, pageName: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteWikiPage(owner, repo, pageName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Dismiss a review for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {DismissPullReviewOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDismissPullReview(owner: string, repo: string, index: number, id: number, body: DismissPullReviewOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDismissPullReview(owner, repo, index, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a commit\'s diff or patch
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha SHA of the commit to get
     * @param {RepoDownloadCommitDiffOrPatchDiffTypeEnum} diffType whether the output is diff or patch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDownloadCommitDiffOrPatch(owner: string, repo: string, sha: string, diffType: RepoDownloadCommitDiffOrPatchDiffTypeEnum, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDownloadCommitDiffOrPatch(owner, repo, sha, diffType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a pull request diff or patch
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {RepoDownloadPullDiffOrPatchDiffTypeEnum} diffType whether the output is diff or patch
     * @param {boolean} [binary] whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDownloadPullDiffOrPatch(owner: string, repo: string, index: number, diffType: RepoDownloadPullDiffOrPatchDiffTypeEnum, binary?: boolean, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDownloadPullDiffOrPatch(owner, repo, index, diffType, binary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a repository\'s properties. Only fields that are set will be changed.
     * @param {string} owner owner of the repo to edit
     * @param {string} repo name of the repo to edit
     * @param {EditRepoOption} [body] Properties of a repo that you can edit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEdit(owner: string, repo: string, body?: EditRepoOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEdit(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a branch protections for a repository. Only fields that are set will be changed
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name name of protected branch
     * @param {EditBranchProtectionOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditBranchProtection(owner: string, repo: string, name: string, body?: EditBranchProtectionOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEditBranchProtection(owner, repo, name, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a Git hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id id of the hook to get
     * @param {EditGitHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditGitHook(owner: string, repo: string, id: string, body?: EditGitHookOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEditGitHook(owner, repo, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id index of the hook
     * @param {EditHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditHook(owner: string, repo: string, id: number, body?: EditHookOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEditHook(owner, repo, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to edit
     * @param {EditPullRequestOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditPullRequest(owner: string, repo: string, index: number, body?: EditPullRequestOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEditPullRequest(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release to edit
     * @param {EditReleaseOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditRelease(owner: string, repo: string, id: number, body?: EditReleaseOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEditRelease(owner, repo, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a release attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {number} attachmentId id of the attachment to edit
     * @param {EditAttachmentOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEditReleaseAttachment(owner, repo, id, attachmentId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} pageName name of the page
     * @param {CreateWikiPageOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditWikiPage(owner: string, repo: string, pageName: string, body?: CreateWikiPageOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEditWikiPage(owner, repo, pageName, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGet(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGet(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all commits from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [sha] SHA or branch to start listing commits from (usually \&#39;master\&#39;)
     * @param {string} [path] filepath of a file/dir
     * @param {boolean} [stat] include diff stats for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results (ignored if used with \&#39;path\&#39;)
     * @param {string} [not] commits that match the given specifier will not be listed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetAllCommits(owner: string, repo: string, sha?: string, path?: string, stat?: boolean, verification?: boolean, files?: boolean, page?: number, limit?: number, not?: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetAllCommits(owner, repo, sha, path, stat, verification, files, page, limit, not, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an archive of a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} archive the git reference for download with attached archive format (e.g. master.zip)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetArchive(owner: string, repo: string, archive: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetArchive(owner, repo, archive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return all users that have write access and can be assigned to issues
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetAssignees(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetAssignees(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a specific branch from a repository, including its effective branch protection
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} branch branch to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetBranch(owner: string, repo: string, branch: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetBranch(owner, repo, branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific branch protection for the repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name name of protected branch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetBranchProtection(owner: string, repo: string, name: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetBranchProtection(owner, repo, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a repository by id
     * @param {number} id id of the repo to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetByID(id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetByID(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a commit\'s combined status, by branch/tag/commit reference
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} ref name of branch/tag/commit
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetCombinedStatusByRef(owner: string, repo: string, ref: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetCombinedStatusByRef(owner, repo, ref, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the dir, file, symlink or submodule in the repo
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetContents(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetContents(owner, repo, filepath, ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the metadata of all the entries of the root dir
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetContentsList(owner: string, repo: string, ref?: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetContentsList(owner, repo, ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the EditorConfig definitions of a file in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath filepath of file to get
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetEditorConfig(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetEditorConfig(owner, repo, filepath, ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Git hook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetGitHook(owner: string, repo: string, id: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetGitHook(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a hook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetHook(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the issue config for a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetIssueConfig(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetIssueConfig(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get available issue templates for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetIssueTemplates(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetIssueTemplates(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a repository\'s key by id
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the key to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetKey(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetKey(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get languages and number of bytes of code written
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetLanguages(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetLanguages(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetLatestRelease(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetLatestRelease(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a note corresponding to a single commit from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha a git ref or commit sha
     * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetNote(owner: string, repo: string, sha: string, verification?: boolean, files?: boolean, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetNote(owner, repo, sha, verification, files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetPullRequest(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetPullRequest(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get commits for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetPullRequestCommits(owner: string, repo: string, index: number, page?: number, limit?: number, verification?: boolean, files?: boolean, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetPullRequestCommits(owner, repo, index, page, limit, verification, files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get changed files for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {string} [skipTo] skip to given file
     * @param {RepoGetPullRequestFilesWhitespaceEnum} [whitespace] whitespace behavior
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetPullRequestFiles(owner: string, repo: string, index: number, skipTo?: string, whitespace?: RepoGetPullRequestFilesWhitespaceEnum, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetPullRequestFiles(owner, repo, index, skipTo, whitespace, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific review for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetPullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetPullReview(owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific review for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetPullReviewComments(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetPullReviewComments(owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get push mirror of the repository by remoteName
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name remote name of push mirror
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetPushMirrorByRemoteName(owner: string, repo: string, name: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetPushMirrorByRemoteName(owner, repo, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a file from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath filepath of the file to get
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetRawFile(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetRawFile(owner, repo, filepath, ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a file or it\'s LFS object from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath filepath of the file to get
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetRawFileOrLFS(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetRawFileOrLFS(owner, repo, filepath, ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetRelease(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetRelease(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a release attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {number} attachmentId id of the attachment to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetReleaseAttachment(owner, repo, id, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a release by tag name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag tag name of the release to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetReleaseByTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetReleaseByTag(owner, repo, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get repository permissions for a user
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} collaborator username of the collaborator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetRepoPermissions(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetRepoPermissions(owner, repo, collaborator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return all users that can be requested to review in this repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetReviewers(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetReviewers(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single commit from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha a git ref or commit sha
     * @param {boolean} [stat] include diff stats for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetSingleCommit(owner: string, repo: string, sha: string, stat?: boolean, verification?: boolean, files?: boolean, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetSingleCommit(owner, repo, sha, stat, verification, files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the tag of a repository by tag name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag name of tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetTag(owner, repo, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} pageName name of the page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetWikiPage(owner: string, repo: string, pageName: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetWikiPage(owner, repo, pageName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get revisions of a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} pageName name of the page
     * @param {number} [page] page number of results to return (1-based)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetWikiPageRevisions(owner: string, repo: string, pageName: string, page?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetWikiPageRevisions(owner, repo, pageName, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all wiki pages
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetWikiPages(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetWikiPages(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s activity feeds
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [date] the date of the activities to be found
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListActivityFeeds(owner: string, repo: string, date?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListActivityFeeds(owner, repo, date, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get specified ref or filtered repository\'s refs
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListAllGitRefs(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListAllGitRefs(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List branch protections for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListBranchProtection(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListBranchProtection(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s branches
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListBranches(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListBranches(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s collaborators
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListCollaborators(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListCollaborators(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the Git hooks in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListGitHooks(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListGitHooks(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get specified ref or filtered repository\'s refs
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} ref part or full name of the ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListGitRefs(owner: string, repo: string, ref: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListGitRefs(owner, repo, ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the hooks in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListHooks(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListHooks(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s keys
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [keyId] the key_id to search for
     * @param {string} [fingerprint] fingerprint of the key
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListKeys(owner: string, repo: string, keyId?: number, fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListKeys(owner, repo, keyId, fingerprint, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repo\'s pinned issues
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListPinnedIssues(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListPinnedIssues(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repo\'s pinned pull requests
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListPinnedPullRequests(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListPinnedPullRequests(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repo\'s pull requests
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {RepoListPullRequestsStateEnum} [state] State of pull request: open or closed (optional)
     * @param {RepoListPullRequestsSortEnum} [sort] Type of sort
     * @param {number} [milestone] ID of the milestone
     * @param {Array<number>} [labels] Label IDs
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListPullRequests(owner: string, repo: string, state?: RepoListPullRequestsStateEnum, sort?: RepoListPullRequestsSortEnum, milestone?: number, labels?: Array<number>, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListPullRequests(owner, repo, state, sort, milestone, labels, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all reviews for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListPullReviews(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListPullReviews(owner, repo, index, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all push mirrors of the repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListPushMirrors(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListPushMirrors(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List release\'s attachments
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListReleaseAttachments(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListReleaseAttachments(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repo\'s releases
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {boolean} [draft] filter (exclude / include) drafts, if you dont have repo write access none will show
     * @param {boolean} [preRelease] filter (exclude / include) pre-releases
     * @param {number} [perPage] page size of results, deprecated - use limit
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListReleases(owner: string, repo: string, draft?: boolean, preRelease?: boolean, perPage?: number, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListReleases(owner, repo, draft, preRelease, perPage, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repo\'s stargazers
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListStargazers(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListStargazers(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a commit\'s statuses
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {RepoListStatusesSortEnum} [sort] type of sort
     * @param {RepoListStatusesStateEnum} [state] type of state
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListStatuses(owner: string, repo: string, sha: string, sort?: RepoListStatusesSortEnum, state?: RepoListStatusesStateEnum, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListStatuses(owner, repo, sha, sort, state, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a commit\'s statuses, by branch/tag/commit reference
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} ref name of branch/tag/commit
     * @param {RepoListStatusesByRefSortEnum} [sort] type of sort
     * @param {RepoListStatusesByRefStateEnum} [state] type of state
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListStatusesByRef(owner: string, repo: string, ref: string, sort?: RepoListStatusesByRefSortEnum, state?: RepoListStatusesByRefStateEnum, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListStatusesByRef(owner, repo, ref, sort, state, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repo\'s watchers
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListSubscribers(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListSubscribers(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s tags
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results, default maximum page size is 50
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListTags(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListTags(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s teams
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListTeams(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListTeams(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of topics that a repository has
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListTopics(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListTopics(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Merge a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to merge
     * @param {MergePullRequestOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoMergePullRequest(owner: string, repo: string, index: number, body?: MergePullRequestOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoMergePullRequest(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Migrate a remote git repository
     * @param {MigrateRepoOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoMigrate(body?: MigrateRepoOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoMigrate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sync a mirrored repository
     * @param {string} owner owner of the repo to sync
     * @param {string} repo name of the repo to sync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoMirrorSync(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoMirrorSync(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns if new Issue Pins are allowed
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoNewPinAllowed(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoNewPinAllowed(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if a pull request has been merged
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoPullRequestIsMerged(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoPullRequestIsMerged(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sync all push mirrored repository
     * @param {string} owner owner of the repo to sync
     * @param {string} repo name of the repo to sync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoPushMirrorSync(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoPushMirrorSync(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for repositories
     * @param {string} [q] keyword
     * @param {boolean} [topic] Limit search to repositories with keyword as topic
     * @param {boolean} [includeDesc] include search of keyword within repository description
     * @param {number} [uid] search only for repos that the user with the given id owns or contributes to
     * @param {number} [priorityOwnerId] repo owner to prioritize in the results
     * @param {number} [teamId] search only for repos that belong to the given team id
     * @param {number} [starredBy] search only for repos that the user with the given id has starred
     * @param {boolean} [_private] include private repositories this user has access to (defaults to true)
     * @param {boolean} [isPrivate] show only pubic, private or all repositories (defaults to all)
     * @param {boolean} [template] include template repositories this user has access to (defaults to true)
     * @param {boolean} [archived] show only archived, non-archived or all repositories (defaults to all)
     * @param {string} [mode] type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
     * @param {boolean} [exclusive] if &#x60;uid&#x60; is given, search only for repos that the user owns
     * @param {string} [sort] sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
     * @param {string} [order] sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoSearch(q?: string, topic?: boolean, includeDesc?: boolean, uid?: number, priorityOwnerId?: number, teamId?: number, starredBy?: number, _private?: boolean, isPrivate?: boolean, template?: boolean, archived?: boolean, mode?: string, exclusive?: boolean, sort?: string, order?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoSearch(q, topic, includeDesc, uid, priorityOwnerId, teamId, starredBy, _private, isPrivate, template, archived, mode, exclusive, sort, order, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get signing-key.gpg for given repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoSigningKey(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoSigningKey(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit a pending review to an pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {SubmitPullReviewOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoSubmitPullReview(owner: string, repo: string, index: number, id: number, body: SubmitPullReviewOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoSubmitPullReview(owner, repo, index, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Test a push webhook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the hook to test
     * @param {string} [ref] The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoTestHook(owner: string, repo: string, id: number, ref?: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoTestHook(owner, repo, id, ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repo\'s tracked times
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [user] optional filter by user (available for issue managers)
     * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoTrackedTimes(owner: string, repo: string, user?: string, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoTrackedTimes(owner, repo, user, since, before, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transfer a repo ownership
     * @param {string} owner owner of the repo to transfer
     * @param {string} repo name of the repo to transfer
     * @param {TransferRepoOption} body Transfer Options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoTransfer(owner: string, repo: string, body: TransferRepoOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoTransfer(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel to dismiss a review for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoUnDismissPullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoUnDismissPullReview(owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update avatar
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {UpdateRepoAvatarOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoUpdateAvatar(owner: string, repo: string, body?: UpdateRepoAvatarOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoUpdateAvatar(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a file in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the file to update
     * @param {UpdateFileOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoUpdateFile(owner: string, repo: string, filepath: string, body: UpdateFileOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoUpdateFile(owner, repo, filepath, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Merge PR\'s baseBranch into headBranch
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {RepoUpdatePullRequestStyleEnum} [style] how to update pull request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoUpdatePullRequest(owner: string, repo: string, index: number, style?: RepoUpdatePullRequestStyleEnum, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoUpdatePullRequest(owner, repo, index, style, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Replace list of topics for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {RepoTopicOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoUpdateTopics(owner: string, repo: string, body?: RepoTopicOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoUpdateTopics(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the validation information for a issue config
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoValidateIssueConfig(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoValidateIssueConfig(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary search topics via keyword
     * @param {string} q keywords to search
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public topicSearch(q: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).topicSearch(q, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create or Update a secret value in a repository
     * @param {string} owner owner of the repository
     * @param {string} repo name of the repository
     * @param {string} secretname name of the secret
     * @param {CreateOrUpdateSecretOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public updateRepoSecret(owner: string, repo: string, secretname: string, body?: CreateOrUpdateSecretOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).updateRepoSecret(owner, repo, secretname, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if the current user is watching a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public userCurrentCheckSubscription(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).userCurrentCheckSubscription(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unwatch a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public userCurrentDeleteSubscription(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).userCurrentDeleteSubscription(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Watch a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public userCurrentPutSubscription(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).userCurrentPutSubscription(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a user\'s tracked times in a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} user username of user
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public userTrackedTimes(owner: string, repo: string, user: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).userTrackedTimes(owner, repo, user, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RepoDownloadCommitDiffOrPatchDiffTypeEnum = {
    diff: 'diff',
    patch: 'patch'
} as const;
export type RepoDownloadCommitDiffOrPatchDiffTypeEnum = typeof RepoDownloadCommitDiffOrPatchDiffTypeEnum[keyof typeof RepoDownloadCommitDiffOrPatchDiffTypeEnum];
/**
 * @export
 */
export const RepoDownloadPullDiffOrPatchDiffTypeEnum = {
    diff: 'diff',
    patch: 'patch'
} as const;
export type RepoDownloadPullDiffOrPatchDiffTypeEnum = typeof RepoDownloadPullDiffOrPatchDiffTypeEnum[keyof typeof RepoDownloadPullDiffOrPatchDiffTypeEnum];
/**
 * @export
 */
export const RepoGetPullRequestFilesWhitespaceEnum = {
    ignore_all: 'ignore-all',
    ignore_change: 'ignore-change',
    ignore_eol: 'ignore-eol',
    show_all: 'show-all'
} as const;
export type RepoGetPullRequestFilesWhitespaceEnum = typeof RepoGetPullRequestFilesWhitespaceEnum[keyof typeof RepoGetPullRequestFilesWhitespaceEnum];
/**
 * @export
 */
export const RepoListPullRequestsStateEnum = {
    closed: 'closed',
    open: 'open',
    all: 'all'
} as const;
export type RepoListPullRequestsStateEnum = typeof RepoListPullRequestsStateEnum[keyof typeof RepoListPullRequestsStateEnum];
/**
 * @export
 */
export const RepoListPullRequestsSortEnum = {
    oldest: 'oldest',
    recentupdate: 'recentupdate',
    leastupdate: 'leastupdate',
    mostcomment: 'mostcomment',
    leastcomment: 'leastcomment',
    priority: 'priority'
} as const;
export type RepoListPullRequestsSortEnum = typeof RepoListPullRequestsSortEnum[keyof typeof RepoListPullRequestsSortEnum];
/**
 * @export
 */
export const RepoListStatusesSortEnum = {
    oldest: 'oldest',
    recentupdate: 'recentupdate',
    leastupdate: 'leastupdate',
    leastindex: 'leastindex',
    highestindex: 'highestindex'
} as const;
export type RepoListStatusesSortEnum = typeof RepoListStatusesSortEnum[keyof typeof RepoListStatusesSortEnum];
/**
 * @export
 */
export const RepoListStatusesStateEnum = {
    pending: 'pending',
    success: 'success',
    error: 'error',
    failure: 'failure',
    warning: 'warning'
} as const;
export type RepoListStatusesStateEnum = typeof RepoListStatusesStateEnum[keyof typeof RepoListStatusesStateEnum];
/**
 * @export
 */
export const RepoListStatusesByRefSortEnum = {
    oldest: 'oldest',
    recentupdate: 'recentupdate',
    leastupdate: 'leastupdate',
    leastindex: 'leastindex',
    highestindex: 'highestindex'
} as const;
export type RepoListStatusesByRefSortEnum = typeof RepoListStatusesByRefSortEnum[keyof typeof RepoListStatusesByRefSortEnum];
/**
 * @export
 */
export const RepoListStatusesByRefStateEnum = {
    pending: 'pending',
    success: 'success',
    error: 'error',
    failure: 'failure',
    warning: 'warning'
} as const;
export type RepoListStatusesByRefStateEnum = typeof RepoListStatusesByRefStateEnum[keyof typeof RepoListStatusesByRefStateEnum];
/**
 * @export
 */
export const RepoUpdatePullRequestStyleEnum = {
    merge: 'merge',
    rebase: 'rebase'
} as const;
export type RepoUpdatePullRequestStyleEnum = typeof RepoUpdatePullRequestStyleEnum[keyof typeof RepoUpdatePullRequestStyleEnum];


/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get instance\'s global settings for api
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralAPISettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/api`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get instance\'s global settings for Attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralAttachmentSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/attachment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get instance\'s global settings for repositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralRepositorySettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get instance\'s global settings for ui
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralUISettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/ui`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get instance\'s global settings for api
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeneralAPISettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralAPISettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGeneralAPISettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get instance\'s global settings for Attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeneralAttachmentSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralAttachmentSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGeneralAttachmentSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get instance\'s global settings for repositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeneralRepositorySettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralRepoSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGeneralRepositorySettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get instance\'s global settings for ui
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeneralUISettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralUISettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGeneralUISettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get instance\'s global settings for api
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralAPISettings(options?: any): AxiosPromise<GeneralAPISettings> {
            return localVarFp.getGeneralAPISettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get instance\'s global settings for Attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralAttachmentSettings(options?: any): AxiosPromise<GeneralAttachmentSettings> {
            return localVarFp.getGeneralAttachmentSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get instance\'s global settings for repositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralRepositorySettings(options?: any): AxiosPromise<GeneralRepoSettings> {
            return localVarFp.getGeneralRepositorySettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get instance\'s global settings for ui
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralUISettings(options?: any): AxiosPromise<GeneralUISettings> {
            return localVarFp.getGeneralUISettings(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsApi - interface
 * @export
 * @interface SettingsApi
 */
export interface SettingsApiInterface {
    /**
     * 
     * @summary Get instance\'s global settings for api
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApiInterface
     */
    getGeneralAPISettings(options?: AxiosRequestConfig): AxiosPromise<GeneralAPISettings>;

    /**
     * 
     * @summary Get instance\'s global settings for Attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApiInterface
     */
    getGeneralAttachmentSettings(options?: AxiosRequestConfig): AxiosPromise<GeneralAttachmentSettings>;

    /**
     * 
     * @summary Get instance\'s global settings for repositories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApiInterface
     */
    getGeneralRepositorySettings(options?: AxiosRequestConfig): AxiosPromise<GeneralRepoSettings>;

    /**
     * 
     * @summary Get instance\'s global settings for ui
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApiInterface
     */
    getGeneralUISettings(options?: AxiosRequestConfig): AxiosPromise<GeneralUISettings>;

}

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI implements SettingsApiInterface {
    /**
     * 
     * @summary Get instance\'s global settings for api
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getGeneralAPISettings(options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).getGeneralAPISettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get instance\'s global settings for Attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getGeneralAttachmentSettings(options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).getGeneralAttachmentSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get instance\'s global settings for repositories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getGeneralRepositorySettings(options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).getGeneralRepositorySettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get instance\'s global settings for ui
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getGeneralUISettings(options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).getGeneralUISettings(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a repository
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrentUserRepo: async (body?: CreateRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/repos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a secret in a user scope
         * @param {string} secretname name of the secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserSecret: async (secretname: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'secretname' is not null or undefined
            assertParamExists('deleteUserSecret', 'secretname', secretname)
            const localVarPath = `/user/actions/secrets/{secretname}`
                .replace(`{${"secretname"}}`, encodeURIComponent(String(secretname)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Token to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerificationToken: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/gpg_key_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create or Update a secret value in a user scope
         * @param {string} secretname name of the secret
         * @param {CreateOrUpdateSecretOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSecret: async (secretname: string, body?: CreateOrUpdateSecretOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'secretname' is not null or undefined
            assertParamExists('updateUserSecret', 'secretname', secretname)
            const localVarPath = `/user/actions/secrets/{secretname}`
                .replace(`{${"secretname"}}`, encodeURIComponent(String(secretname)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user settings
         * @param {UserSettingsOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSettings: async (body?: UserSettingsOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add email addresses
         * @param {CreateEmailOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAddEmail: async (body?: CreateEmailOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/emails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if one user is following another user
         * @param {string} username username of following user
         * @param {string} target username of followed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCheckFollowing: async (username: string, target: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userCheckFollowing', 'username', username)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('userCheckFollowing', 'target', target)
            const localVarPath = `/users/{username}/following/{target}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a hook
         * @param {CreateHookOption} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateHook: async (body: CreateHookOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('userCreateHook', 'body', body)
            const localVarPath = `/user/hooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary creates a new OAuth2 application
         * @param {CreateOAuth2ApplicationOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateOAuth2Application: async (body: CreateOAuth2ApplicationOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('userCreateOAuth2Application', 'body', body)
            const localVarPath = `/user/applications/oauth2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an access token
         * @param {string} username username of user
         * @param {CreateAccessTokenOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateToken: async (username: string, body?: CreateAccessTokenOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userCreateToken', 'username', username)
            const localVarPath = `/users/{username}/tokens`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check whether a user is followed by the authenticated user
         * @param {string} username username of followed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentCheckFollowing: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userCurrentCheckFollowing', 'username', username)
            const localVarPath = `/user/following/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Whether the authenticated is starring the repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentCheckStarring: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('userCurrentCheckStarring', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('userCurrentCheckStarring', 'repo', repo)
            const localVarPath = `/user/starred/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unfollow a user
         * @param {string} username username of user to unfollow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteFollow: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userCurrentDeleteFollow', 'username', username)
            const localVarPath = `/user/following/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a GPG key
         * @param {number} id id of key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteGPGKey: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userCurrentDeleteGPGKey', 'id', id)
            const localVarPath = `/user/gpg_keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a public key
         * @param {number} id id of key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteKey: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userCurrentDeleteKey', 'id', id)
            const localVarPath = `/user/keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unstar the given repo
         * @param {string} owner owner of the repo to unstar
         * @param {string} repo name of the repo to unstar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteStar: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('userCurrentDeleteStar', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('userCurrentDeleteStar', 'repo', repo)
            const localVarPath = `/user/starred/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a GPG key
         * @param {number} id id of key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentGetGPGKey: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userCurrentGetGPGKey', 'id', id)
            const localVarPath = `/user/gpg_keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a public key
         * @param {number} id id of key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentGetKey: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userCurrentGetKey', 'id', id)
            const localVarPath = `/user/keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the authenticated user\'s followers
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListFollowers: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/followers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the users that the authenticated user is following
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListFollowing: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/following`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the authenticated user\'s GPG keys
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListGPGKeys: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/gpg_keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the authenticated user\'s public keys
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListKeys: async (fingerprint?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (fingerprint !== undefined) {
                localVarQueryParameter['fingerprint'] = fingerprint;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the repos that the authenticated user owns
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListRepos: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/repos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary The repos that the authenticated user has starred
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListStarred: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/starred`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List repositories watched by the authenticated user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListSubscriptions: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a GPG key
         * @param {CreateGPGKeyOption} [form] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPostGPGKey: async (form?: CreateGPGKeyOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/gpg_keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(form, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a public key
         * @param {CreateKeyOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPostKey: async (body?: CreateKeyOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Follow a user
         * @param {string} username username of user to follow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPutFollow: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userCurrentPutFollow', 'username', username)
            const localVarPath = `/user/following/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Star the given repo
         * @param {string} owner owner of the repo to star
         * @param {string} repo name of the repo to star
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPutStar: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('userCurrentPutStar', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('userCurrentPutStar', 'repo', repo)
            const localVarPath = `/user/starred/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the current user\'s tracked times
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentTrackedTimes: async (page?: number, limit?: number, since?: string, before?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/times`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete an access token
         * @param {string} username username of user
         * @param {string} token token to be deleted, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteAccessToken: async (username: string, token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userDeleteAccessToken', 'username', username)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('userDeleteAccessToken', 'token', token)
            const localVarPath = `/users/{username}/tokens/{token}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)))
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Avatar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteAvatar: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/avatar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete email addresses
         * @param {DeleteEmailOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteEmail: async (body?: DeleteEmailOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/emails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a hook
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteHook: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userDeleteHook', 'id', id)
            const localVarPath = `/user/hooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete an OAuth2 Application
         * @param {number} id token to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteOAuth2Application: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userDeleteOAuth2Application', 'id', id)
            const localVarPath = `/user/applications/oauth2/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a hook
         * @param {number} id id of the hook to update
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEditHook: async (id: number, body?: EditHookOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userEditHook', 'id', id)
            const localVarPath = `/user/hooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user
         * @param {string} username username of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userGet', 'username', username)
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetCurrent: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s heatmap
         * @param {string} username username of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetHeatmapData: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userGetHeatmapData', 'username', username)
            const localVarPath = `/users/{username}/heatmap`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a hook
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetHook: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userGetHook', 'id', id)
            const localVarPath = `/user/hooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get an OAuth2 Application
         * @param {number} id Application ID to be found
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetOAuth2Application: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userGetOAuth2Application', 'id', id)
            const localVarPath = `/user/applications/oauth2/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the authenticated user\'s oauth2 applications
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetOauth2Application: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/applications/oauth2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of all existing stopwatches
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetStopWatches: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/stopwatches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the authenticated user\'s access tokens
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetTokens: async (username: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userGetTokens', 'username', username)
            const localVarPath = `/users/{username}/tokens`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a user\'s activity feeds
         * @param {string} username username of user
         * @param {boolean} [onlyPerformedBy] if true, only show actions performed by the requested user
         * @param {string} [date] the date of the activities to be found
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListActivityFeeds: async (username: string, onlyPerformedBy?: boolean, date?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListActivityFeeds', 'username', username)
            const localVarPath = `/users/{username}/activities/feeds`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (onlyPerformedBy !== undefined) {
                localVarQueryParameter['only-performed-by'] = onlyPerformedBy;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substring(0,10) :
                    date;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the authenticated user\'s email addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListEmails: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/emails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the given user\'s followers
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListFollowers: async (username: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListFollowers', 'username', username)
            const localVarPath = `/users/{username}/followers`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the users that the given user is following
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListFollowing: async (username: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListFollowing', 'username', username)
            const localVarPath = `/users/{username}/following`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the given user\'s GPG keys
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListGPGKeys: async (username: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListGPGKeys', 'username', username)
            const localVarPath = `/users/{username}/gpg_keys`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the authenticated user\'s webhooks
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListHooks: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/hooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the given user\'s public keys
         * @param {string} username username of user
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListKeys: async (username: string, fingerprint?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListKeys', 'username', username)
            const localVarPath = `/users/{username}/keys`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (fingerprint !== undefined) {
                localVarQueryParameter['fingerprint'] = fingerprint;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the repos owned by the given user
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListRepos: async (username: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListRepos', 'username', username)
            const localVarPath = `/users/{username}/repos`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary The repos that the given user has starred
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListStarred: async (username: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListStarred', 'username', username)
            const localVarPath = `/users/{username}/starred`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the repositories watched by a user
         * @param {string} username username of the user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListSubscriptions: async (username: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListSubscriptions', 'username', username)
            const localVarPath = `/users/{username}/subscriptions`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all the teams a user belongs to
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListTeams: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for users
         * @param {string} [q] keyword
         * @param {number} [uid] ID of the user to search for
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearch: async (q?: string, uid?: number, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Avatar
         * @param {UpdateUserAvatarOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdateAvatar: async (body?: UpdateUserAvatarOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/avatar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update an OAuth2 Application, this includes regenerating the client secret
         * @param {number} id application to be updated
         * @param {CreateOAuth2ApplicationOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdateOAuth2Application: async (id: number, body: CreateOAuth2ApplicationOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userUpdateOAuth2Application', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('userUpdateOAuth2Application', 'body', body)
            const localVarPath = `/user/applications/oauth2/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify a GPG key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userVerifyGPGKey: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/gpg_key_verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a repository
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCurrentUserRepo(body?: CreateRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCurrentUserRepo(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a secret in a user scope
         * @param {string} secretname name of the secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserSecret(secretname: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserSecret(secretname, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSettings>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Token to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVerificationToken(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVerificationToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create or Update a secret value in a user scope
         * @param {string} secretname name of the secret
         * @param {CreateOrUpdateSecretOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserSecret(secretname: string, body?: CreateOrUpdateSecretOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserSecret(secretname, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user settings
         * @param {UserSettingsOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserSettings(body?: UserSettingsOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSettings>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserSettings(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add email addresses
         * @param {CreateEmailOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAddEmail(body?: CreateEmailOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Email>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAddEmail(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if one user is following another user
         * @param {string} username username of following user
         * @param {string} target username of followed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCheckFollowing(username: string, target: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCheckFollowing(username, target, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a hook
         * @param {CreateHookOption} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCreateHook(body: CreateHookOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCreateHook(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary creates a new OAuth2 application
         * @param {CreateOAuth2ApplicationOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCreateOAuth2Application(body: CreateOAuth2ApplicationOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCreateOAuth2Application(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an access token
         * @param {string} username username of user
         * @param {CreateAccessTokenOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCreateToken(username: string, body?: CreateAccessTokenOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCreateToken(username, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check whether a user is followed by the authenticated user
         * @param {string} username username of followed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentCheckFollowing(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentCheckFollowing(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Whether the authenticated is starring the repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentCheckStarring(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentCheckStarring(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unfollow a user
         * @param {string} username username of user to unfollow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentDeleteFollow(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentDeleteFollow(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a GPG key
         * @param {number} id id of key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentDeleteGPGKey(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentDeleteGPGKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a public key
         * @param {number} id id of key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentDeleteKey(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentDeleteKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unstar the given repo
         * @param {string} owner owner of the repo to unstar
         * @param {string} repo name of the repo to unstar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentDeleteStar(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentDeleteStar(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a GPG key
         * @param {number} id id of key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentGetGPGKey(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GPGKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentGetGPGKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a public key
         * @param {number} id id of key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentGetKey(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentGetKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the authenticated user\'s followers
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentListFollowers(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentListFollowers(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the users that the authenticated user is following
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentListFollowing(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentListFollowing(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the authenticated user\'s GPG keys
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentListGPGKeys(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GPGKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentListGPGKeys(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the authenticated user\'s public keys
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentListKeys(fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentListKeys(fingerprint, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the repos that the authenticated user owns
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentListRepos(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentListRepos(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary The repos that the authenticated user has starred
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentListStarred(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentListStarred(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List repositories watched by the authenticated user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentListSubscriptions(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentListSubscriptions(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a GPG key
         * @param {CreateGPGKeyOption} [form] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentPostGPGKey(form?: CreateGPGKeyOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GPGKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentPostGPGKey(form, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a public key
         * @param {CreateKeyOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentPostKey(body?: CreateKeyOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentPostKey(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Follow a user
         * @param {string} username username of user to follow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentPutFollow(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentPutFollow(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Star the given repo
         * @param {string} owner owner of the repo to star
         * @param {string} repo name of the repo to star
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentPutStar(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentPutStar(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the current user\'s tracked times
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentTrackedTimes(page?: number, limit?: number, since?: string, before?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrackedTime>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentTrackedTimes(page, limit, since, before, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary delete an access token
         * @param {string} username username of user
         * @param {string} token token to be deleted, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDeleteAccessToken(username: string, token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDeleteAccessToken(username, token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Avatar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDeleteAvatar(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDeleteAvatar(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete email addresses
         * @param {DeleteEmailOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDeleteEmail(body?: DeleteEmailOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDeleteEmail(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a hook
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDeleteHook(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDeleteHook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary delete an OAuth2 Application
         * @param {number} id token to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDeleteOAuth2Application(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDeleteOAuth2Application(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a hook
         * @param {number} id id of the hook to update
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userEditHook(id: number, body?: EditHookOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userEditHook(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a user
         * @param {string} username username of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGet(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGet(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetCurrent(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetCurrent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a user\'s heatmap
         * @param {string} username username of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetHeatmapData(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserHeatmapData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetHeatmapData(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a hook
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetHook(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetHook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get an OAuth2 Application
         * @param {number} id Application ID to be found
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetOAuth2Application(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetOAuth2Application(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the authenticated user\'s oauth2 applications
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetOauth2Application(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OAuth2Application>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetOauth2Application(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get list of all existing stopwatches
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetStopWatches(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StopWatch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetStopWatches(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the authenticated user\'s access tokens
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetTokens(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetTokens(username, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a user\'s activity feeds
         * @param {string} username username of user
         * @param {boolean} [onlyPerformedBy] if true, only show actions performed by the requested user
         * @param {string} [date] the date of the activities to be found
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListActivityFeeds(username: string, onlyPerformedBy?: boolean, date?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Activity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListActivityFeeds(username, onlyPerformedBy, date, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the authenticated user\'s email addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListEmails(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Email>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListEmails(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the given user\'s followers
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListFollowers(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListFollowers(username, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the users that the given user is following
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListFollowing(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListFollowing(username, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the given user\'s GPG keys
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListGPGKeys(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GPGKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListGPGKeys(username, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the authenticated user\'s webhooks
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListHooks(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hook>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListHooks(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the given user\'s public keys
         * @param {string} username username of user
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListKeys(username: string, fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListKeys(username, fingerprint, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the repos owned by the given user
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListRepos(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListRepos(username, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary The repos that the given user has starred
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListStarred(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListStarred(username, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the repositories watched by a user
         * @param {string} username username of the user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListSubscriptions(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListSubscriptions(username, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all the teams a user belongs to
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListTeams(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Team>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListTeams(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search for users
         * @param {string} [q] keyword
         * @param {number} [uid] ID of the user to search for
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSearch(q?: string, uid?: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSearch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSearch(q, uid, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Avatar
         * @param {UpdateUserAvatarOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUpdateAvatar(body?: UpdateUserAvatarOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUpdateAvatar(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary update an OAuth2 Application, this includes regenerating the client secret
         * @param {number} id application to be updated
         * @param {CreateOAuth2ApplicationOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUpdateOAuth2Application(id: number, body: CreateOAuth2ApplicationOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUpdateOAuth2Application(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Verify a GPG key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userVerifyGPGKey(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GPGKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userVerifyGPGKey(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a repository
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrentUserRepo(body?: CreateRepoOption, options?: any): AxiosPromise<Repository> {
            return localVarFp.createCurrentUserRepo(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a secret in a user scope
         * @param {string} secretname name of the secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserSecret(secretname: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserSecret(secretname, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSettings(options?: any): AxiosPromise<Array<UserSettings>> {
            return localVarFp.getUserSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Token to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerificationToken(options?: any): AxiosPromise<string> {
            return localVarFp.getVerificationToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create or Update a secret value in a user scope
         * @param {string} secretname name of the secret
         * @param {CreateOrUpdateSecretOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSecret(secretname: string, body?: CreateOrUpdateSecretOption, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserSecret(secretname, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user settings
         * @param {UserSettingsOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSettings(body?: UserSettingsOptions, options?: any): AxiosPromise<Array<UserSettings>> {
            return localVarFp.updateUserSettings(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add email addresses
         * @param {CreateEmailOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAddEmail(body?: CreateEmailOption, options?: any): AxiosPromise<Array<Email>> {
            return localVarFp.userAddEmail(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if one user is following another user
         * @param {string} username username of following user
         * @param {string} target username of followed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCheckFollowing(username: string, target: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCheckFollowing(username, target, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a hook
         * @param {CreateHookOption} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateHook(body: CreateHookOption, options?: any): AxiosPromise<Hook> {
            return localVarFp.userCreateHook(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary creates a new OAuth2 application
         * @param {CreateOAuth2ApplicationOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateOAuth2Application(body: CreateOAuth2ApplicationOptions, options?: any): AxiosPromise<OAuth2Application> {
            return localVarFp.userCreateOAuth2Application(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an access token
         * @param {string} username username of user
         * @param {CreateAccessTokenOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateToken(username: string, body?: CreateAccessTokenOption, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.userCreateToken(username, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check whether a user is followed by the authenticated user
         * @param {string} username username of followed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentCheckFollowing(username: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentCheckFollowing(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Whether the authenticated is starring the repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentCheckStarring(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentCheckStarring(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unfollow a user
         * @param {string} username username of user to unfollow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteFollow(username: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentDeleteFollow(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a GPG key
         * @param {number} id id of key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteGPGKey(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentDeleteGPGKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a public key
         * @param {number} id id of key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteKey(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentDeleteKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unstar the given repo
         * @param {string} owner owner of the repo to unstar
         * @param {string} repo name of the repo to unstar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteStar(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentDeleteStar(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a GPG key
         * @param {number} id id of key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentGetGPGKey(id: number, options?: any): AxiosPromise<GPGKey> {
            return localVarFp.userCurrentGetGPGKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a public key
         * @param {number} id id of key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentGetKey(id: number, options?: any): AxiosPromise<PublicKey> {
            return localVarFp.userCurrentGetKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the authenticated user\'s followers
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListFollowers(page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.userCurrentListFollowers(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the users that the authenticated user is following
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListFollowing(page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.userCurrentListFollowing(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the authenticated user\'s GPG keys
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListGPGKeys(page?: number, limit?: number, options?: any): AxiosPromise<Array<GPGKey>> {
            return localVarFp.userCurrentListGPGKeys(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the authenticated user\'s public keys
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListKeys(fingerprint?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<PublicKey>> {
            return localVarFp.userCurrentListKeys(fingerprint, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the repos that the authenticated user owns
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListRepos(page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.userCurrentListRepos(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary The repos that the authenticated user has starred
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListStarred(page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.userCurrentListStarred(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List repositories watched by the authenticated user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListSubscriptions(page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.userCurrentListSubscriptions(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a GPG key
         * @param {CreateGPGKeyOption} [form] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPostGPGKey(form?: CreateGPGKeyOption, options?: any): AxiosPromise<GPGKey> {
            return localVarFp.userCurrentPostGPGKey(form, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a public key
         * @param {CreateKeyOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPostKey(body?: CreateKeyOption, options?: any): AxiosPromise<PublicKey> {
            return localVarFp.userCurrentPostKey(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Follow a user
         * @param {string} username username of user to follow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPutFollow(username: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentPutFollow(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Star the given repo
         * @param {string} owner owner of the repo to star
         * @param {string} repo name of the repo to star
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPutStar(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentPutStar(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the current user\'s tracked times
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentTrackedTimes(page?: number, limit?: number, since?: string, before?: string, options?: any): AxiosPromise<Array<TrackedTime>> {
            return localVarFp.userCurrentTrackedTimes(page, limit, since, before, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary delete an access token
         * @param {string} username username of user
         * @param {string} token token to be deleted, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteAccessToken(username: string, token: string, options?: any): AxiosPromise<void> {
            return localVarFp.userDeleteAccessToken(username, token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Avatar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteAvatar(options?: any): AxiosPromise<void> {
            return localVarFp.userDeleteAvatar(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete email addresses
         * @param {DeleteEmailOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteEmail(body?: DeleteEmailOption, options?: any): AxiosPromise<void> {
            return localVarFp.userDeleteEmail(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a hook
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteHook(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.userDeleteHook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary delete an OAuth2 Application
         * @param {number} id token to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteOAuth2Application(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.userDeleteOAuth2Application(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a hook
         * @param {number} id id of the hook to update
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEditHook(id: number, body?: EditHookOption, options?: any): AxiosPromise<Hook> {
            return localVarFp.userEditHook(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user
         * @param {string} username username of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet(username: string, options?: any): AxiosPromise<User> {
            return localVarFp.userGet(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetCurrent(options?: any): AxiosPromise<User> {
            return localVarFp.userGetCurrent(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s heatmap
         * @param {string} username username of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetHeatmapData(username: string, options?: any): AxiosPromise<Array<UserHeatmapData>> {
            return localVarFp.userGetHeatmapData(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a hook
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetHook(id: number, options?: any): AxiosPromise<Hook> {
            return localVarFp.userGetHook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get an OAuth2 Application
         * @param {number} id Application ID to be found
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetOAuth2Application(id: number, options?: any): AxiosPromise<OAuth2Application> {
            return localVarFp.userGetOAuth2Application(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the authenticated user\'s oauth2 applications
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetOauth2Application(page?: number, limit?: number, options?: any): AxiosPromise<Array<OAuth2Application>> {
            return localVarFp.userGetOauth2Application(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of all existing stopwatches
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetStopWatches(page?: number, limit?: number, options?: any): AxiosPromise<Array<StopWatch>> {
            return localVarFp.userGetStopWatches(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the authenticated user\'s access tokens
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetTokens(username: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<AccessToken>> {
            return localVarFp.userGetTokens(username, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a user\'s activity feeds
         * @param {string} username username of user
         * @param {boolean} [onlyPerformedBy] if true, only show actions performed by the requested user
         * @param {string} [date] the date of the activities to be found
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListActivityFeeds(username: string, onlyPerformedBy?: boolean, date?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Activity>> {
            return localVarFp.userListActivityFeeds(username, onlyPerformedBy, date, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the authenticated user\'s email addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListEmails(options?: any): AxiosPromise<Array<Email>> {
            return localVarFp.userListEmails(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the given user\'s followers
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListFollowers(username: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.userListFollowers(username, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the users that the given user is following
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListFollowing(username: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.userListFollowing(username, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the given user\'s GPG keys
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListGPGKeys(username: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<GPGKey>> {
            return localVarFp.userListGPGKeys(username, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the authenticated user\'s webhooks
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListHooks(page?: number, limit?: number, options?: any): AxiosPromise<Array<Hook>> {
            return localVarFp.userListHooks(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the given user\'s public keys
         * @param {string} username username of user
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListKeys(username: string, fingerprint?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<PublicKey>> {
            return localVarFp.userListKeys(username, fingerprint, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the repos owned by the given user
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListRepos(username: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.userListRepos(username, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary The repos that the given user has starred
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListStarred(username: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.userListStarred(username, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the repositories watched by a user
         * @param {string} username username of the user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListSubscriptions(username: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.userListSubscriptions(username, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all the teams a user belongs to
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListTeams(page?: number, limit?: number, options?: any): AxiosPromise<Array<Team>> {
            return localVarFp.userListTeams(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for users
         * @param {string} [q] keyword
         * @param {number} [uid] ID of the user to search for
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearch(q?: string, uid?: number, page?: number, limit?: number, options?: any): AxiosPromise<UserSearch200Response> {
            return localVarFp.userSearch(q, uid, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Avatar
         * @param {UpdateUserAvatarOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdateAvatar(body?: UpdateUserAvatarOption, options?: any): AxiosPromise<void> {
            return localVarFp.userUpdateAvatar(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update an OAuth2 Application, this includes regenerating the client secret
         * @param {number} id application to be updated
         * @param {CreateOAuth2ApplicationOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdateOAuth2Application(id: number, body: CreateOAuth2ApplicationOptions, options?: any): AxiosPromise<OAuth2Application> {
            return localVarFp.userUpdateOAuth2Application(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify a GPG key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userVerifyGPGKey(options?: any): AxiosPromise<GPGKey> {
            return localVarFp.userVerifyGPGKey(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
    /**
     * 
     * @summary Create a repository
     * @param {CreateRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    createCurrentUserRepo(body?: CreateRepoOption, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Delete a secret in a user scope
     * @param {string} secretname name of the secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    deleteUserSecret(secretname: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get user settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUserSettings(options?: AxiosRequestConfig): AxiosPromise<Array<UserSettings>>;

    /**
     * 
     * @summary Get a Token to verify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getVerificationToken(options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Create or Update a secret value in a user scope
     * @param {string} secretname name of the secret
     * @param {CreateOrUpdateSecretOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    updateUserSecret(secretname: string, body?: CreateOrUpdateSecretOption, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Update user settings
     * @param {UserSettingsOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    updateUserSettings(body?: UserSettingsOptions, options?: AxiosRequestConfig): AxiosPromise<Array<UserSettings>>;

    /**
     * 
     * @summary Add email addresses
     * @param {CreateEmailOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userAddEmail(body?: CreateEmailOption, options?: AxiosRequestConfig): AxiosPromise<Array<Email>>;

    /**
     * 
     * @summary Check if one user is following another user
     * @param {string} username username of following user
     * @param {string} target username of followed user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCheckFollowing(username: string, target: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Create a hook
     * @param {CreateHookOption} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCreateHook(body: CreateHookOption, options?: AxiosRequestConfig): AxiosPromise<Hook>;

    /**
     * 
     * @summary creates a new OAuth2 application
     * @param {CreateOAuth2ApplicationOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCreateOAuth2Application(body: CreateOAuth2ApplicationOptions, options?: AxiosRequestConfig): AxiosPromise<OAuth2Application>;

    /**
     * 
     * @summary Create an access token
     * @param {string} username username of user
     * @param {CreateAccessTokenOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCreateToken(username: string, body?: CreateAccessTokenOption, options?: AxiosRequestConfig): AxiosPromise<AccessToken>;

    /**
     * 
     * @summary Check whether a user is followed by the authenticated user
     * @param {string} username username of followed user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentCheckFollowing(username: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Whether the authenticated is starring the repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentCheckStarring(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Unfollow a user
     * @param {string} username username of user to unfollow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentDeleteFollow(username: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Remove a GPG key
     * @param {number} id id of key to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentDeleteGPGKey(id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a public key
     * @param {number} id id of key to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentDeleteKey(id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Unstar the given repo
     * @param {string} owner owner of the repo to unstar
     * @param {string} repo name of the repo to unstar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentDeleteStar(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get a GPG key
     * @param {number} id id of key to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentGetGPGKey(id: number, options?: AxiosRequestConfig): AxiosPromise<GPGKey>;

    /**
     * 
     * @summary Get a public key
     * @param {number} id id of key to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentGetKey(id: number, options?: AxiosRequestConfig): AxiosPromise<PublicKey>;

    /**
     * 
     * @summary List the authenticated user\'s followers
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentListFollowers(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary List the users that the authenticated user is following
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentListFollowing(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary List the authenticated user\'s GPG keys
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentListGPGKeys(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<GPGKey>>;

    /**
     * 
     * @summary List the authenticated user\'s public keys
     * @param {string} [fingerprint] fingerprint of the key
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentListKeys(fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<PublicKey>>;

    /**
     * 
     * @summary List the repos that the authenticated user owns
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentListRepos(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Repository>>;

    /**
     * 
     * @summary The repos that the authenticated user has starred
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentListStarred(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Repository>>;

    /**
     * 
     * @summary List repositories watched by the authenticated user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentListSubscriptions(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Repository>>;

    /**
     * 
     * @summary Create a GPG key
     * @param {CreateGPGKeyOption} [form] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentPostGPGKey(form?: CreateGPGKeyOption, options?: AxiosRequestConfig): AxiosPromise<GPGKey>;

    /**
     * 
     * @summary Create a public key
     * @param {CreateKeyOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentPostKey(body?: CreateKeyOption, options?: AxiosRequestConfig): AxiosPromise<PublicKey>;

    /**
     * 
     * @summary Follow a user
     * @param {string} username username of user to follow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentPutFollow(username: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Star the given repo
     * @param {string} owner owner of the repo to star
     * @param {string} repo name of the repo to star
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentPutStar(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary List the current user\'s tracked times
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentTrackedTimes(page?: number, limit?: number, since?: string, before?: string, options?: AxiosRequestConfig): AxiosPromise<Array<TrackedTime>>;

    /**
     * 
     * @summary delete an access token
     * @param {string} username username of user
     * @param {string} token token to be deleted, identified by ID and if not available by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userDeleteAccessToken(username: string, token: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete Avatar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userDeleteAvatar(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete email addresses
     * @param {DeleteEmailOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userDeleteEmail(body?: DeleteEmailOption, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a hook
     * @param {number} id id of the hook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userDeleteHook(id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary delete an OAuth2 Application
     * @param {number} id token to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userDeleteOAuth2Application(id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Update a hook
     * @param {number} id id of the hook to update
     * @param {EditHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userEditHook(id: number, body?: EditHookOption, options?: AxiosRequestConfig): AxiosPromise<Hook>;

    /**
     * 
     * @summary Get a user
     * @param {string} username username of user to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userGet(username: string, options?: AxiosRequestConfig): AxiosPromise<User>;

    /**
     * 
     * @summary Get the authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userGetCurrent(options?: AxiosRequestConfig): AxiosPromise<User>;

    /**
     * 
     * @summary Get a user\'s heatmap
     * @param {string} username username of user to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userGetHeatmapData(username: string, options?: AxiosRequestConfig): AxiosPromise<Array<UserHeatmapData>>;

    /**
     * 
     * @summary Get a hook
     * @param {number} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userGetHook(id: number, options?: AxiosRequestConfig): AxiosPromise<Hook>;

    /**
     * 
     * @summary get an OAuth2 Application
     * @param {number} id Application ID to be found
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userGetOAuth2Application(id: number, options?: AxiosRequestConfig): AxiosPromise<OAuth2Application>;

    /**
     * 
     * @summary List the authenticated user\'s oauth2 applications
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userGetOauth2Application(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<OAuth2Application>>;

    /**
     * 
     * @summary Get list of all existing stopwatches
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userGetStopWatches(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<StopWatch>>;

    /**
     * 
     * @summary List the authenticated user\'s access tokens
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userGetTokens(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<AccessToken>>;

    /**
     * 
     * @summary List a user\'s activity feeds
     * @param {string} username username of user
     * @param {boolean} [onlyPerformedBy] if true, only show actions performed by the requested user
     * @param {string} [date] the date of the activities to be found
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListActivityFeeds(username: string, onlyPerformedBy?: boolean, date?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Activity>>;

    /**
     * 
     * @summary List the authenticated user\'s email addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListEmails(options?: AxiosRequestConfig): AxiosPromise<Array<Email>>;

    /**
     * 
     * @summary List the given user\'s followers
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListFollowers(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary List the users that the given user is following
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListFollowing(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary List the given user\'s GPG keys
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListGPGKeys(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<GPGKey>>;

    /**
     * 
     * @summary List the authenticated user\'s webhooks
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListHooks(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Hook>>;

    /**
     * 
     * @summary List the given user\'s public keys
     * @param {string} username username of user
     * @param {string} [fingerprint] fingerprint of the key
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListKeys(username: string, fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<PublicKey>>;

    /**
     * 
     * @summary List the repos owned by the given user
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListRepos(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Repository>>;

    /**
     * 
     * @summary The repos that the given user has starred
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListStarred(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Repository>>;

    /**
     * 
     * @summary List the repositories watched by a user
     * @param {string} username username of the user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListSubscriptions(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Repository>>;

    /**
     * 
     * @summary List all the teams a user belongs to
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListTeams(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Team>>;

    /**
     * 
     * @summary Search for users
     * @param {string} [q] keyword
     * @param {number} [uid] ID of the user to search for
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userSearch(q?: string, uid?: number, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<UserSearch200Response>;

    /**
     * 
     * @summary Update Avatar
     * @param {UpdateUserAvatarOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userUpdateAvatar(body?: UpdateUserAvatarOption, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary update an OAuth2 Application, this includes regenerating the client secret
     * @param {number} id application to be updated
     * @param {CreateOAuth2ApplicationOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userUpdateOAuth2Application(id: number, body: CreateOAuth2ApplicationOptions, options?: AxiosRequestConfig): AxiosPromise<OAuth2Application>;

    /**
     * 
     * @summary Verify a GPG key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userVerifyGPGKey(options?: AxiosRequestConfig): AxiosPromise<GPGKey>;

}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI implements UserApiInterface {
    /**
     * 
     * @summary Create a repository
     * @param {CreateRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createCurrentUserRepo(body?: CreateRepoOption, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).createCurrentUserRepo(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a secret in a user scope
     * @param {string} secretname name of the secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUserSecret(secretname: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteUserSecret(secretname, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserSettings(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Token to verify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getVerificationToken(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getVerificationToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create or Update a secret value in a user scope
     * @param {string} secretname name of the secret
     * @param {CreateOrUpdateSecretOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserSecret(secretname: string, body?: CreateOrUpdateSecretOption, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUserSecret(secretname, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user settings
     * @param {UserSettingsOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserSettings(body?: UserSettingsOptions, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUserSettings(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add email addresses
     * @param {CreateEmailOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userAddEmail(body?: CreateEmailOption, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userAddEmail(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if one user is following another user
     * @param {string} username username of following user
     * @param {string} target username of followed user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCheckFollowing(username: string, target: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCheckFollowing(username, target, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a hook
     * @param {CreateHookOption} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCreateHook(body: CreateHookOption, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCreateHook(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary creates a new OAuth2 application
     * @param {CreateOAuth2ApplicationOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCreateOAuth2Application(body: CreateOAuth2ApplicationOptions, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCreateOAuth2Application(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an access token
     * @param {string} username username of user
     * @param {CreateAccessTokenOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCreateToken(username: string, body?: CreateAccessTokenOption, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCreateToken(username, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check whether a user is followed by the authenticated user
     * @param {string} username username of followed user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentCheckFollowing(username: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentCheckFollowing(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Whether the authenticated is starring the repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentCheckStarring(owner: string, repo: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentCheckStarring(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unfollow a user
     * @param {string} username username of user to unfollow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentDeleteFollow(username: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentDeleteFollow(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a GPG key
     * @param {number} id id of key to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentDeleteGPGKey(id: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentDeleteGPGKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a public key
     * @param {number} id id of key to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentDeleteKey(id: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentDeleteKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unstar the given repo
     * @param {string} owner owner of the repo to unstar
     * @param {string} repo name of the repo to unstar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentDeleteStar(owner: string, repo: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentDeleteStar(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a GPG key
     * @param {number} id id of key to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentGetGPGKey(id: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentGetGPGKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a public key
     * @param {number} id id of key to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentGetKey(id: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentGetKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the authenticated user\'s followers
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentListFollowers(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentListFollowers(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the users that the authenticated user is following
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentListFollowing(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentListFollowing(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the authenticated user\'s GPG keys
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentListGPGKeys(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentListGPGKeys(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the authenticated user\'s public keys
     * @param {string} [fingerprint] fingerprint of the key
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentListKeys(fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentListKeys(fingerprint, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the repos that the authenticated user owns
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentListRepos(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentListRepos(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary The repos that the authenticated user has starred
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentListStarred(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentListStarred(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List repositories watched by the authenticated user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentListSubscriptions(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentListSubscriptions(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a GPG key
     * @param {CreateGPGKeyOption} [form] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentPostGPGKey(form?: CreateGPGKeyOption, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentPostGPGKey(form, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a public key
     * @param {CreateKeyOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentPostKey(body?: CreateKeyOption, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentPostKey(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Follow a user
     * @param {string} username username of user to follow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentPutFollow(username: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentPutFollow(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Star the given repo
     * @param {string} owner owner of the repo to star
     * @param {string} repo name of the repo to star
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentPutStar(owner: string, repo: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentPutStar(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the current user\'s tracked times
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentTrackedTimes(page?: number, limit?: number, since?: string, before?: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentTrackedTimes(page, limit, since, before, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary delete an access token
     * @param {string} username username of user
     * @param {string} token token to be deleted, identified by ID and if not available by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userDeleteAccessToken(username: string, token: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userDeleteAccessToken(username, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Avatar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userDeleteAvatar(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userDeleteAvatar(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete email addresses
     * @param {DeleteEmailOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userDeleteEmail(body?: DeleteEmailOption, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userDeleteEmail(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a hook
     * @param {number} id id of the hook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userDeleteHook(id: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userDeleteHook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary delete an OAuth2 Application
     * @param {number} id token to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userDeleteOAuth2Application(id: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userDeleteOAuth2Application(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a hook
     * @param {number} id id of the hook to update
     * @param {EditHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userEditHook(id: number, body?: EditHookOption, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userEditHook(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user
     * @param {string} username username of user to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGet(username: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGet(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetCurrent(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGetCurrent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s heatmap
     * @param {string} username username of user to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetHeatmapData(username: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGetHeatmapData(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a hook
     * @param {number} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetHook(id: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGetHook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get an OAuth2 Application
     * @param {number} id Application ID to be found
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetOAuth2Application(id: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGetOAuth2Application(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the authenticated user\'s oauth2 applications
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetOauth2Application(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGetOauth2Application(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of all existing stopwatches
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetStopWatches(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGetStopWatches(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the authenticated user\'s access tokens
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetTokens(username: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGetTokens(username, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a user\'s activity feeds
     * @param {string} username username of user
     * @param {boolean} [onlyPerformedBy] if true, only show actions performed by the requested user
     * @param {string} [date] the date of the activities to be found
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListActivityFeeds(username: string, onlyPerformedBy?: boolean, date?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListActivityFeeds(username, onlyPerformedBy, date, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the authenticated user\'s email addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListEmails(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListEmails(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the given user\'s followers
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListFollowers(username: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListFollowers(username, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the users that the given user is following
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListFollowing(username: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListFollowing(username, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the given user\'s GPG keys
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListGPGKeys(username: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListGPGKeys(username, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the authenticated user\'s webhooks
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListHooks(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListHooks(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the given user\'s public keys
     * @param {string} username username of user
     * @param {string} [fingerprint] fingerprint of the key
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListKeys(username: string, fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListKeys(username, fingerprint, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the repos owned by the given user
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListRepos(username: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListRepos(username, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary The repos that the given user has starred
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListStarred(username: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListStarred(username, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the repositories watched by a user
     * @param {string} username username of the user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListSubscriptions(username: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListSubscriptions(username, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all the teams a user belongs to
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListTeams(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListTeams(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for users
     * @param {string} [q] keyword
     * @param {number} [uid] ID of the user to search for
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userSearch(q?: string, uid?: number, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userSearch(q, uid, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Avatar
     * @param {UpdateUserAvatarOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userUpdateAvatar(body?: UpdateUserAvatarOption, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userUpdateAvatar(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update an OAuth2 Application, this includes regenerating the client secret
     * @param {number} id application to be updated
     * @param {CreateOAuth2ApplicationOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userUpdateOAuth2Application(id: number, body: CreateOAuth2ApplicationOptions, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userUpdateOAuth2Application(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify a GPG key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userVerifyGPGKey(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userVerifyGPGKey(options).then((request) => request(this.axios, this.basePath));
    }
}



